// forkmark, v1.0.1
// Copyright (c)2017 md.nachuo.com (zhangfucheng).
// Distributed under MIT license
// https://coding.net/u/forger

!function(g,n){if("object"==typeof exports&&"object"==typeof module)module.exports=n();else if("function"==typeof define&&define.amd)define([],n);else{var I=n();for(var t in I)("object"==typeof exports?exports:g)[t]=I[t]}}(this,function(){return function(g){function n(g){delete installedChunks[g]}function I(g){var n=document.getElementsByTagName("head")[0],I=document.createElement("script");I.type="text/javascript",I.charset="utf-8",I.src=Q.p+""+g+"."+m+".hot-update.js",n.appendChild(I)}function t(){return new Promise(function(g,n){if("undefined"==typeof XMLHttpRequest)return n(new Error("No browser support"));try{var I=new XMLHttpRequest,t=Q.p+""+m+".hot-update.json";I.open("GET",t,!0),I.timeout=1e4,I.send(null)}catch(g){return n(g)}I.onreadystatechange=function(){if(4===I.readyState)if(0===I.status)n(new Error("Manifest request to "+t+" timed out."));else if(404===I.status)g();else if(200!==I.status&&304!==I.status)n(new Error("Manifest request to "+t+" failed."));else{try{var e=JSON.parse(I.responseText)}catch(g){return void n(g)}g(e)}}})}function e(g){var n=N[g];if(!n)return Q;var I=function(I){return n.hot.active?(N[I]?N[I].parents.indexOf(g)<0&&N[I].parents.push(g):Z=[g],n.children.indexOf(I)<0&&n.children.push(I)):(console.warn("[HMR] unexpected require("+I+") from disposed module "+g),Z=[]),s=!1,Q(I)};for(var t in Q)Object.prototype.hasOwnProperty.call(Q,t)&&Object.defineProperty(I,t,function(g){return{configurable:!0,enumerable:!0,get:function(){return Q[g]},set:function(n){Q[g]=n}}}(t));return Object.defineProperty(I,"e",{enumerable:!0,value:function(g){function n(){x--,"prepare"===h&&(U[g]||i(g),0===x&&0===y&&b())}return"ready"===h&&c("prepare"),x++,Q.e(g).then(n,function(g){throw n(),g})}}),I}function C(g){var n={_acceptedDependencies:{},_declinedDependencies:{},_selfAccepted:!1,_selfDeclined:!1,_disposeHandlers:[],_main:s,active:!0,accept:function(g,I){if(void 0===g)n._selfAccepted=!0;else if("function"==typeof g)n._selfAccepted=g;else if("object"==typeof g)for(var t=0;t<g.length;t++)n._acceptedDependencies[g[t]]=I||function(){};else n._acceptedDependencies[g]=I||function(){}},decline:function(g){if(void 0===g)n._selfDeclined=!0;else if("object"==typeof g)for(var I=0;I<g.length;I++)n._declinedDependencies[g[I]]=!0;else n._declinedDependencies[g]=!0},dispose:function(g){n._disposeHandlers.push(g)},addDisposeHandler:function(g){n._disposeHandlers.push(g)},removeDisposeHandler:function(g){var I=n._disposeHandlers.indexOf(g);I>=0&&n._disposeHandlers.splice(I,1)},check:B,apply:a,status:function(g){if(!g)return h;p.push(g)},addStatusHandler:function(g){p.push(g)},removeStatusHandler:function(g){var n=p.indexOf(g);n>=0&&p.splice(n,1)},data:F[g]};return s=!0,n}function c(g){h=g;for(var n=0;n<p.length;n++)p[n].call(null,g)}function A(g){return+g+""===g?+g:g}function B(g){if("idle"!==h)throw new Error("check() is only allowed in idle status");return o=g,c("check"),t().then(function(g){if(!g)return c("idle"),null;W={},U={},V=g.c,G=g.h,c("prepare");var n=new Promise(function(g,n){r={resolve:g,reject:n}});d={};return i(0),"prepare"===h&&0===x&&0===y&&b(),n})}function l(g,n){if(V[g]&&W[g]){W[g]=!1;for(var I in n)Object.prototype.hasOwnProperty.call(n,I)&&(d[I]=n[I]);0==--y&&0===x&&b()}}function i(g){V[g]?(W[g]=!0,y++,I(g)):U[g]=!0}function b(){c("ready");var g=r;if(r=null,g)if(o)a(o).then(function(n){g.resolve(n)},function(n){g.reject(n)});else{var n=[];for(var I in d)Object.prototype.hasOwnProperty.call(d,I)&&n.push(A(I));g.resolve(n)}}function a(I){function t(g,n){for(var I=0;I<n.length;I++){var t=n[I];g.indexOf(t)<0&&g.push(t)}}if("ready"!==h)throw new Error("apply() is only allowed in ready status");I=I||{};var e,C,B,l,i,b={},a=[],u={},r=function(){console.warn("[HMR] unexpected require("+s.moduleId+") to disposed module")};for(var o in d)if(Object.prototype.hasOwnProperty.call(d,o)){i=A(o);var s;s=d[o]?function(g){for(var n=[g],I={},e=n.slice().map(function(g){return{chain:[g],id:g}});e.length>0;){var C=e.pop(),c=C.id,A=C.chain;if((l=N[c])&&!l.hot._selfAccepted){if(l.hot._selfDeclined)return{type:"self-declined",chain:A,moduleId:c};if(l.hot._main)return{type:"unaccepted",chain:A,moduleId:c};for(var B=0;B<l.parents.length;B++){var i=l.parents[B],b=N[i];if(b){if(b.hot._declinedDependencies[c])return{type:"declined",chain:A.concat([i]),moduleId:c,parentId:i};n.indexOf(i)>=0||(b.hot._acceptedDependencies[c]?(I[i]||(I[i]=[]),t(I[i],[c])):(delete I[i],n.push(i),e.push({chain:A.concat([i]),id:i})))}}}}return{type:"accepted",moduleId:g,outdatedModules:n,outdatedDependencies:I}}(i):{type:"disposed",moduleId:o};var X=!1,p=!1,y=!1,x="";switch(s.chain&&(x="\nUpdate propagation: "+s.chain.join(" -> ")),s.type){case"self-declined":I.onDeclined&&I.onDeclined(s),I.ignoreDeclined||(X=new Error("Aborted because of self decline: "+s.moduleId+x));break;case"declined":I.onDeclined&&I.onDeclined(s),I.ignoreDeclined||(X=new Error("Aborted because of declined dependency: "+s.moduleId+" in "+s.parentId+x));break;case"unaccepted":I.onUnaccepted&&I.onUnaccepted(s),I.ignoreUnaccepted||(X=new Error("Aborted because "+i+" is not accepted"+x));break;case"accepted":I.onAccepted&&I.onAccepted(s),p=!0;break;case"disposed":I.onDisposed&&I.onDisposed(s),y=!0;break;default:throw new Error("Unexception type "+s.type)}if(X)return c("abort"),Promise.reject(X);if(p){u[i]=d[i],t(a,s.outdatedModules);for(i in s.outdatedDependencies)Object.prototype.hasOwnProperty.call(s.outdatedDependencies,i)&&(b[i]||(b[i]=[]),t(b[i],s.outdatedDependencies[i]))}y&&(t(a,[s.moduleId]),u[i]=r)}var U=[];for(C=0;C<a.length;C++)i=a[C],N[i]&&N[i].hot._selfAccepted&&U.push({module:i,errorHandler:N[i].hot._selfAccepted});c("dispose"),Object.keys(V).forEach(function(g){!1===V[g]&&n(g)});for(var W,Y=a.slice();Y.length>0;)if(i=Y.pop(),l=N[i]){var H={},O=l.hot._disposeHandlers;for(B=0;B<O.length;B++)(e=O[B])(H);for(F[i]=H,l.hot.active=!1,delete N[i],B=0;B<l.children.length;B++){var D=N[l.children[B]];D&&((W=D.parents.indexOf(i))>=0&&D.parents.splice(W,1))}}var T,R;for(i in b)if(Object.prototype.hasOwnProperty.call(b,i)&&(l=N[i]))for(R=b[i],B=0;B<R.length;B++)T=R[B],(W=l.children.indexOf(T))>=0&&l.children.splice(W,1);c("apply"),m=G;for(i in u)Object.prototype.hasOwnProperty.call(u,i)&&(g[i]=u[i]);var v=null;for(i in b)if(Object.prototype.hasOwnProperty.call(b,i)){l=N[i],R=b[i];var f=[];for(C=0;C<R.length;C++)T=R[C],e=l.hot._acceptedDependencies[T],f.indexOf(e)>=0||f.push(e);for(C=0;C<f.length;C++){e=f[C];try{e(R)}catch(g){I.onErrored&&I.onErrored({type:"accept-errored",moduleId:i,dependencyId:R[C],error:g}),I.ignoreErrored||v||(v=g)}}}for(C=0;C<U.length;C++){var J=U[C];i=J.module,Z=[i];try{Q(i)}catch(g){if("function"==typeof J.errorHandler)try{J.errorHandler(g)}catch(n){I.onErrored&&I.onErrored({type:"self-accept-error-handler-errored",moduleId:i,error:n,orginalError:g}),I.ignoreErrored||v||(v=n),v||(v=g)}else I.onErrored&&I.onErrored({type:"self-accept-errored",moduleId:i,error:g}),I.ignoreErrored||v||(v=g)}}return v?(c("fail"),Promise.reject(v)):(c("idle"),Promise.resolve(a))}function Q(n){if(N[n])return N[n].exports;var I=N[n]={i:n,l:!1,exports:{},hot:C(n),parents:(X=Z,Z=[],X),children:[]};return g[n].call(I.exports,I,I.exports,e(n)),I.l=!0,I.exports}var u=this.webpackHotUpdate;this.webpackHotUpdate=function(g,n){l(g,n),u&&u(g,n)};var r,d,G,o=!0,m="1ac3a6a904a5673c28ac",F={},s=!0,Z=[],X=[],p=[],h="idle",y=0,x=0,U={},W={},V={},N={};return Q.m=g,Q.c=N,Q.i=function(g){return g},Q.d=function(g,n,I){Q.o(g,n)||Object.defineProperty(g,n,{configurable:!1,enumerable:!0,get:I})},Q.n=function(g){var n=g&&g.__esModule?function(){return g.default}:function(){return g};return Q.d(n,"a",n),n},Q.o=function(g,n){return Object.prototype.hasOwnProperty.call(g,n)},Q.p="",Q.h=function(){return m},e(11)(Q.s=11)}([function(module,exports,__webpack_require__){eval("/*\n    selection range API\n*/\n\nvar UA = __webpack_require__(/*! ./dop.util */ 1).UA;\n\n// 构造函数\nfunction Selection(inputArea) {\n    this.inputArea = inputArea;\n    this.currentRange = null;\n    this.collapsedRange = null;\n}\n\n// 获取 range 对象\nSelection.prototype.getRange = function () {\n    if (!this.currentRange) {\n        this.saveRange();\n    }\n    return this.currentRange;\n};\n\n// 保存选区\nSelection.prototype.saveRange = function (range) {\n    if (range) {\n        // 保存已有选区\n        this.currentRange = range;\n        return\n    }\n    // 获取当前的选区\n    const selection = window.getSelection();\n    if (selection.rangeCount === 0) {\n        return;\n    }\n    range = selection.getRangeAt(0);\n    // 判断选区内容是否在编辑内容之内\n    const container = this.getSelectionContainer(range)\n    if (!container) {\n        return;\n    }\n    if (this.inputArea.contains(container)) {\n        // 是编辑内容之内的\n        this.currentRange = range;\n    }\n};\n\n// 设置选区到document\nSelection.prototype.restoreSelection = function () {\n    if (!this.currentRange) {\n        return;\n    }\n    const range = this.currentRange.cloneRange();\n    const selection = window.getSelection();\n    selection.removeAllRanges();\n    selection.addRange(range);\n};\n\n// 折叠选区\nSelection.prototype.collapseRange = function (toStart) {\n    if (toStart == null) {\n        // 默认为 false\n        toStart = false;\n    }\n    const range = this.currentRange;\n    if (range) {\n        this.collapsedRange = range.cloneRange();\n        range.collapse(toStart);\n    }\n};\n\n// 恢复上次的选区折叠\nSelection.prototype.recollapse = function () {\n    const collapsed = this.collapsedRange;\n    if (!collapsed) {\n        return;\n    }\n    const range = this.currentRange;\n    if (!collapsed) {\n        return;\n    }\n    range.setStart(collapsed.startContainer, collapsed.startOffset);\n    range.setEnd(collapsed.endContainer, collapsed.endOffset);\n};\n\n// 选中区域的文字\nSelection.prototype.getSelectionText = function () {\n    const range = this.currentRange;\n    if (range) {\n        return range.toString();\n    } else {\n        return '';\n    }\n};\n\n// 包含全部选区的container\nSelection.prototype.getSelectionContainer = function (range) {\n    range = range || this.currentRange;\n    let elem;\n    if (range) {\n        elem = range.commonAncestorContainer;\n        if (elem.nodeType == 1) {\n            return elem;\n        } else {\n            return elem.parentNode;\n        }\n    }\n};\n\nSelection.prototype.getStartElement = function (range) {\n    range = range || this.currentRange;\n    let elem;\n    if (range) {\n        elem = range.startContainer;\n        return elem.nodeType === 1 ? elem : elem.parentNode;\n    }\n};\n\nSelection.prototype.getEndElement = function (range) {\n    range = range || this.currentRange;\n    let elem;\n    if (range) {\n        elem = range.endContainer;\n        return elem.nodeType === 1 ? elem : elem.parentNode;\n    }\n};\n\n// 选区是否为空\nSelection.prototype.isSelectionEmpty = function () {\n    if (range && range.startContainer) {\n        if (range.startContainer === range.endContainer) {\n            if (range.startOffset === range.endOffset) {\n                return true;\n            }\n        }\n    }\n    return false;\n};\n\nSelection.prototype.offset = function(offset) {\n    this.offsetStart(offset);\n    this.offsetEnd(offset);\n}\n\nSelection.prototype.offsetStart = function(offset) {\n    let range = this.currentRange;\n    if (!range) {\n        return;\n    }\n    let startContainer = range.startContainer;\n    let remain = range.startContainer.length - range.startOffset;\n    if (offset < remain) {\n        remain = offset;\n    }\n    range.setStart(startContainer, range.startOffset + remain);\n}\n\nSelection.prototype.offsetEnd = function(offset) {\n    let range = this.currentRange;\n    if (!range) {\n        return;\n    }\n    let endContainer = range.endContainer;\n    let remain = range.endContainer.length - range.endOffset;\n    if (offset < remain) {\n        remain = offset;\n    }\n    range.setEnd(endContainer, range.endOffset + remain);\n}\n\n// 创建一个空白（即 &#8203 字符）选区\nSelection.prototype.createEmptyRange = function () {\n    const range = this.getRange();\n    let elem;\n\n    if (!range) {\n        // 当前无 range\n        return\n    }\n    if (!this.isSelectionEmpty()) {\n        // 当前选区必须没有内容才可以\n        return\n    }\n\n    try {\n        // 目前只支持 webkit 内核\n        if (UA.isWebkit()) {\n            // 插入 &#8203\n            document.execCommand('insertHTML', false, '&#8203;');\n            // 修改 offset 位置\n            range.setEnd(range.endContainer, range.endOffset + 1)\n            // 存储\n            this.saveRange(range)\n        } else {\n            elem = document.createElement('div');\n            elem.innerHTML = '<strong>&#8203;</strong>';\n            elem = elem.children[0];\n            const range = this.getRange()\n            if (range.insertNode) {\n                range.deleteContents()\n                range.insertNode(elem);\n            }\n            this.createRangeByElement(elem, true)\n        }\n    } catch (ex) {\n        // 部分情况下会报错，兼容一下\n    }\n};\n\n// 根据 Elem 设置选区\nSelection.prototype.createRangeByElement = function (elem, toStart, isContent) {\n    // toStart - true 开始位置，false 结束位置\n    // isContent - 是否选中Elem的内容\n    if (!elem) {\n        return\n    }\n\n    const range = document.createRange();\n\n    if (isContent) {\n        range.selectNodeContents(elem);\n    } else {\n        range.selectNode(elem);\n    }\n\n    if (typeof toStart === 'boolean') {\n        range.collapse(toStart);\n    }\n\n    // 存储 range\n    this.saveRange(range);\n    this.restoreSelection();\n}\n\nSelection.prototype.getRangeHTML = function() {\n    let range = this.getRange();\n    if (!range) {\n        return null;\n    }\n    var doc = range.extractContents();\n    var html = new XMLSerializer().serializeToString(doc);\n    return html;\n}\n\nmodule.exports = Selection;\n//export default Selection;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9kb3Auc2VsZWN0aW9uLmpzPzQ4ZmIiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBzZWxlY3Rpb24gcmFuZ2UgQVBJXG4qL1xuXG52YXIgVUEgPSByZXF1aXJlKCcuL2RvcC51dGlsJykuVUE7XG5cbi8vIOaehOmAoOWHveaVsFxuZnVuY3Rpb24gU2VsZWN0aW9uKGlucHV0QXJlYSkge1xuICAgIHRoaXMuaW5wdXRBcmVhID0gaW5wdXRBcmVhO1xuICAgIHRoaXMuY3VycmVudFJhbmdlID0gbnVsbDtcbiAgICB0aGlzLmNvbGxhcHNlZFJhbmdlID0gbnVsbDtcbn1cblxuLy8g6I635Y+WIHJhbmdlIOWvueixoVxuU2VsZWN0aW9uLnByb3RvdHlwZS5nZXRSYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuY3VycmVudFJhbmdlKSB7XG4gICAgICAgIHRoaXMuc2F2ZVJhbmdlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmN1cnJlbnRSYW5nZTtcbn07XG5cbi8vIOS/neWtmOmAieWMulxuU2VsZWN0aW9uLnByb3RvdHlwZS5zYXZlUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgLy8g5L+d5a2Y5bey5pyJ6YCJ5Yy6XG4gICAgICAgIHRoaXMuY3VycmVudFJhbmdlID0gcmFuZ2U7XG4gICAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyDojrflj5blvZPliY3nmoTpgInljLpcbiAgICBjb25zdCBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcbiAgICAvLyDliKTmlq3pgInljLrlhoXlrrnmmK/lkKblnKjnvJbovpHlhoXlrrnkuYvlhoVcbiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmdldFNlbGVjdGlvbkNvbnRhaW5lcihyYW5nZSlcbiAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmlucHV0QXJlYS5jb250YWlucyhjb250YWluZXIpKSB7XG4gICAgICAgIC8vIOaYr+e8lui+keWGheWuueS5i+WGheeahFxuICAgICAgICB0aGlzLmN1cnJlbnRSYW5nZSA9IHJhbmdlO1xuICAgIH1cbn07XG5cbi8vIOiuvue9rumAieWMuuWIsGRvY3VtZW50XG5TZWxlY3Rpb24ucHJvdG90eXBlLnJlc3RvcmVTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnRSYW5nZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJhbmdlID0gdGhpcy5jdXJyZW50UmFuZ2UuY2xvbmVSYW5nZSgpO1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbn07XG5cbi8vIOaKmOWPoOmAieWMulxuU2VsZWN0aW9uLnByb3RvdHlwZS5jb2xsYXBzZVJhbmdlID0gZnVuY3Rpb24gKHRvU3RhcnQpIHtcbiAgICBpZiAodG9TdGFydCA9PSBudWxsKSB7XG4gICAgICAgIC8vIOm7mOiupOS4uiBmYWxzZVxuICAgICAgICB0b1N0YXJ0ID0gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHJhbmdlID0gdGhpcy5jdXJyZW50UmFuZ2U7XG4gICAgaWYgKHJhbmdlKSB7XG4gICAgICAgIHRoaXMuY29sbGFwc2VkUmFuZ2UgPSByYW5nZS5jbG9uZVJhbmdlKCk7XG4gICAgICAgIHJhbmdlLmNvbGxhcHNlKHRvU3RhcnQpO1xuICAgIH1cbn07XG5cbi8vIOaBouWkjeS4iuasoeeahOmAieWMuuaKmOWPoFxuU2VsZWN0aW9uLnByb3RvdHlwZS5yZWNvbGxhcHNlID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGNvbGxhcHNlZCA9IHRoaXMuY29sbGFwc2VkUmFuZ2U7XG4gICAgaWYgKCFjb2xsYXBzZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByYW5nZSA9IHRoaXMuY3VycmVudFJhbmdlO1xuICAgIGlmICghY29sbGFwc2VkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmFuZ2Uuc2V0U3RhcnQoY29sbGFwc2VkLnN0YXJ0Q29udGFpbmVyLCBjb2xsYXBzZWQuc3RhcnRPZmZzZXQpO1xuICAgIHJhbmdlLnNldEVuZChjb2xsYXBzZWQuZW5kQ29udGFpbmVyLCBjb2xsYXBzZWQuZW5kT2Zmc2V0KTtcbn07XG5cbi8vIOmAieS4reWMuuWfn+eahOaWh+Wtl1xuU2VsZWN0aW9uLnByb3RvdHlwZS5nZXRTZWxlY3Rpb25UZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHJhbmdlID0gdGhpcy5jdXJyZW50UmFuZ2U7XG4gICAgaWYgKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiByYW5nZS50b1N0cmluZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59O1xuXG4vLyDljIXlkKvlhajpg6jpgInljLrnmoRjb250YWluZXJcblNlbGVjdGlvbi5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uQ29udGFpbmVyID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgcmFuZ2UgPSByYW5nZSB8fCB0aGlzLmN1cnJlbnRSYW5nZTtcbiAgICBsZXQgZWxlbTtcbiAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgZWxlbSA9IHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5TZWxlY3Rpb24ucHJvdG90eXBlLmdldFN0YXJ0RWxlbWVudCA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgIHJhbmdlID0gcmFuZ2UgfHwgdGhpcy5jdXJyZW50UmFuZ2U7XG4gICAgbGV0IGVsZW07XG4gICAgaWYgKHJhbmdlKSB7XG4gICAgICAgIGVsZW0gPSByYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICAgICAgcmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDEgPyBlbGVtIDogZWxlbS5wYXJlbnROb2RlO1xuICAgIH1cbn07XG5cblNlbGVjdGlvbi5wcm90b3R5cGUuZ2V0RW5kRWxlbWVudCA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgIHJhbmdlID0gcmFuZ2UgfHwgdGhpcy5jdXJyZW50UmFuZ2U7XG4gICAgbGV0IGVsZW07XG4gICAgaWYgKHJhbmdlKSB7XG4gICAgICAgIGVsZW0gPSByYW5nZS5lbmRDb250YWluZXI7XG4gICAgICAgIHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxID8gZWxlbSA6IGVsZW0ucGFyZW50Tm9kZTtcbiAgICB9XG59O1xuXG4vLyDpgInljLrmmK/lkKbkuLrnqbpcblNlbGVjdGlvbi5wcm90b3R5cGUuaXNTZWxlY3Rpb25FbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocmFuZ2UgJiYgcmFuZ2Uuc3RhcnRDb250YWluZXIpIHtcbiAgICAgICAgaWYgKHJhbmdlLnN0YXJ0Q29udGFpbmVyID09PSByYW5nZS5lbmRDb250YWluZXIpIHtcbiAgICAgICAgICAgIGlmIChyYW5nZS5zdGFydE9mZnNldCA9PT0gcmFuZ2UuZW5kT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuU2VsZWN0aW9uLnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICB0aGlzLm9mZnNldFN0YXJ0KG9mZnNldCk7XG4gICAgdGhpcy5vZmZzZXRFbmQob2Zmc2V0KTtcbn1cblxuU2VsZWN0aW9uLnByb3RvdHlwZS5vZmZzZXRTdGFydCA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgIGxldCByYW5nZSA9IHRoaXMuY3VycmVudFJhbmdlO1xuICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgc3RhcnRDb250YWluZXIgPSByYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICBsZXQgcmVtYWluID0gcmFuZ2Uuc3RhcnRDb250YWluZXIubGVuZ3RoIC0gcmFuZ2Uuc3RhcnRPZmZzZXQ7XG4gICAgaWYgKG9mZnNldCA8IHJlbWFpbikge1xuICAgICAgICByZW1haW4gPSBvZmZzZXQ7XG4gICAgfVxuICAgIHJhbmdlLnNldFN0YXJ0KHN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCArIHJlbWFpbik7XG59XG5cblNlbGVjdGlvbi5wcm90b3R5cGUub2Zmc2V0RW5kID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgbGV0IHJhbmdlID0gdGhpcy5jdXJyZW50UmFuZ2U7XG4gICAgaWYgKCFyYW5nZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBlbmRDb250YWluZXIgPSByYW5nZS5lbmRDb250YWluZXI7XG4gICAgbGV0IHJlbWFpbiA9IHJhbmdlLmVuZENvbnRhaW5lci5sZW5ndGggLSByYW5nZS5lbmRPZmZzZXQ7XG4gICAgaWYgKG9mZnNldCA8IHJlbWFpbikge1xuICAgICAgICByZW1haW4gPSBvZmZzZXQ7XG4gICAgfVxuICAgIHJhbmdlLnNldEVuZChlbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCArIHJlbWFpbik7XG59XG5cbi8vIOWIm+W7uuS4gOS4quepuueZve+8iOWNsyAmIzgyMDMg5a2X56ym77yJ6YCJ5Yy6XG5TZWxlY3Rpb24ucHJvdG90eXBlLmNyZWF0ZUVtcHR5UmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgcmFuZ2UgPSB0aGlzLmdldFJhbmdlKCk7XG4gICAgbGV0IGVsZW07XG5cbiAgICBpZiAoIXJhbmdlKSB7XG4gICAgICAgIC8vIOW9k+WJjeaXoCByYW5nZVxuICAgICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzU2VsZWN0aW9uRW1wdHkoKSkge1xuICAgICAgICAvLyDlvZPliY3pgInljLrlv4XpobvmsqHmnInlhoXlrrnmiY3lj6/ku6VcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgLy8g55uu5YmN5Y+q5pSv5oyBIHdlYmtpdCDlhoXmoLhcbiAgICAgICAgaWYgKFVBLmlzV2Via2l0KCkpIHtcbiAgICAgICAgICAgIC8vIOaPkuWFpSAmIzgyMDNcbiAgICAgICAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKCdpbnNlcnRIVE1MJywgZmFsc2UsICcmIzgyMDM7Jyk7XG4gICAgICAgICAgICAvLyDkv67mlLkgb2Zmc2V0IOS9jee9rlxuICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0ICsgMSlcbiAgICAgICAgICAgIC8vIOWtmOWCqFxuICAgICAgICAgICAgdGhpcy5zYXZlUmFuZ2UocmFuZ2UpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBlbGVtLmlubmVySFRNTCA9ICc8c3Ryb25nPiYjODIwMzs8L3N0cm9uZz4nO1xuICAgICAgICAgICAgZWxlbSA9IGVsZW0uY2hpbGRyZW5bMF07XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IHRoaXMuZ2V0UmFuZ2UoKVxuICAgICAgICAgICAgaWYgKHJhbmdlLmluc2VydE5vZGUpIHtcbiAgICAgICAgICAgICAgICByYW5nZS5kZWxldGVDb250ZW50cygpXG4gICAgICAgICAgICAgICAgcmFuZ2UuaW5zZXJ0Tm9kZShlbGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY3JlYXRlUmFuZ2VCeUVsZW1lbnQoZWxlbSwgdHJ1ZSlcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIC8vIOmDqOWIhuaDheWGteS4i+S8muaKpemUme+8jOWFvOWuueS4gOS4i1xuICAgIH1cbn07XG5cbi8vIOagueaNriBFbGVtIOiuvue9rumAieWMulxuU2VsZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVSYW5nZUJ5RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtLCB0b1N0YXJ0LCBpc0NvbnRlbnQpIHtcbiAgICAvLyB0b1N0YXJ0IC0gdHJ1ZSDlvIDlp4vkvY3nva7vvIxmYWxzZSDnu5PmnZ/kvY3nva5cbiAgICAvLyBpc0NvbnRlbnQgLSDmmK/lkKbpgInkuK1FbGVt55qE5YaF5a65XG4gICAgaWYgKCFlbGVtKSB7XG4gICAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcblxuICAgIGlmIChpc0NvbnRlbnQpIHtcbiAgICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKGVsZW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlLnNlbGVjdE5vZGUoZWxlbSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0b1N0YXJ0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmFuZ2UuY29sbGFwc2UodG9TdGFydCk7XG4gICAgfVxuXG4gICAgLy8g5a2Y5YKoIHJhbmdlXG4gICAgdGhpcy5zYXZlUmFuZ2UocmFuZ2UpO1xuICAgIHRoaXMucmVzdG9yZVNlbGVjdGlvbigpO1xufVxuXG5TZWxlY3Rpb24ucHJvdG90eXBlLmdldFJhbmdlSFRNTCA9IGZ1bmN0aW9uKCkge1xuICAgIGxldCByYW5nZSA9IHRoaXMuZ2V0UmFuZ2UoKTtcbiAgICBpZiAoIXJhbmdlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgZG9jID0gcmFuZ2UuZXh0cmFjdENvbnRlbnRzKCk7XG4gICAgdmFyIGh0bWwgPSBuZXcgWE1MU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKGRvYyk7XG4gICAgcmV0dXJuIGh0bWw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VsZWN0aW9uO1xuLy9leHBvcnQgZGVmYXVsdCBTZWxlY3Rpb247XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZG9wLnNlbGVjdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9")},function(module,exports){eval("const UA = {\n    _ua: navigator.userAgent,\n\n    // 是否 webkit\n    isWebkit: function () {\n        const reg = /webkit/i\n        return reg.test(this._ua)\n    },\n\n    // 是否 IE\n    isIE: function () {\n        return 'ActiveXObject' in window\n    }\n}\n\nfunction dop(html) {\n    var container = document.createElement('div');\n    container.innerHTML = html;\n    return container.children;\n}\n\nmodule.exports = {\n    'UA': UA, \n    'dop': dop\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9kb3AudXRpbC5qcz9jMDljIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFVBID0ge1xuICAgIF91YTogbmF2aWdhdG9yLnVzZXJBZ2VudCxcblxuICAgIC8vIOaYr+WQpiB3ZWJraXRcbiAgICBpc1dlYmtpdDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCByZWcgPSAvd2Via2l0L2lcbiAgICAgICAgcmV0dXJuIHJlZy50ZXN0KHRoaXMuX3VhKVxuICAgIH0sXG5cbiAgICAvLyDmmK/lkKYgSUVcbiAgICBpc0lFOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQWN0aXZlWE9iamVjdCcgaW4gd2luZG93XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkb3AoaHRtbCkge1xuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgICByZXR1cm4gY29udGFpbmVyLmNoaWxkcmVuO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAnVUEnOiBVQSwgXG4gICAgJ2RvcCc6IGRvcFxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2RvcC51dGlsLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports){eval('var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function("return this")() || (1,eval)("this");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === "object")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it\'s\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/MzY5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){eval("/*var parse = require('./src/flowchart.parse');\nrequire('./src/jquery-plugin');\n\nvar FlowChart = {\n\tparse: parse\n};\n\nif (typeof window !== 'undefined') {\n\twindow.flowchart = FlowChart;\n}*/\n\n__webpack_require__(/*! ./src/entry */ 9);\n// module.exports = FlowChart;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2luZGV4LmpzPzI2NDUiXSwic291cmNlc0NvbnRlbnQiOlsiLyp2YXIgcGFyc2UgPSByZXF1aXJlKCcuL3NyYy9mbG93Y2hhcnQucGFyc2UnKTtcbnJlcXVpcmUoJy4vc3JjL2pxdWVyeS1wbHVnaW4nKTtcblxudmFyIEZsb3dDaGFydCA9IHtcblx0cGFyc2U6IHBhcnNlXG59O1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0d2luZG93LmZsb3djaGFydCA9IEZsb3dDaGFydDtcbn0qL1xuXG5yZXF1aXJlKCcuL3NyYy9lbnRyeScpO1xuLy8gbW9kdWxlLmV4cG9ydHMgPSBGbG93Q2hhcnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9")},function(module,exports){eval("// defaults\nmodule.exports = {\n    'contentName': 'forkmde-content', \n    'contentId': 'forkmde-content'\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9jb21tb24uZGVmYXVsdHMuanM/NDQyMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBkZWZhdWx0c1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgJ2NvbnRlbnROYW1lJzogJ2ZvcmttZGUtY29udGVudCcsIFxuICAgICdjb250ZW50SWQnOiAnZm9ya21kZS1jb250ZW50J1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2NvbW1vbi5kZWZhdWx0cy5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9")},function(module,exports){eval("/**\n * similar with underscore\n */\nfunction inherits(ctor, superCtor) {\n    if (typeof(Object.create) === 'function') {\n        // implementation from standard node.js 'util' module\n        ctor.super_ = superCtor;\n        ctor.prototype = Object.create(superCtor.prototype, {\n            constructor: {\n                value: ctor,\n                enumerable: false,\n                writable: true,\n                configurable: true\n            }\n        });\n    } else {\n        // old school shim for old browsers\n        ctor.super_ = superCtor;\n        var TempCtor = function () {};\n        TempCtor.prototype = superCtor.prototype;\n        ctor.prototype = new TempCtor();\n        ctor.prototype.constructor = ctor;\n    }\n}\n\nfunction insertText(text) {\n    var sel, range, html;\n    if (window.getSelection) {\n        sel = window.getSelection();\n        if (sel.getRangeAt && sel.rangeCount) {\n            range = sel.getRangeAt(0);\n            //range.deleteContents();\n            range.insertNode( document.createTextNode(text) );\n        }\n    } else if (document.selection && document.selection.createRange) {\n        document.selection.createRange().text = text;\n    }\n}\n\nfunction each(arr, callback) {\n    for (var i = 0 ; i < arr.length ; i++) {\n        callback(arr[i]);\n    }\n}\nfunction replace(regex, opt) {\n    regex = regex.source;\n    opt = opt || '';\n    return function self(name, val) {\n        if (!name) return new RegExp(regex, opt);\n        val = val.source || val;\n        val = val.replace(/(^|[^\\[])\\^/g, '$1');\n        regex = regex.replace(name, val);\n        return self;\n    };\n}\n\n/* ==========这都是网上找的，存在这儿作为参考，本项目只需要一个弱化版本==============\n\nfunction pasteHtmlAtCaret(html, selectPastedContent, iframe) {\n    var sel, range;\n    var win = iframe ? iframe.contentWindow : window;\n    var doc = win.document;\n    if (win.getSelection) {\n        // IE9 and non-IE\n        sel = win.getSelection();\n        if (sel.getRangeAt && sel.rangeCount) {\n            range = sel.getRangeAt(0);\n            range.deleteContents();\n\n            // Range.createContextualFragment() would be useful here but is\n            // only relatively recently standardized and is not supported in\n            // some browsers (IE9, for one)\n            var el = doc.createElement(\"div\");\n            el.innerHTML = html;\n            var frag = doc.createDocumentFragment(), node, lastNode;\n            while ( (node = el.firstChild) ) {\n                lastNode = frag.appendChild(node);\n            }\n            var firstNode = frag.firstChild;\n            range.insertNode(frag);\n\n            // Preserve the selection\n            if (lastNode) {\n                range = range.cloneRange();\n                range.setStartAfter(lastNode);\n                if (selectPastedContent) {\n                    range.setStartBefore(firstNode);\n                } else {\n                    range.collapse(true);\n                }\n                sel.removeAllRanges();\n                sel.addRange(range);\n            }\n        }\n    } else if ( (sel = doc.selection) && sel.type != \"Control\") {\n        // IE < 9\n        var originalRange = sel.createRange();\n        originalRange.collapse(true);\n        sel.createRange().pasteHTML(html);\n        if (selectPastedContent) {\n            range = sel.createRange();\n            range.setEndPoint(\"StartToStart\", originalRange);\n            range.select();\n        }\n    }\n}\n\nfunction saveSelection() {\n    if (window.getSelection) {\n        sel = window.getSelection();\n        if (sel.getRangeAt && sel.rangeCount) {\n            return sel.getRangeAt(0);\n        }\n    } else if (document.selection && document.selection.createRange) {\n        return document.selection.createRange();\n    }\n    return null;\n}\n\nfunction restoreSelection(range) {\n    if (range) {\n        if (window.getSelection) {\n            sel = window.getSelection();\n            sel.removeAllRanges();\n            sel.addRange(range);\n        } else if (document.selection && range.select) {\n            range.select();\n        }\n    }\n}\n\n*/\n\nfunction isRangeIn(range, container) {\n    var node = range.startContainer;\n    while (node) {\n        if (node == container) {\n            return true;\n        }\n        node = node.parentNode;\n    }\n    return false;\n}\n// ref: http://kjah.iteye.com/blog/420624\nfunction roundText(prefix, suffix, container) {\n    var selection, range;\n    if (window.getSelection) {\n        // IE9 and non-IE\n        selection = window.getSelection();\n        if (selection.getRangeAt && selection.rangeCount) {\n            range = selection.getRangeAt(0);\n            console.dir(selection);\n\n            if (!isRangeIn(range, container) || !isRangeIn(range, container)) return;\n            // range.deleteContents();\n            // console.log(range.startContainer);\n\n            var preTextNode = document.createTextNode(prefix);\n            var sufTextNode = document.createTextNode(suffix);\n            range.insertNode(preTextNode);\n            range.collapse(false);\n            range.insertNode(sufTextNode);\n\n            range.setStartAfter(preTextNode);\n            range.setEndBefore(sufTextNode);\n\n            range = range.cloneRange();\n            selection.removeAllRanges();\n            selection.addRange(range);\n        }\n    } else if ( (selection = document.selection) && selection.type != \"Control\") {\n        // IE < 9\n        throw \"ForkMark is not supported in current browser, please contact zhfchdev@gmail.com\";\n    }\n}\n\nString.prototype.trim = function() {\n    return this.replace(/^\\s+|\\s+$/gm,'');\n}\n\nArray.prototype.addAll = function(arr) {\n    for (var i = 0 ; i < arr.length ; i++) {\n        this.push(arr[i]);\n    }\n};\n\nfunction TimeoutLock(obj, timeout) {\n    this.obj = obj;\n    this.time = 0;\n    this.timeout = timeout;\n}\nTimeoutLock.prototype.update = function(obj) {\n    this.obj = obj;\n    this.time = (new Date()).getTime();\n}\nTimeoutLock.prototype.check = function(obj) {\n    var time = (new Date()).getTime();\n    return this.obj == obj || time - this.time >= this.timeout;\n}\n\nmodule.exports = {\n    inherits: inherits, \n    roundText: roundText, \n    each: each, \n    replace: replace, \n    TimeoutLock: TimeoutLock\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9jb21tb24udG9vbHMuanM/Zjg0MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHNpbWlsYXIgd2l0aCB1bmRlcnNjb3JlXG4gKi9cbmZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmICh0eXBlb2YoT2JqZWN0LmNyZWF0ZSkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gICAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICAgICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGU7XG4gICAgICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKCk7XG4gICAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvcjtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGluc2VydFRleHQodGV4dCkge1xuICAgIHZhciBzZWwsIHJhbmdlLCBodG1sO1xuICAgIGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG4gICAgICAgIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgaWYgKHNlbC5nZXRSYW5nZUF0ICYmIHNlbC5yYW5nZUNvdW50KSB7XG4gICAgICAgICAgICByYW5nZSA9IHNlbC5nZXRSYW5nZUF0KDApO1xuICAgICAgICAgICAgLy9yYW5nZS5kZWxldGVDb250ZW50cygpO1xuICAgICAgICAgICAgcmFuZ2UuaW5zZXJ0Tm9kZSggZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCkgKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uICYmIGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSkge1xuICAgICAgICBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKS50ZXh0ID0gdGV4dDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGVhY2goYXJyLCBjYWxsYmFjaykge1xuICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IGFyci5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgY2FsbGJhY2soYXJyW2ldKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXBsYWNlKHJlZ2V4LCBvcHQpIHtcbiAgICByZWdleCA9IHJlZ2V4LnNvdXJjZTtcbiAgICBvcHQgPSBvcHQgfHwgJyc7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHNlbGYobmFtZSwgdmFsKSB7XG4gICAgICAgIGlmICghbmFtZSkgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXgsIG9wdCk7XG4gICAgICAgIHZhbCA9IHZhbC5zb3VyY2UgfHwgdmFsO1xuICAgICAgICB2YWwgPSB2YWwucmVwbGFjZSgvKF58W15cXFtdKVxcXi9nLCAnJDEnKTtcbiAgICAgICAgcmVnZXggPSByZWdleC5yZXBsYWNlKG5hbWUsIHZhbCk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG59XG5cbi8qID09PT09PT09PT3ov5npg73mmK/nvZHkuIrmib7nmoTvvIzlrZjlnKjov5nlhL/kvZzkuLrlj4LogIPvvIzmnKzpobnnm67lj6rpnIDopoHkuIDkuKrlvLHljJbniYjmnKw9PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBwYXN0ZUh0bWxBdENhcmV0KGh0bWwsIHNlbGVjdFBhc3RlZENvbnRlbnQsIGlmcmFtZSkge1xuICAgIHZhciBzZWwsIHJhbmdlO1xuICAgIHZhciB3aW4gPSBpZnJhbWUgPyBpZnJhbWUuY29udGVudFdpbmRvdyA6IHdpbmRvdztcbiAgICB2YXIgZG9jID0gd2luLmRvY3VtZW50O1xuICAgIGlmICh3aW4uZ2V0U2VsZWN0aW9uKSB7XG4gICAgICAgIC8vIElFOSBhbmQgbm9uLUlFXG4gICAgICAgIHNlbCA9IHdpbi5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgaWYgKHNlbC5nZXRSYW5nZUF0ICYmIHNlbC5yYW5nZUNvdW50KSB7XG4gICAgICAgICAgICByYW5nZSA9IHNlbC5nZXRSYW5nZUF0KDApO1xuICAgICAgICAgICAgcmFuZ2UuZGVsZXRlQ29udGVudHMoKTtcblxuICAgICAgICAgICAgLy8gUmFuZ2UuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KCkgd291bGQgYmUgdXNlZnVsIGhlcmUgYnV0IGlzXG4gICAgICAgICAgICAvLyBvbmx5IHJlbGF0aXZlbHkgcmVjZW50bHkgc3RhbmRhcmRpemVkIGFuZCBpcyBub3Qgc3VwcG9ydGVkIGluXG4gICAgICAgICAgICAvLyBzb21lIGJyb3dzZXJzIChJRTksIGZvciBvbmUpXG4gICAgICAgICAgICB2YXIgZWwgPSBkb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIGVsLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgICAgICB2YXIgZnJhZyA9IGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIG5vZGUsIGxhc3ROb2RlO1xuICAgICAgICAgICAgd2hpbGUgKCAobm9kZSA9IGVsLmZpcnN0Q2hpbGQpICkge1xuICAgICAgICAgICAgICAgIGxhc3ROb2RlID0gZnJhZy5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmaXJzdE5vZGUgPSBmcmFnLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICByYW5nZS5pbnNlcnROb2RlKGZyYWcpO1xuXG4gICAgICAgICAgICAvLyBQcmVzZXJ2ZSB0aGUgc2VsZWN0aW9uXG4gICAgICAgICAgICBpZiAobGFzdE5vZGUpIHtcbiAgICAgICAgICAgICAgICByYW5nZSA9IHJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydEFmdGVyKGxhc3ROb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0UGFzdGVkQ29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydEJlZm9yZShmaXJzdE5vZGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgc2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIChzZWwgPSBkb2Muc2VsZWN0aW9uKSAmJiBzZWwudHlwZSAhPSBcIkNvbnRyb2xcIikge1xuICAgICAgICAvLyBJRSA8IDlcbiAgICAgICAgdmFyIG9yaWdpbmFsUmFuZ2UgPSBzZWwuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgb3JpZ2luYWxSYW5nZS5jb2xsYXBzZSh0cnVlKTtcbiAgICAgICAgc2VsLmNyZWF0ZVJhbmdlKCkucGFzdGVIVE1MKGh0bWwpO1xuICAgICAgICBpZiAoc2VsZWN0UGFzdGVkQ29udGVudCkge1xuICAgICAgICAgICAgcmFuZ2UgPSBzZWwuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgIHJhbmdlLnNldEVuZFBvaW50KFwiU3RhcnRUb1N0YXJ0XCIsIG9yaWdpbmFsUmFuZ2UpO1xuICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNhdmVTZWxlY3Rpb24oKSB7XG4gICAgaWYgKHdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICAgICAgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICBpZiAoc2VsLmdldFJhbmdlQXQgJiYgc2VsLnJhbmdlQ291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWwuZ2V0UmFuZ2VBdCgwKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uICYmIGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiByZXN0b3JlU2VsZWN0aW9uKHJhbmdlKSB7XG4gICAgaWYgKHJhbmdlKSB7XG4gICAgICAgIGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICBzZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbiAmJiByYW5nZS5zZWxlY3QpIHtcbiAgICAgICAgICAgIHJhbmdlLnNlbGVjdCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4qL1xuXG5mdW5jdGlvbiBpc1JhbmdlSW4ocmFuZ2UsIGNvbnRhaW5lcikge1xuICAgIHZhciBub2RlID0gcmFuZ2Uuc3RhcnRDb250YWluZXI7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gY29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLyByZWY6IGh0dHA6Ly9ramFoLml0ZXllLmNvbS9ibG9nLzQyMDYyNFxuZnVuY3Rpb24gcm91bmRUZXh0KHByZWZpeCwgc3VmZml4LCBjb250YWluZXIpIHtcbiAgICB2YXIgc2VsZWN0aW9uLCByYW5nZTtcbiAgICBpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xuICAgICAgICAvLyBJRTkgYW5kIG5vbi1JRVxuICAgICAgICBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIGlmIChzZWxlY3Rpb24uZ2V0UmFuZ2VBdCAmJiBzZWxlY3Rpb24ucmFuZ2VDb3VudCkge1xuICAgICAgICAgICAgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZGlyKHNlbGVjdGlvbik7XG5cbiAgICAgICAgICAgIGlmICghaXNSYW5nZUluKHJhbmdlLCBjb250YWluZXIpIHx8ICFpc1JhbmdlSW4ocmFuZ2UsIGNvbnRhaW5lcikpIHJldHVybjtcbiAgICAgICAgICAgIC8vIHJhbmdlLmRlbGV0ZUNvbnRlbnRzKCk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhyYW5nZS5zdGFydENvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIHZhciBwcmVUZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHByZWZpeCk7XG4gICAgICAgICAgICB2YXIgc3VmVGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzdWZmaXgpO1xuICAgICAgICAgICAgcmFuZ2UuaW5zZXJ0Tm9kZShwcmVUZXh0Tm9kZSk7XG4gICAgICAgICAgICByYW5nZS5jb2xsYXBzZShmYWxzZSk7XG4gICAgICAgICAgICByYW5nZS5pbnNlcnROb2RlKHN1ZlRleHROb2RlKTtcblxuICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnRBZnRlcihwcmVUZXh0Tm9kZSk7XG4gICAgICAgICAgICByYW5nZS5zZXRFbmRCZWZvcmUoc3VmVGV4dE5vZGUpO1xuXG4gICAgICAgICAgICByYW5nZSA9IHJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCAoc2VsZWN0aW9uID0gZG9jdW1lbnQuc2VsZWN0aW9uKSAmJiBzZWxlY3Rpb24udHlwZSAhPSBcIkNvbnRyb2xcIikge1xuICAgICAgICAvLyBJRSA8IDlcbiAgICAgICAgdGhyb3cgXCJGb3JrTWFyayBpcyBub3Qgc3VwcG9ydGVkIGluIGN1cnJlbnQgYnJvd3NlciwgcGxlYXNlIGNvbnRhY3QgemhmY2hkZXZAZ21haWwuY29tXCI7XG4gICAgfVxufVxuXG5TdHJpbmcucHJvdG90eXBlLnRyaW0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nbSwnJyk7XG59XG5cbkFycmF5LnByb3RvdHlwZS5hZGRBbGwgPSBmdW5jdGlvbihhcnIpIHtcbiAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBhcnIubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgIHRoaXMucHVzaChhcnJbaV0pO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXRMb2NrKG9iaiwgdGltZW91dCkge1xuICAgIHRoaXMub2JqID0gb2JqO1xuICAgIHRoaXMudGltZSA9IDA7XG4gICAgdGhpcy50aW1lb3V0ID0gdGltZW91dDtcbn1cblRpbWVvdXRMb2NrLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICB0aGlzLm9iaiA9IG9iajtcbiAgICB0aGlzLnRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xufVxuVGltZW91dExvY2sucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgIHJldHVybiB0aGlzLm9iaiA9PSBvYmogfHwgdGltZSAtIHRoaXMudGltZSA+PSB0aGlzLnRpbWVvdXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGluaGVyaXRzOiBpbmhlcml0cywgXG4gICAgcm91bmRUZXh0OiByb3VuZFRleHQsIFxuICAgIGVhY2g6IGVhY2gsIFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsIFxuICAgIFRpbWVvdXRMb2NrOiBUaW1lb3V0TG9ja1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2NvbW1vbi50b29scy5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {(function() {\n\nfunction merge(obj) {\n    var i = 1\n        , target\n        , key;\n\n    for (; i < arguments.length; i++) {\n        target = arguments[i];\n        for (key in target) {\n            if (Object.prototype.hasOwnProperty.call(target, key)) {\n                obj[key] = target[key];\n            }\n        }\n    }\n    return obj;\n}\n\nfunction newArray(m, n) {\n    var arr = new Array(m);\n    if (n) {\n        for (var i = 0 ; i < m ; i++) {\n            arr[i] = new Array(n);\n        }\n    }\n    return arr;\n}\n\nfunction getMaxMatch(arr1, arr2) {\n    var m = arr1.length;\n    var n = arr2.length;\n    if (m == 0 && n == 0) {\n        // 无变化\n        return {removed: [], added: []};\n    }\n    if (m == 0) {\n        // 全新增\n        var added = new Array();\n        for (var i = 0 ; i < n ; i++) {\n            added.push({\n                pos: i, \n                to: i, \n                content: arr2[i]\n            });\n        }\n        return {removed: [], added: added};\n    }\n    if (n == 0) {\n        // 全删除\n        var removed = new Array();\n        for (var i = 0 ; i < m ; i++) {\n            removed.push({\n                from: 0, \n                content: arr1[i]\n            });\n        }\n        return {removed: removed, added: []};\n    }\n    var i, j, k;\n\n    var p = newArray(m, n);\n    for (i = 0 ; i < m ; i++) {\n        for (j = 0 ; j < n ; j++) {\n            if (eq(arr1[i], arr2[j])) {\n                p[i][j]=1;\n            } else {\n                p[i][j]=0;\n            }\n        }\n    }\n    var q = newArray(m+1, n+1);\n    for (i = 0 ; i < m + 1 ; i++) {\n        q[i][n] = 0;\n    }\n    for (i = 0 ; i < n + 1 ; i++) {\n        q[m][i] = 0; \n    }\n\n    for (i = m - 1 ; i >= 0 ; i--) {\n        for (j = n - 1 ; j >= 0 ; j--) {\n            var max, maxi, maxj;\n            if (q[i][j+1] >= q[i+1][j]) {\n                max = q[i][j+1];\n            } else {\n                max = q[i+1][j];\n            }\n            if (q[i+1][j+1] + p[i][j] > max) {\n                max = q[i+1][j+1]+1;\n            }\n            q[i][j] = max;\n        }\n    }\n\n    var maxQ = -1;\n    for (i = 0 ; i < m ; i++) {\n        if (p[i][0] == 1 && (maxQ == -1 || q[i][0] > maxQ)) {  \n            maxQ = q[i][0];\n        }\n    }\n    for (i = 0 ; i < n ; i++) {\n        if (p[0][i] == 1 && q[0][i] > maxQ) {  \n             maxQ = q[0][i];\n         }\n    }\n\n    var s = maxQ;\n    var path = new Array();\n    var h = -1;\n\n    for (i = 0 ; i < m ; i++) {\n        for (j = 0 ; j < n ; j++) {\n            if (p[i][j] == 1 && q[i][j] == maxQ) {\n                var x = i;\n                var y = j;\n                path.push(i);\n                path.push(j);\n                s = s - 1;\n                while (s > 0) {\n                    var signal = true; \n                    var u, v, x1, y1;\n                    for (u = x + 1 ; u < m && signal ; u++) {\n                        for ( v = y + 1 ; v < n && signal ; v++) {\n                            if (p[u][v] == 1 && q[u][v] == s) {\n                                path.push(u);\n                                path.push(v);\n                                x1 = u;\n                                y1 = v;\n                                signal=false;\n                            }\n                        }\n                    }\n                    x = x1;\n                    y = y1;\n                    s = s-1;\n                }\n                h = i;\n                break;\n            }\n        }\n        if (h > -1) {\n            break;\n        }\n    }\n\n    var ti = 0, tj = 0;\n    var si, sj, sum = 0;\n\n    var removed = new Array();\n    var added = new Array();\n    var remain = new Array();\n\n    for (k = 0 ; k < path.length ; k = k + 2) {\n        si = path[k];\n        sj = path[k+1];\n        remain.push({\n            from: si, \n            to: sj\n        });\n        \n        for (j = ti ; j < si ; j++) {\n            removed.push({\n                from: j + sum, // 从哪儿删除\n                content: arr1[j]\n            });\n            sum--;\n        }\n        for (j = tj ; j < sj ; j++) {\n            added.push({\n                to: j, // 调整后的位置\n                content: arr2[j]\n            });\n        }\n        ti = si;\n        tj = sj;\n        ti++;\n        tj++;\n    }\n    si = m;\n    sj = n;\n    for (j = ti ; j < si ; j++) {\n        removed.push({\n            from: j + sum, \n            content: arr1[j]\n        });\n        sum--;\n    }\n    for (j = tj ; j < sj ; j++) {\n        added.push({\n            to: j,  // 调整后的位置\n            content: arr2[j]\n        });\n    }\n    return {\n        removed: removed, \n        added: added, \n        remain: remain\n    }\n}\n\n// 去除<span offset=\"xxx\" length=\"xxx\"></span>的影响来比较，这个不同理论上应该放在外层，\n// 但是因为返回的added直接就是string而不是index，放在外层不好处理，待改进！\nfunction eq(html1, html2) {\n    /*var a1 = html1;\n    var a1 = a1.substring(a1.indexOf('>') + 1);\n    var a1 = a1.substring(0, a1.lastIndexOf('<'));\n    var a2 = html2;\n    var a2 = a2.substring(a2.indexOf('>') + 1);\n    var a2 = a2.substring(0, a2.lastIndexOf('<'));\n    return a1 == a2;*/\n    return html1 == html2;\n}\n\nfunction diff(arr1, arr2) {\n    if (!arr1) {\n        arr1 = new Array();\n    }\n    if (!arr2) {\n        arr2 = new Array();\n    }\n    return getMaxMatch(arr1, arr2);\n}\n\nif (true) {\n    module.exports = diff;\n} else if (typeof define === 'function' && define.amd) {\n    define(function() { return diff; });\n} else {\n    this.diff = diff;\n}\n\n}).call(function() {\n  return this || (typeof window !== 'undefined' ? window : global);\n}());\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../../../../../usr/local/lib/~/webpack/buildin/global.js */ 2)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9kaWZmLnRleHQuanM/MDYxMyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKSB7XG5cbmZ1bmN0aW9uIG1lcmdlKG9iaikge1xuICAgIHZhciBpID0gMVxuICAgICAgICAsIHRhcmdldFxuICAgICAgICAsIGtleTtcblxuICAgIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgZm9yIChrZXkgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KSkge1xuICAgICAgICAgICAgICAgIG9ialtrZXldID0gdGFyZ2V0W2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gbmV3QXJyYXkobSwgbikge1xuICAgIHZhciBhcnIgPSBuZXcgQXJyYXkobSk7XG4gICAgaWYgKG4pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgbSA7IGkrKykge1xuICAgICAgICAgICAgYXJyW2ldID0gbmV3IEFycmF5KG4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIGdldE1heE1hdGNoKGFycjEsIGFycjIpIHtcbiAgICB2YXIgbSA9IGFycjEubGVuZ3RoO1xuICAgIHZhciBuID0gYXJyMi5sZW5ndGg7XG4gICAgaWYgKG0gPT0gMCAmJiBuID09IDApIHtcbiAgICAgICAgLy8g5peg5Y+Y5YyWXG4gICAgICAgIHJldHVybiB7cmVtb3ZlZDogW10sIGFkZGVkOiBbXX07XG4gICAgfVxuICAgIGlmIChtID09IDApIHtcbiAgICAgICAgLy8g5YWo5paw5aKeXG4gICAgICAgIHZhciBhZGRlZCA9IG5ldyBBcnJheSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBuIDsgaSsrKSB7XG4gICAgICAgICAgICBhZGRlZC5wdXNoKHtcbiAgICAgICAgICAgICAgICBwb3M6IGksIFxuICAgICAgICAgICAgICAgIHRvOiBpLCBcbiAgICAgICAgICAgICAgICBjb250ZW50OiBhcnIyW2ldXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge3JlbW92ZWQ6IFtdLCBhZGRlZDogYWRkZWR9O1xuICAgIH1cbiAgICBpZiAobiA9PSAwKSB7XG4gICAgICAgIC8vIOWFqOWIoOmZpFxuICAgICAgICB2YXIgcmVtb3ZlZCA9IG5ldyBBcnJheSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBtIDsgaSsrKSB7XG4gICAgICAgICAgICByZW1vdmVkLnB1c2goe1xuICAgICAgICAgICAgICAgIGZyb206IDAsIFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGFycjFbaV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7cmVtb3ZlZDogcmVtb3ZlZCwgYWRkZWQ6IFtdfTtcbiAgICB9XG4gICAgdmFyIGksIGosIGs7XG5cbiAgICB2YXIgcCA9IG5ld0FycmF5KG0sIG4pO1xuICAgIGZvciAoaSA9IDAgOyBpIDwgbSA7IGkrKykge1xuICAgICAgICBmb3IgKGogPSAwIDsgaiA8IG4gOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChlcShhcnIxW2ldLCBhcnIyW2pdKSkge1xuICAgICAgICAgICAgICAgIHBbaV1bal09MTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcFtpXVtqXT0wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBxID0gbmV3QXJyYXkobSsxLCBuKzEpO1xuICAgIGZvciAoaSA9IDAgOyBpIDwgbSArIDEgOyBpKyspIHtcbiAgICAgICAgcVtpXVtuXSA9IDA7XG4gICAgfVxuICAgIGZvciAoaSA9IDAgOyBpIDwgbiArIDEgOyBpKyspIHtcbiAgICAgICAgcVttXVtpXSA9IDA7IFxuICAgIH1cblxuICAgIGZvciAoaSA9IG0gLSAxIDsgaSA+PSAwIDsgaS0tKSB7XG4gICAgICAgIGZvciAoaiA9IG4gLSAxIDsgaiA+PSAwIDsgai0tKSB7XG4gICAgICAgICAgICB2YXIgbWF4LCBtYXhpLCBtYXhqO1xuICAgICAgICAgICAgaWYgKHFbaV1baisxXSA+PSBxW2krMV1bal0pIHtcbiAgICAgICAgICAgICAgICBtYXggPSBxW2ldW2orMV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1heCA9IHFbaSsxXVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChxW2krMV1baisxXSArIHBbaV1bal0gPiBtYXgpIHtcbiAgICAgICAgICAgICAgICBtYXggPSBxW2krMV1baisxXSsxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcVtpXVtqXSA9IG1heDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBtYXhRID0gLTE7XG4gICAgZm9yIChpID0gMCA7IGkgPCBtIDsgaSsrKSB7XG4gICAgICAgIGlmIChwW2ldWzBdID09IDEgJiYgKG1heFEgPT0gLTEgfHwgcVtpXVswXSA+IG1heFEpKSB7ICBcbiAgICAgICAgICAgIG1heFEgPSBxW2ldWzBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IDAgOyBpIDwgbiA7IGkrKykge1xuICAgICAgICBpZiAocFswXVtpXSA9PSAxICYmIHFbMF1baV0gPiBtYXhRKSB7ICBcbiAgICAgICAgICAgICBtYXhRID0gcVswXVtpXTtcbiAgICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcyA9IG1heFE7XG4gICAgdmFyIHBhdGggPSBuZXcgQXJyYXkoKTtcbiAgICB2YXIgaCA9IC0xO1xuXG4gICAgZm9yIChpID0gMCA7IGkgPCBtIDsgaSsrKSB7XG4gICAgICAgIGZvciAoaiA9IDAgOyBqIDwgbiA7IGorKykge1xuICAgICAgICAgICAgaWYgKHBbaV1bal0gPT0gMSAmJiBxW2ldW2pdID09IG1heFEpIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IGk7XG4gICAgICAgICAgICAgICAgdmFyIHkgPSBqO1xuICAgICAgICAgICAgICAgIHBhdGgucHVzaChpKTtcbiAgICAgICAgICAgICAgICBwYXRoLnB1c2goaik7XG4gICAgICAgICAgICAgICAgcyA9IHMgLSAxO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2lnbmFsID0gdHJ1ZTsgXG4gICAgICAgICAgICAgICAgICAgIHZhciB1LCB2LCB4MSwgeTE7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodSA9IHggKyAxIDsgdSA8IG0gJiYgc2lnbmFsIDsgdSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2ID0geSArIDEgOyB2IDwgbiAmJiBzaWduYWwgOyB2KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocFt1XVt2XSA9PSAxICYmIHFbdV1bdl0gPT0gcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoLnB1c2godSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGgucHVzaCh2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSB1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MSA9IHY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbD1mYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeCA9IHgxO1xuICAgICAgICAgICAgICAgICAgICB5ID0geTE7XG4gICAgICAgICAgICAgICAgICAgIHMgPSBzLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGggPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoID4gLTEpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRpID0gMCwgdGogPSAwO1xuICAgIHZhciBzaSwgc2osIHN1bSA9IDA7XG5cbiAgICB2YXIgcmVtb3ZlZCA9IG5ldyBBcnJheSgpO1xuICAgIHZhciBhZGRlZCA9IG5ldyBBcnJheSgpO1xuICAgIHZhciByZW1haW4gPSBuZXcgQXJyYXkoKTtcblxuICAgIGZvciAoayA9IDAgOyBrIDwgcGF0aC5sZW5ndGggOyBrID0gayArIDIpIHtcbiAgICAgICAgc2kgPSBwYXRoW2tdO1xuICAgICAgICBzaiA9IHBhdGhbaysxXTtcbiAgICAgICAgcmVtYWluLnB1c2goe1xuICAgICAgICAgICAgZnJvbTogc2ksIFxuICAgICAgICAgICAgdG86IHNqXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgZm9yIChqID0gdGkgOyBqIDwgc2kgOyBqKyspIHtcbiAgICAgICAgICAgIHJlbW92ZWQucHVzaCh7XG4gICAgICAgICAgICAgICAgZnJvbTogaiArIHN1bSwgLy8g5LuO5ZOq5YS/5Yig6ZmkXG4gICAgICAgICAgICAgICAgY29udGVudDogYXJyMVtqXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdW0tLTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGogPSB0aiA7IGogPCBzaiA7IGorKykge1xuICAgICAgICAgICAgYWRkZWQucHVzaCh7XG4gICAgICAgICAgICAgICAgdG86IGosIC8vIOiwg+aVtOWQjueahOS9jee9rlxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGFycjJbal1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRpID0gc2k7XG4gICAgICAgIHRqID0gc2o7XG4gICAgICAgIHRpKys7XG4gICAgICAgIHRqKys7XG4gICAgfVxuICAgIHNpID0gbTtcbiAgICBzaiA9IG47XG4gICAgZm9yIChqID0gdGkgOyBqIDwgc2kgOyBqKyspIHtcbiAgICAgICAgcmVtb3ZlZC5wdXNoKHtcbiAgICAgICAgICAgIGZyb206IGogKyBzdW0sIFxuICAgICAgICAgICAgY29udGVudDogYXJyMVtqXVxuICAgICAgICB9KTtcbiAgICAgICAgc3VtLS07XG4gICAgfVxuICAgIGZvciAoaiA9IHRqIDsgaiA8IHNqIDsgaisrKSB7XG4gICAgICAgIGFkZGVkLnB1c2goe1xuICAgICAgICAgICAgdG86IGosICAvLyDosIPmlbTlkI7nmoTkvY3nva5cbiAgICAgICAgICAgIGNvbnRlbnQ6IGFycjJbal1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZWQ6IHJlbW92ZWQsIFxuICAgICAgICBhZGRlZDogYWRkZWQsIFxuICAgICAgICByZW1haW46IHJlbWFpblxuICAgIH1cbn1cblxuLy8g5Y676ZmkPHNwYW4gb2Zmc2V0PVwieHh4XCIgbGVuZ3RoPVwieHh4XCI+PC9zcGFuPueahOW9seWTjeadpeavlOi+g++8jOi/meS4quS4jeWQjOeQhuiuuuS4iuW6lOivpeaUvuWcqOWkluWxgu+8jFxuLy8g5L2G5piv5Zug5Li66L+U5Zue55qEYWRkZWTnm7TmjqXlsLHmmK9zdHJpbmfogIzkuI3mmK9pbmRleO+8jOaUvuWcqOWkluWxguS4jeWlveWkhOeQhu+8jOW+heaUuei/m++8gVxuZnVuY3Rpb24gZXEoaHRtbDEsIGh0bWwyKSB7XG4gICAgLyp2YXIgYTEgPSBodG1sMTtcbiAgICB2YXIgYTEgPSBhMS5zdWJzdHJpbmcoYTEuaW5kZXhPZignPicpICsgMSk7XG4gICAgdmFyIGExID0gYTEuc3Vic3RyaW5nKDAsIGExLmxhc3RJbmRleE9mKCc8JykpO1xuICAgIHZhciBhMiA9IGh0bWwyO1xuICAgIHZhciBhMiA9IGEyLnN1YnN0cmluZyhhMi5pbmRleE9mKCc+JykgKyAxKTtcbiAgICB2YXIgYTIgPSBhMi5zdWJzdHJpbmcoMCwgYTIubGFzdEluZGV4T2YoJzwnKSk7XG4gICAgcmV0dXJuIGExID09IGEyOyovXG4gICAgcmV0dXJuIGh0bWwxID09IGh0bWwyO1xufVxuXG5mdW5jdGlvbiBkaWZmKGFycjEsIGFycjIpIHtcbiAgICBpZiAoIWFycjEpIHtcbiAgICAgICAgYXJyMSA9IG5ldyBBcnJheSgpO1xuICAgIH1cbiAgICBpZiAoIWFycjIpIHtcbiAgICAgICAgYXJyMiA9IG5ldyBBcnJheSgpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0TWF4TWF0Y2goYXJyMSwgYXJyMik7XG59XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGRpZmY7XG59IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGRpZmY7IH0pO1xufSBlbHNlIHtcbiAgICB0aGlzLmRpZmYgPSBkaWZmO1xufVxuXG59KS5jYWxsKGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcyB8fCAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwpO1xufSgpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2RpZmYudGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("// dop is short for Document Operation\n\n/*\n    命令，封装 document.execCommand\n*/\n\nconst Util = __webpack_require__(/*! ./dop.util */ 1);\nconst UA = Util.UA;\nconst dop = Util.dop;\n\n// 构造函数\nfunction Command(inputArea) {\n    this.inputArea = inputArea;\n}\n\nCommand.prototype.do = function(name, value) {\n    const inputArea = this.inputArea;\n\n    // 执行\n    const commandName = '_' + name\n    if (this[commandName]) {\n        // 有自定义事件\n        this[commandName](value);\n    } else {\n        // 默认 command\n        this._execCommand(name, value);\n    }\n}\n\n// 封装 execCommand\nCommand.prototype._execCommand = function (name, value) {\n    document.execCommand(name, false, value);\n}\n\n// 封装 document.queryCommandValue\nCommand.prototype.queryCommandValue = function (name) {\n    return document.queryCommandValue(name);\n}\n\n// 封装 document.queryCommandState\nCommand.prototype.queryCommandState = function (name) {\n    return document.queryCommandState(name);\n}\n\n// 封装 document.queryCommandSupported\nCommand.prototype.queryCommandSupported = function (name) {\n    return document.queryCommandSupported(name);\n}\n\n// 插入html代码\nCommand.prototype._insertHTML = function(html) {\n    const inputArea = this.inputArea;\n    const selection = this.selection;\n\n    const range = this.getRange();\n\n    // 保证传入的参数是 html 代码\n    const test = /^<.+>$/.test(html)\n    if (!test && !UA.isWebkit()) {\n        // webkit 可以插入非 html 格式的文字\n        throw new Error('执行 insertHTML 命令时传入的参数必须是 html 格式')\n    }\n\n    if (this.queryCommandSupported('insertHTML')) {\n        // W3C\n        this._execCommand('insertHTML', html)\n    } else if (range.insertNode) {\n        // IE\n        range.deleteContents();\n        var elems = dop(html);\n        for (var i = 0 ; i < elems.length ; i++) {\n            range.insertNode(elems[i]);\n        }\n    } else if (range.pasteHTML) {\n        // IE <= 10\n        range.pasteHTML(html)\n    } \n}\n\n// 插入 elem\nCommand.prototype._insertElement = function (elem) {\n    const inputArea = this.inputArea;\n    const selection = this.selection;\n    const range = selection.getRange();\n\n    if (range.insertNode) {\n        range.deleteContents();\n        range.insertNode(elem);\n    }\n}\n\n// 直接照搬Selection的getRange\nCommand.prototype.getRange = function() {\n    // 获取当前的选区\n    const selection = window.getSelection();\n    if (selection.rangeCount === 0) {\n        return null;\n    }\n    range = selection.getRangeAt(0);\n\n    // 判断选区内容是否在编辑内容之内\n    let container = range.commonAncestorContainer;\n    if (container.nodeType != 1) {\n        container = container.parentNode;\n    }\n    if (!container) {\n        return null;\n    }\n\n    if (this.inputArea.contains(container)) {\n        return range;\n    }\n    return null;\n};\n\nmodule.exports = Command;\n// export default Command;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9kb3AuY29tbWFuZC5qcz8wN2ZmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGRvcCBpcyBzaG9ydCBmb3IgRG9jdW1lbnQgT3BlcmF0aW9uXG5cbi8qXG4gICAg5ZG95Luk77yM5bCB6KOFIGRvY3VtZW50LmV4ZWNDb21tYW5kXG4qL1xuXG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi9kb3AudXRpbCcpO1xuY29uc3QgVUEgPSBVdGlsLlVBO1xuY29uc3QgZG9wID0gVXRpbC5kb3A7XG5cbi8vIOaehOmAoOWHveaVsFxuZnVuY3Rpb24gQ29tbWFuZChpbnB1dEFyZWEpIHtcbiAgICB0aGlzLmlucHV0QXJlYSA9IGlucHV0QXJlYTtcbn1cblxuQ29tbWFuZC5wcm90b3R5cGUuZG8gPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIGNvbnN0IGlucHV0QXJlYSA9IHRoaXMuaW5wdXRBcmVhO1xuXG4gICAgLy8g5omn6KGMXG4gICAgY29uc3QgY29tbWFuZE5hbWUgPSAnXycgKyBuYW1lXG4gICAgaWYgKHRoaXNbY29tbWFuZE5hbWVdKSB7XG4gICAgICAgIC8vIOacieiHquWumuS5ieS6i+S7tlxuICAgICAgICB0aGlzW2NvbW1hbmROYW1lXSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8g6buY6K6kIGNvbW1hbmRcbiAgICAgICAgdGhpcy5fZXhlY0NvbW1hbmQobmFtZSwgdmFsdWUpO1xuICAgIH1cbn1cblxuLy8g5bCB6KOFIGV4ZWNDb21tYW5kXG5Db21tYW5kLnByb3RvdHlwZS5fZXhlY0NvbW1hbmQgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBkb2N1bWVudC5leGVjQ29tbWFuZChuYW1lLCBmYWxzZSwgdmFsdWUpO1xufVxuXG4vLyDlsIHoo4UgZG9jdW1lbnQucXVlcnlDb21tYW5kVmFsdWVcbkNvbW1hbmQucHJvdG90eXBlLnF1ZXJ5Q29tbWFuZFZhbHVlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlDb21tYW5kVmFsdWUobmFtZSk7XG59XG5cbi8vIOWwgeijhSBkb2N1bWVudC5xdWVyeUNvbW1hbmRTdGF0ZVxuQ29tbWFuZC5wcm90b3R5cGUucXVlcnlDb21tYW5kU3RhdGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5xdWVyeUNvbW1hbmRTdGF0ZShuYW1lKTtcbn1cblxuLy8g5bCB6KOFIGRvY3VtZW50LnF1ZXJ5Q29tbWFuZFN1cHBvcnRlZFxuQ29tbWFuZC5wcm90b3R5cGUucXVlcnlDb21tYW5kU3VwcG9ydGVkID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlDb21tYW5kU3VwcG9ydGVkKG5hbWUpO1xufVxuXG4vLyDmj5LlhaVodG1s5Luj56CBXG5Db21tYW5kLnByb3RvdHlwZS5faW5zZXJ0SFRNTCA9IGZ1bmN0aW9uKGh0bWwpIHtcbiAgICBjb25zdCBpbnB1dEFyZWEgPSB0aGlzLmlucHV0QXJlYTtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbjtcblxuICAgIGNvbnN0IHJhbmdlID0gdGhpcy5nZXRSYW5nZSgpO1xuXG4gICAgLy8g5L+d6K+B5Lyg5YWl55qE5Y+C5pWw5pivIGh0bWwg5Luj56CBXG4gICAgY29uc3QgdGVzdCA9IC9ePC4rPiQvLnRlc3QoaHRtbClcbiAgICBpZiAoIXRlc3QgJiYgIVVBLmlzV2Via2l0KCkpIHtcbiAgICAgICAgLy8gd2Via2l0IOWPr+S7peaPkuWFpemdniBodG1sIOagvOW8j+eahOaWh+Wtl1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ+aJp+ihjCBpbnNlcnRIVE1MIOWRveS7pOaXtuS8oOWFpeeahOWPguaVsOW/hemhu+aYryBodG1sIOagvOW8jycpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMucXVlcnlDb21tYW5kU3VwcG9ydGVkKCdpbnNlcnRIVE1MJykpIHtcbiAgICAgICAgLy8gVzNDXG4gICAgICAgIHRoaXMuX2V4ZWNDb21tYW5kKCdpbnNlcnRIVE1MJywgaHRtbClcbiAgICB9IGVsc2UgaWYgKHJhbmdlLmluc2VydE5vZGUpIHtcbiAgICAgICAgLy8gSUVcbiAgICAgICAgcmFuZ2UuZGVsZXRlQ29udGVudHMoKTtcbiAgICAgICAgdmFyIGVsZW1zID0gZG9wKGh0bWwpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBlbGVtcy5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgICAgIHJhbmdlLmluc2VydE5vZGUoZWxlbXNbaV0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChyYW5nZS5wYXN0ZUhUTUwpIHtcbiAgICAgICAgLy8gSUUgPD0gMTBcbiAgICAgICAgcmFuZ2UucGFzdGVIVE1MKGh0bWwpXG4gICAgfSBcbn1cblxuLy8g5o+S5YWlIGVsZW1cbkNvbW1hbmQucHJvdG90eXBlLl9pbnNlcnRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICBjb25zdCBpbnB1dEFyZWEgPSB0aGlzLmlucHV0QXJlYTtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbjtcbiAgICBjb25zdCByYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZSgpO1xuXG4gICAgaWYgKHJhbmdlLmluc2VydE5vZGUpIHtcbiAgICAgICAgcmFuZ2UuZGVsZXRlQ29udGVudHMoKTtcbiAgICAgICAgcmFuZ2UuaW5zZXJ0Tm9kZShlbGVtKTtcbiAgICB9XG59XG5cbi8vIOebtOaOpeeFp+aQrFNlbGVjdGlvbueahGdldFJhbmdlXG5Db21tYW5kLnByb3RvdHlwZS5nZXRSYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIOiOt+WPluW9k+WJjeeahOmAieWMulxuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG5cbiAgICAvLyDliKTmlq3pgInljLrlhoXlrrnmmK/lkKblnKjnvJbovpHlhoXlrrnkuYvlhoVcbiAgICBsZXQgY29udGFpbmVyID0gcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG4gICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSAhPSAxKSB7XG4gICAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgIH1cbiAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pbnB1dEFyZWEuY29udGFpbnMoY29udGFpbmVyKSkge1xuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb21tYW5kO1xuLy8gZXhwb3J0IGRlZmF1bHQgQ29tbWFuZDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9kb3AuY29tbWFuZC5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("//import Selection from './dop.selection.js';\n//import Command from './dop.command.js';\nvar Selection = __webpack_require__(/*! ./dop.selection */ 0);\nvar Command = __webpack_require__(/*! ./dop.command */ 7);\n\n\n/**\n * 构造函数\n */\nfunction Text(inputArea) {\n    this.inputArea = inputArea;\n    this.selection = new Selection(inputArea);\n    this.command = new Command(inputArea);\n\n    this.enableTab();\n    this.rewritePaste();\n    this.rewriteCopy();\n    this.rewriteCut();\n}\n\nText.prototype.initChangeDetect = function(onchange) {\n    var inputArea = this.inputArea;\n    var preHTML = '';\n    var lastTimer = 0;\n    inputArea.onchange = function(e) {\n        clearTimeout(lastTimer);\n        lastTimer = setTimeout(function() {\n            if (preHTML !== inputArea.innerHTML) {\n                preHTML = inputArea.innerHTML;\n                console.log('changed');\n                onchange();\n            }\n        }, 100);\n        return false;\n    }\n\n    inputArea.onblur = inputArea.onchange;\n    inputArea.onkeyup = inputArea.onchange;\n    //inputArea.onpaste = inputArea.onchange;\n    inputArea.oninput = inputArea.onchange;\n}\n\nText.prototype.rewritePaste = function() {\n    var selection = this.selection;\n    this.inputArea.addEventListener('paste', function(e) {\n        // console.log(e.clipboardData.getData());\n        const clipboardData = e.clipboardData || (e.originalEvent && e.originalEvent.clipboardData);\n        let pasteText, pasteHtml;\n        if (clipboardData == null) {\n            pasteText = window.clipboardData && window.clipboardData.getData('text')\n        } else {\n            pasteText = clipboardData.getData('text/plain')\n            pasteHtml = clipboardData.getData('text/html')\n        }\n        if (pasteHtml) {\n            var fake = document.createElement('div');\n            fake.innerHTML = pasteHtml;\n            pasteText = fake.innerText;\n        }\n        pasteText = pasteText.replace(/</gm, '&lt;')\n                .replace(/>/gm, '&gt;')\n                .replace(/\"/gm, '&quot;')\n                .replace(/ /gm, '&nbsp;');\n        pasteHtml = '';\n        var slis = pasteText.split(/\\n/);\n        for (let i = 0 ; i < slis.length ; i++) {\n            var sli = slis[i];\n            if (sli.length == 0) {\n                pasteHtml += '<p><br></p>';\n            } else {\n                pasteHtml += `<p>${sli}</p>`;\n            }\n        }\n\n        // 恢复选取\n        selection.restoreSelection()\n        document.execCommand('insertHTML', false, pasteHtml);\n        selection.saveRange()\n        //selection.restoreSelection()\n        // 使用 execCommand 的粘贴命令，阻止默认行为\n        e.preventDefault();\n\n        // TODO 滚到底部\n    });\n}\n\nText.prototype.enableTab = function() {\n    // 处理tab\n    this.inputArea.addEventListener('keydown', function(e) {\n        if (e.keyCode !== 9) {\n            return false;\n        }\n        if (!document.queryCommandSupported('insertHTML')) {\n            // 必须原生支持 insertHTML 命令\n            return false;\n        }\n        // 我们的输入框中只支持<p>和<br/>，一定是普通文字\n        document.execCommand('insertHTML', false, '&nbsp;&nbsp;&nbsp;&nbsp;')\n        e.preventDefault();\n    });\n}\n\n// 原生的复制会有点问题，这里重写\nText.prototype.rewriteCopy = function() {\n    this.inputArea.addEventListener('copy', function(e) {\n        // 浏览器在copy的时候，会莫名其妙得把<p></p>替换成两个回车符，这里删掉一个\n        // console.log(e.clipboardData.getData());\n        const clipboardData = e.clipboardData || (e.originalEvent && e.originalEvent.clipboardData);\n        if (!clipboardData) {\n            clipboardData = window.clipboardData;\n        }\n        if (clipboardData) {\n            var selectedText = window.getSelection().toString(); \n            /*var fake = document.createElement('div');\n            fake.innerHTML = selectedText;\n            console.dir(fake);\n            selectedText = selectedText.replace(/\\n{2}/gm, '\\n');*/\n            clipboardData.setData('text/plain', selectedText);\n            e.preventDefault();\n        }\n    });\n}\n\nText.prototype.rewriteCut = function() {\n    this.inputArea.addEventListener('cut', function(e) {\n        // 浏览器在copy的时候，会莫名其妙得把<p></p>替换成两个回车符，这里删掉一个\n        // console.log(e.clipboardData.getData());\n        const clipboardData = e.clipboardData || (e.originalEvent && e.originalEvent.clipboardData);\n        if (!clipboardData) {\n            clipboardData = window.clipboardData;\n        }\n        if (clipboardData) {\n            var selectedText = window.getSelection().toString(); \n            //selectedText = selectedText.replace(/\\n{2}/gm, '\\n');\n            clipboardData.setData('text/plain', selectedText);\n            document.execCommand('delete');\n            e.preventDefault();\n        }\n    });\n}\n\nText.prototype.round = function(prefix, suffix) {\n    let sel = this.selection, \n        cmd = this.command;\n\n    sel.saveRange();\n\n    if (prefix) {\n        sel.collapseRange(true);\n        sel.restoreSelection();\n        cmd.do('insertText', prefix);\n        sel.recollapse();\n        sel.offsetStart(prefix.length);\n        sel.restoreSelection();\n    }\n\n    if (suffix) {\n        sel.collapseRange(false);\n        sel.restoreSelection();\n        cmd.do('insertText', suffix);\n        sel.recollapse();\n        sel.restoreSelection();\n    }\n    \n    this.inputArea.onkeyup();\n}\n\nText.prototype.insertLineStart = function(text) {\n    let sel = this.selection, \n        cmd = this.command;\n\n    sel.saveRange();\n    var range = sel.getRange();\n\n    if (!range) {\n        return;\n    }\n\n    var start = sel.getStartElement();\n    while (true) {\n        if (start == this.inputArea) {\n            // 找到最后也找不到根级的p，直接返回\n            return;\n        }\n        if (start.parentNode == this.inputArea) {\n            break;\n        }\n        start = start.parentNode;\n    }\n    if (start) {\n        sel.createRangeByElement(start, true);\n        cmd.do('insertText', text);\n        sel.saveRange(range);\n        sel.restoreSelection();\n    }\n    \n    this.inputArea.onkeyup();\n}\n\n/**\n * mode = 1: toUpper; mode = 2: toLower; mode = 3: first toUpper\n */\nText.prototype.changeCase = function(mode) {\n    let sel = this.selection, \n        cmd = this.command;\n\n    sel.saveRange();\n    let range = sel.getRange();\n    if (!range) {\n        return;\n    }\n\n    if (range.startContainer != range.endContainer) {\n        var start = range.startContainer;\n        range.setEnd(start, start.length);\n    }\n\n    console.dir(range);\n    let text = range.startContainer.textContent;\n    text = text.substring(range.startOffset, range.endOffset);\n\n    switch (mode) {\n    case 1: text = text.toUpperCase(); break;\n    case 2: text = text.toLowerCase(); break;\n    case 3: text = text.substring(0, 1).toUpperCase() + text.substring(1).toLowerCase(); break;\n    default: break;\n    }\n\n    sel.restoreSelection();\n    cmd.do('insertText', text);\n    sel.recollapse();\n    sel.restoreSelection();\n    \n    this.inputArea.onkeyup();\n}\n\nText.prototype.insertList = function(isOrdered) {\n    if (isOrdered) {\n        this.insertLineStart('1. ');\n    } else {\n        this.insertLineStart('- ');\n    }\n};\n\nText.prototype.setContent = function(content) {\n    // 和重写粘贴逻辑类似\n    content = content.replace(/</gm, '&lt;')\n                .replace(/>/gm, '&gt;')\n                .replace(/\"/gm, '&quot;')\n                .replace(/ /gm, '&nbsp;');\n    var html = '';\n    var lines = content.split(/\\n/);\n    for (let i = 0 ; i < lines.length ; i++) {\n        var line = lines[i];\n        if (line.length == 0) {\n            html += '<p><br></p>';\n        } else {\n            html += `<p>${line}</p>`;\n        }\n    }\n\n    this.inputArea.innerHTML = html;\n}\n\nText.prototype.getContent = function() {\n    /*var content = this.inputArea.innerHTML.replace(/<p>/g, '\\n');\n    content = content.replace(/<\\/p>/g, '\\n');\n    content = content.replace(/<br>/g, '\\n');\n    content = content.replace(/<br\\/>/g, '\\n');*/\n    var children = this.inputArea.children;\n    var content = '';\n    for (var i = 0 ; i < children.length ; i++) {\n        var text = children[i].innerText;\n        if (text == '\\n') {\n            content += '\\n';\n        } else {\n            content += text + '\\n';\n        }\n    }\n    return content;\n}\n\nmodule.exports = Text;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9kb3AudGV4dC5qcz9kMjdjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vaW1wb3J0IFNlbGVjdGlvbiBmcm9tICcuL2RvcC5zZWxlY3Rpb24uanMnO1xuLy9pbXBvcnQgQ29tbWFuZCBmcm9tICcuL2RvcC5jb21tYW5kLmpzJztcbnZhciBTZWxlY3Rpb24gPSByZXF1aXJlKCcuL2RvcC5zZWxlY3Rpb24nKTtcbnZhciBDb21tYW5kID0gcmVxdWlyZSgnLi9kb3AuY29tbWFuZCcpO1xuXG5cbi8qKlxuICog5p6E6YCg5Ye95pWwXG4gKi9cbmZ1bmN0aW9uIFRleHQoaW5wdXRBcmVhKSB7XG4gICAgdGhpcy5pbnB1dEFyZWEgPSBpbnB1dEFyZWE7XG4gICAgdGhpcy5zZWxlY3Rpb24gPSBuZXcgU2VsZWN0aW9uKGlucHV0QXJlYSk7XG4gICAgdGhpcy5jb21tYW5kID0gbmV3IENvbW1hbmQoaW5wdXRBcmVhKTtcblxuICAgIHRoaXMuZW5hYmxlVGFiKCk7XG4gICAgdGhpcy5yZXdyaXRlUGFzdGUoKTtcbiAgICB0aGlzLnJld3JpdGVDb3B5KCk7XG4gICAgdGhpcy5yZXdyaXRlQ3V0KCk7XG59XG5cblRleHQucHJvdG90eXBlLmluaXRDaGFuZ2VEZXRlY3QgPSBmdW5jdGlvbihvbmNoYW5nZSkge1xuICAgIHZhciBpbnB1dEFyZWEgPSB0aGlzLmlucHV0QXJlYTtcbiAgICB2YXIgcHJlSFRNTCA9ICcnO1xuICAgIHZhciBsYXN0VGltZXIgPSAwO1xuICAgIGlucHV0QXJlYS5vbmNoYW5nZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGxhc3RUaW1lcik7XG4gICAgICAgIGxhc3RUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAocHJlSFRNTCAhPT0gaW5wdXRBcmVhLmlubmVySFRNTCkge1xuICAgICAgICAgICAgICAgIHByZUhUTUwgPSBpbnB1dEFyZWEuaW5uZXJIVE1MO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjaGFuZ2VkJyk7XG4gICAgICAgICAgICAgICAgb25jaGFuZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlucHV0QXJlYS5vbmJsdXIgPSBpbnB1dEFyZWEub25jaGFuZ2U7XG4gICAgaW5wdXRBcmVhLm9ua2V5dXAgPSBpbnB1dEFyZWEub25jaGFuZ2U7XG4gICAgLy9pbnB1dEFyZWEub25wYXN0ZSA9IGlucHV0QXJlYS5vbmNoYW5nZTtcbiAgICBpbnB1dEFyZWEub25pbnB1dCA9IGlucHV0QXJlYS5vbmNoYW5nZTtcbn1cblxuVGV4dC5wcm90b3R5cGUucmV3cml0ZVBhc3RlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uO1xuICAgIHRoaXMuaW5wdXRBcmVhLmFkZEV2ZW50TGlzdGVuZXIoJ3Bhc3RlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhlLmNsaXBib2FyZERhdGEuZ2V0RGF0YSgpKTtcbiAgICAgICAgY29uc3QgY2xpcGJvYXJkRGF0YSA9IGUuY2xpcGJvYXJkRGF0YSB8fCAoZS5vcmlnaW5hbEV2ZW50ICYmIGUub3JpZ2luYWxFdmVudC5jbGlwYm9hcmREYXRhKTtcbiAgICAgICAgbGV0IHBhc3RlVGV4dCwgcGFzdGVIdG1sO1xuICAgICAgICBpZiAoY2xpcGJvYXJkRGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICBwYXN0ZVRleHQgPSB3aW5kb3cuY2xpcGJvYXJkRGF0YSAmJiB3aW5kb3cuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCd0ZXh0JylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhc3RlVGV4dCA9IGNsaXBib2FyZERhdGEuZ2V0RGF0YSgndGV4dC9wbGFpbicpXG4gICAgICAgICAgICBwYXN0ZUh0bWwgPSBjbGlwYm9hcmREYXRhLmdldERhdGEoJ3RleHQvaHRtbCcpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhc3RlSHRtbCkge1xuICAgICAgICAgICAgdmFyIGZha2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGZha2UuaW5uZXJIVE1MID0gcGFzdGVIdG1sO1xuICAgICAgICAgICAgcGFzdGVUZXh0ID0gZmFrZS5pbm5lclRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgcGFzdGVUZXh0ID0gcGFzdGVUZXh0LnJlcGxhY2UoLzwvZ20sICcmbHQ7JylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvPi9nbSwgJyZndDsnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cIi9nbSwgJyZxdW90OycpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoLyAvZ20sICcmbmJzcDsnKTtcbiAgICAgICAgcGFzdGVIdG1sID0gJyc7XG4gICAgICAgIHZhciBzbGlzID0gcGFzdGVUZXh0LnNwbGl0KC9cXG4vKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAgOyBpIDwgc2xpcy5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzbGkgPSBzbGlzW2ldO1xuICAgICAgICAgICAgaWYgKHNsaS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIHBhc3RlSHRtbCArPSAnPHA+PGJyPjwvcD4nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXN0ZUh0bWwgKz0gYDxwPiR7c2xpfTwvcD5gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8g5oGi5aSN6YCJ5Y+WXG4gICAgICAgIHNlbGVjdGlvbi5yZXN0b3JlU2VsZWN0aW9uKClcbiAgICAgICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ2luc2VydEhUTUwnLCBmYWxzZSwgcGFzdGVIdG1sKTtcbiAgICAgICAgc2VsZWN0aW9uLnNhdmVSYW5nZSgpXG4gICAgICAgIC8vc2VsZWN0aW9uLnJlc3RvcmVTZWxlY3Rpb24oKVxuICAgICAgICAvLyDkvb/nlKggZXhlY0NvbW1hbmQg55qE57KY6LS05ZG95Luk77yM6Zi75q2i6buY6K6k6KGM5Li6XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAvLyBUT0RPIOa7muWIsOW6lemDqFxuICAgIH0pO1xufVxuXG5UZXh0LnByb3RvdHlwZS5lbmFibGVUYWIgPSBmdW5jdGlvbigpIHtcbiAgICAvLyDlpITnkIZ0YWJcbiAgICB0aGlzLmlucHV0QXJlYS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZS5rZXlDb2RlICE9PSA5KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkb2N1bWVudC5xdWVyeUNvbW1hbmRTdXBwb3J0ZWQoJ2luc2VydEhUTUwnKSkge1xuICAgICAgICAgICAgLy8g5b+F6aG75Y6f55Sf5pSv5oyBIGluc2VydEhUTUwg5ZG95LukXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8g5oiR5Lus55qE6L6T5YWl5qGG5Lit5Y+q5pSv5oyBPHA+5ZKMPGJyLz7vvIzkuIDlrprmmK/mma7pgJrmloflrZdcbiAgICAgICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ2luc2VydEhUTUwnLCBmYWxzZSwgJyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOycpXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9KTtcbn1cblxuLy8g5Y6f55Sf55qE5aSN5Yi25Lya5pyJ54K56Zeu6aKY77yM6L+Z6YeM6YeN5YaZXG5UZXh0LnByb3RvdHlwZS5yZXdyaXRlQ29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW5wdXRBcmVhLmFkZEV2ZW50TGlzdGVuZXIoJ2NvcHknLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIC8vIOa1j+iniOWZqOWcqGNvcHnnmoTml7blgJnvvIzkvJrojqvlkI3lhbblppnlvpfmioo8cD48L3A+5pu/5o2i5oiQ5Lik5Liq5Zue6L2m56ym77yM6L+Z6YeM5Yig5o6J5LiA5LiqXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGUuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCkpO1xuICAgICAgICBjb25zdCBjbGlwYm9hcmREYXRhID0gZS5jbGlwYm9hcmREYXRhIHx8IChlLm9yaWdpbmFsRXZlbnQgJiYgZS5vcmlnaW5hbEV2ZW50LmNsaXBib2FyZERhdGEpO1xuICAgICAgICBpZiAoIWNsaXBib2FyZERhdGEpIHtcbiAgICAgICAgICAgIGNsaXBib2FyZERhdGEgPSB3aW5kb3cuY2xpcGJvYXJkRGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xpcGJvYXJkRGF0YSkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkVGV4dCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKS50b1N0cmluZygpOyBcbiAgICAgICAgICAgIC8qdmFyIGZha2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGZha2UuaW5uZXJIVE1MID0gc2VsZWN0ZWRUZXh0O1xuICAgICAgICAgICAgY29uc29sZS5kaXIoZmFrZSk7XG4gICAgICAgICAgICBzZWxlY3RlZFRleHQgPSBzZWxlY3RlZFRleHQucmVwbGFjZSgvXFxuezJ9L2dtLCAnXFxuJyk7Ki9cbiAgICAgICAgICAgIGNsaXBib2FyZERhdGEuc2V0RGF0YSgndGV4dC9wbGFpbicsIHNlbGVjdGVkVGV4dCk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuVGV4dC5wcm90b3R5cGUucmV3cml0ZUN1dCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW5wdXRBcmVhLmFkZEV2ZW50TGlzdGVuZXIoJ2N1dCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgLy8g5rWP6KeI5Zmo5ZyoY29weeeahOaXtuWAme+8jOS8muiOq+WQjeWFtuWmmeW+l+aKijxwPjwvcD7mm7/mjaLmiJDkuKTkuKrlm57ovabnrKbvvIzov5nph4zliKDmjonkuIDkuKpcbiAgICAgICAgLy8gY29uc29sZS5sb2coZS5jbGlwYm9hcmREYXRhLmdldERhdGEoKSk7XG4gICAgICAgIGNvbnN0IGNsaXBib2FyZERhdGEgPSBlLmNsaXBib2FyZERhdGEgfHwgKGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQuY2xpcGJvYXJkRGF0YSk7XG4gICAgICAgIGlmICghY2xpcGJvYXJkRGF0YSkge1xuICAgICAgICAgICAgY2xpcGJvYXJkRGF0YSA9IHdpbmRvdy5jbGlwYm9hcmREYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGlwYm9hcmREYXRhKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRUZXh0ID0gd2luZG93LmdldFNlbGVjdGlvbigpLnRvU3RyaW5nKCk7IFxuICAgICAgICAgICAgLy9zZWxlY3RlZFRleHQgPSBzZWxlY3RlZFRleHQucmVwbGFjZSgvXFxuezJ9L2dtLCAnXFxuJyk7XG4gICAgICAgICAgICBjbGlwYm9hcmREYXRhLnNldERhdGEoJ3RleHQvcGxhaW4nLCBzZWxlY3RlZFRleHQpO1xuICAgICAgICAgICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ2RlbGV0ZScpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cblRleHQucHJvdG90eXBlLnJvdW5kID0gZnVuY3Rpb24ocHJlZml4LCBzdWZmaXgpIHtcbiAgICBsZXQgc2VsID0gdGhpcy5zZWxlY3Rpb24sIFxuICAgICAgICBjbWQgPSB0aGlzLmNvbW1hbmQ7XG5cbiAgICBzZWwuc2F2ZVJhbmdlKCk7XG5cbiAgICBpZiAocHJlZml4KSB7XG4gICAgICAgIHNlbC5jb2xsYXBzZVJhbmdlKHRydWUpO1xuICAgICAgICBzZWwucmVzdG9yZVNlbGVjdGlvbigpO1xuICAgICAgICBjbWQuZG8oJ2luc2VydFRleHQnLCBwcmVmaXgpO1xuICAgICAgICBzZWwucmVjb2xsYXBzZSgpO1xuICAgICAgICBzZWwub2Zmc2V0U3RhcnQocHJlZml4Lmxlbmd0aCk7XG4gICAgICAgIHNlbC5yZXN0b3JlU2VsZWN0aW9uKCk7XG4gICAgfVxuXG4gICAgaWYgKHN1ZmZpeCkge1xuICAgICAgICBzZWwuY29sbGFwc2VSYW5nZShmYWxzZSk7XG4gICAgICAgIHNlbC5yZXN0b3JlU2VsZWN0aW9uKCk7XG4gICAgICAgIGNtZC5kbygnaW5zZXJ0VGV4dCcsIHN1ZmZpeCk7XG4gICAgICAgIHNlbC5yZWNvbGxhcHNlKCk7XG4gICAgICAgIHNlbC5yZXN0b3JlU2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuaW5wdXRBcmVhLm9ua2V5dXAoKTtcbn1cblxuVGV4dC5wcm90b3R5cGUuaW5zZXJ0TGluZVN0YXJ0ID0gZnVuY3Rpb24odGV4dCkge1xuICAgIGxldCBzZWwgPSB0aGlzLnNlbGVjdGlvbiwgXG4gICAgICAgIGNtZCA9IHRoaXMuY29tbWFuZDtcblxuICAgIHNlbC5zYXZlUmFuZ2UoKTtcbiAgICB2YXIgcmFuZ2UgPSBzZWwuZ2V0UmFuZ2UoKTtcblxuICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzdGFydCA9IHNlbC5nZXRTdGFydEVsZW1lbnQoKTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAoc3RhcnQgPT0gdGhpcy5pbnB1dEFyZWEpIHtcbiAgICAgICAgICAgIC8vIOaJvuWIsOacgOWQjuS5n+aJvuS4jeWIsOaguee6p+eahHDvvIznm7TmjqXov5Tlm55cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQucGFyZW50Tm9kZSA9PSB0aGlzLmlucHV0QXJlYSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnQgPSBzdGFydC5wYXJlbnROb2RlO1xuICAgIH1cbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgc2VsLmNyZWF0ZVJhbmdlQnlFbGVtZW50KHN0YXJ0LCB0cnVlKTtcbiAgICAgICAgY21kLmRvKCdpbnNlcnRUZXh0JywgdGV4dCk7XG4gICAgICAgIHNlbC5zYXZlUmFuZ2UocmFuZ2UpO1xuICAgICAgICBzZWwucmVzdG9yZVNlbGVjdGlvbigpO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLmlucHV0QXJlYS5vbmtleXVwKCk7XG59XG5cbi8qKlxuICogbW9kZSA9IDE6IHRvVXBwZXI7IG1vZGUgPSAyOiB0b0xvd2VyOyBtb2RlID0gMzogZmlyc3QgdG9VcHBlclxuICovXG5UZXh0LnByb3RvdHlwZS5jaGFuZ2VDYXNlID0gZnVuY3Rpb24obW9kZSkge1xuICAgIGxldCBzZWwgPSB0aGlzLnNlbGVjdGlvbiwgXG4gICAgICAgIGNtZCA9IHRoaXMuY29tbWFuZDtcblxuICAgIHNlbC5zYXZlUmFuZ2UoKTtcbiAgICBsZXQgcmFuZ2UgPSBzZWwuZ2V0UmFuZ2UoKTtcbiAgICBpZiAoIXJhbmdlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocmFuZ2Uuc3RhcnRDb250YWluZXIgIT0gcmFuZ2UuZW5kQ29udGFpbmVyKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgICByYW5nZS5zZXRFbmQoc3RhcnQsIHN0YXJ0Lmxlbmd0aCk7XG4gICAgfVxuXG4gICAgY29uc29sZS5kaXIocmFuZ2UpO1xuICAgIGxldCB0ZXh0ID0gcmFuZ2Uuc3RhcnRDb250YWluZXIudGV4dENvbnRlbnQ7XG4gICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKHJhbmdlLnN0YXJ0T2Zmc2V0LCByYW5nZS5lbmRPZmZzZXQpO1xuXG4gICAgc3dpdGNoIChtb2RlKSB7XG4gICAgY2FzZSAxOiB0ZXh0ID0gdGV4dC50b1VwcGVyQ2FzZSgpOyBicmVhaztcbiAgICBjYXNlIDI6IHRleHQgPSB0ZXh0LnRvTG93ZXJDYXNlKCk7IGJyZWFrO1xuICAgIGNhc2UgMzogdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyB0ZXh0LnN1YnN0cmluZygxKS50b0xvd2VyQ2FzZSgpOyBicmVhaztcbiAgICBkZWZhdWx0OiBicmVhaztcbiAgICB9XG5cbiAgICBzZWwucmVzdG9yZVNlbGVjdGlvbigpO1xuICAgIGNtZC5kbygnaW5zZXJ0VGV4dCcsIHRleHQpO1xuICAgIHNlbC5yZWNvbGxhcHNlKCk7XG4gICAgc2VsLnJlc3RvcmVTZWxlY3Rpb24oKTtcbiAgICBcbiAgICB0aGlzLmlucHV0QXJlYS5vbmtleXVwKCk7XG59XG5cblRleHQucHJvdG90eXBlLmluc2VydExpc3QgPSBmdW5jdGlvbihpc09yZGVyZWQpIHtcbiAgICBpZiAoaXNPcmRlcmVkKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0TGluZVN0YXJ0KCcxLiAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmluc2VydExpbmVTdGFydCgnLSAnKTtcbiAgICB9XG59O1xuXG5UZXh0LnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24oY29udGVudCkge1xuICAgIC8vIOWSjOmHjeWGmeeymOi0tOmAu+i+keexu+S8vFxuICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoLzwvZ20sICcmbHQ7JylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvPi9nbSwgJyZndDsnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cIi9nbSwgJyZxdW90OycpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoLyAvZ20sICcmbmJzcDsnKTtcbiAgICB2YXIgaHRtbCA9ICcnO1xuICAgIHZhciBsaW5lcyA9IGNvbnRlbnQuc3BsaXQoL1xcbi8pO1xuICAgIGZvciAobGV0IGkgPSAwIDsgaSA8IGxpbmVzLmxlbmd0aCA7IGkrKykge1xuICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgICBpZiAobGluZS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgaHRtbCArPSAnPHA+PGJyPjwvcD4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaHRtbCArPSBgPHA+JHtsaW5lfTwvcD5gO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5pbnB1dEFyZWEuaW5uZXJIVE1MID0gaHRtbDtcbn1cblxuVGV4dC5wcm90b3R5cGUuZ2V0Q29udGVudCA9IGZ1bmN0aW9uKCkge1xuICAgIC8qdmFyIGNvbnRlbnQgPSB0aGlzLmlucHV0QXJlYS5pbm5lckhUTUwucmVwbGFjZSgvPHA+L2csICdcXG4nKTtcbiAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC88XFwvcD4vZywgJ1xcbicpO1xuICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoLzxicj4vZywgJ1xcbicpO1xuICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoLzxiclxcLz4vZywgJ1xcbicpOyovXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5pbnB1dEFyZWEuY2hpbGRyZW47XG4gICAgdmFyIGNvbnRlbnQgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBjaGlsZHJlbi5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgdmFyIHRleHQgPSBjaGlsZHJlbltpXS5pbm5lclRleHQ7XG4gICAgICAgIGlmICh0ZXh0ID09ICdcXG4nKSB7XG4gICAgICAgICAgICBjb250ZW50ICs9ICdcXG4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGVudCArPSB0ZXh0ICsgJ1xcbic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVGV4dDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9kb3AudGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("var defaults = __webpack_require__(/*! ./common.defaults */ 4);\nvar tools = __webpack_require__(/*! ./common.tools */ 5);\nvar marked = __webpack_require__(/*! ./marked.core */ 10);\nvar diff = __webpack_require__(/*! ./diff.text */ 6);\nvar Selection = __webpack_require__(/*! ./dop.selection */ 0);\nvar Text = __webpack_require__(/*! ./dop.text */ 8);\nvar TimeoutLock = tools.TimeoutLock;\n\n/*\n * ==========================================================\n * based：https://github.com/chjj/marked\n * forkmde\n * 功能点参考：https://pandao.github.io/editor.md/\n * ==========================================================\n */\nfunction ForkMDE(parent, options) {\n    var contentName = (options.contentName ) \n        ? options.contentName \n        : defaults.contentName;\n    var contentId = (options.contentId) \n        ? options.contentId \n        : defaults.contentId;\n\n    var centerContent = document.createElement('div');\n    centerContent.id = 'forkmde-inner-editor';\n    centerContent.className = 'forkmde-inner-editor';\n\n    var inputArea = document.createElement('div');\n    inputArea.name = contentName;\n    inputArea.id = contentId;\n    inputArea.className = 'forkmde-inner-content'\n    inputArea.contentEditable = true;\n    inputArea.innerHTML = '<p><br></p>';\n    this.inputArea = inputArea;\n    this.textarea = new Text(inputArea);\n\n    var preview = document.createElement('div');\n    preview.id = 'forkmde-outer-content';\n    preview.className = 'forkmde-outer-content';\n    this.preview = preview;\n\n    centerContent.appendChild(inputArea);\n    centerContent.appendChild(preview);\n\n    var actionsBar = document.createElement('div');\n    actionsBar.id = 'forkmde-inner-actions';\n    actionsBar.className = 'forkmde-inner-actions';\n    this.fillActions(actionsBar, options.actions);\n\n    parent.appendChild(actionsBar);\n    parent.appendChild(centerContent);\n\n    var _this = this;\n    this.lock = new TimeoutLock(null, 300); // 解决两侧scroll事件互相干扰的锁\n\n    this.prevComps = new Array();\n    this.initScroll();\n\n    /*marked.setOptions({\n        highlight: function(code) {\n            return hljs.highlightAuto(code).value;\n        }\n    });*/\n    if (typeof mermaidAPI != 'undefined') {\n        mermaidAPI.initialize({\n            startOnLoad: false, \n            logLevel: 5\n        });\n    }\n\n    this.initOnChange();\n}\n\nForkMDE.prototype.initOnChange = function() {\n    var _this = this;\n    this.textarea.initChangeDetect(function() {\n        _this.triggerChange();\n    }); // 不能直接initChangeDetect(_this.triggerChange)，这样会改变this的指向\n}\n\nForkMDE.prototype.triggerChange = function() {\n    var text = this.textarea.getContent();\n    var thisComps = marked(text, {\n        toArray: true\n    });\n    var simpleComps = new Array();\n    for (var i = 0 ; i < thisComps.length ; i++) {\n        simpleComps.push(thisComps[i].html);;\n    }\n    var ds = diff(this.prevComps, simpleComps);\n    //var ds2 = diff2(this.prevComps, simpleComps);\n    this.prevComps = simpleComps;\n\n    /*console.log(this.prevComps);\n    console.log(thisComps);\n    console.log(ds);*/\n    //console.log(ds2);\n\n    children = this.preview.children;\n    if (ds.remain && ds.remain.length > 0) {\n        for (var i = 0 ; i < ds.remain.length ; i++) {\n            var item = ds.remain[i];\n            var from = item.from, to = item.to;\n            children[item.from].setAttribute('offset', thisComps[to].offset);\n            children[item.from].setAttribute('length', thisComps[to].length); \n        }\n    }\n    if (ds.removed && ds.removed.length > 0) {\n        for (var i = 0 ; i < ds.removed.length ; i++) {\n            var item = ds.removed[i];\n            var from = item.from;\n            // console.log('remove: ' + children[from].innerHTML);\n            this.lock.update(this.inputArea); // 不要让preview的插入/删除操作激发输入框的scroll\n            this.preview.removeChild(children[from])\n            children = this.preview.children;\n        }\n    }\n    if (ds.added && ds.added.length > 0) {\n        for (var i = 0 ; i < ds.added.length ; i++) {\n            var item = ds.added[i];\n            var div = document.createElement(\"div\");\n            var to = item.to;\n            div.innerHTML = '<div offset=\"' + thisComps[to].offset + '\" length=\"' + thisComps[to].length + '\">' + thisComps[to].html + '</div>';\n            var span = div.children[0]; // span貌似拿不到offsetHeight，所以换成了div\n            var existing = to < children.length ? children[to] : null;\n            // console.log('insert: ' + span.innerHTML);\n            this.lock.update(this.inputArea);\n            this.preview.insertBefore(span, existing);\n            children = this.preview.children;\n        }\n    }\n\n    // 渲染完之后要触发一次输入框的scroll，让右侧滚动到对应的位置上\n    $(this.inputArea).scroll();\n}\n\n// 获取inputArea > p中的文本内容\nForkMDE.prototype.pText = function(p) {\n    var text = p.innerText;\n    return text == '\\n' ? '' : text;\n}\n\n// 获取输入区域的滚动字符偏移值\nForkMDE.prototype.getInputScrollOffset = function() {\n    var inputArea = this.inputArea;\n    var children = inputArea.children;\n    var offset = 0;\n    for (var i = 0 ; i < children.length ; i++) {\n        var blockLength = this.pText(children[i]).length + 1, // 1 for '\\n'\n            blockTop = children[i].offsetTop, \n            blockHeight = i < children.length - 1 ? children[i+1].offsetTop - children[i].offsetTop : children[i].offsetHeight, \n            containerTop = inputArea.scrollTop;\n\n        if (blockTop >= containerTop) { \n            // 由于margin的存在，这种情况很普遍，上一个元素还top+height<=containerTop，下一个就top>containerTop了。\n            break;\n        }\n\n        if (blockTop + blockHeight > containerTop) {\n            //console.log('containerTop: ' + containerTop);\n            //console.log('blockTop: ' + blockTop);\n            offset += blockLength * (containerTop - blockTop) / blockHeight;\n            break;\n        }\n        offset += blockLength; // 1 for '\\n'\n    }\n    return offset;\n}\n\nForkMDE.prototype.getInputTargetTop = function(offset) {\n    var inputArea = this.inputArea;\n    var children = inputArea.children;\n    for (var i = 0 ; i < children.length ; i++) {\n        var blockLength = this.pText(children[i]).length + 1, \n            blockTop = children[i].offsetTop, \n            blockHeight = i < children.length - 1 ? children[i+1].offsetTop - children[i].offsetTop : children[i].offsetHeight;\n\n        if (blockLength > offset) {\n            return blockHeight * offset / blockLength+ blockTop;\n        }\n        offset -= blockLength;\n    }\n\n    // 没找到对应点的话直接滚到最后\n    return inputArea.scrollHeight - inputArea.clientHeight;\n}\n\nForkMDE.prototype.getPreviewScrollOffset = function() {\n    var preview = this.preview;\n    var children = preview.children;\n    var FOE = 0; // 处理极端情况\n    for (var i = 0 ; i < children.length ; i++) {\n        var blockOffset = parseInt(children[i].getAttribute('offset')), \n            blockLength = parseInt(children[i].getAttribute('length')), \n            blockTop = children[i].offsetTop, \n            blockHeight = i < children.length - 1 ? children[i+1].offsetTop - children[i].offsetTop : children[i].offsetHeight, \n            containerTop = preview.scrollTop;\n\n        FOE = blockOffset + blockLength;\n        if (blockTop + blockHeight > containerTop) {\n            return blockLength * (containerTop - blockTop) / blockHeight + blockOffset;\n        }\n    }\n    return FOE;\n}\n\n// 根据字符offset把预览区域滚动到目标位置\nForkMDE.prototype.getPreviewTargetTop = function(offset) {\n    var preview = this.preview;\n    var children = preview.children;\n    for (var i = 0 ; i < children.length ; i++) {\n        var blockOffset = parseInt(children[i].getAttribute('offset')), \n            blockLength = parseInt(children[i].getAttribute('length')), \n            blockTop = children[i].offsetTop, \n            blockHeight = i < children.length - 1 ? children[i+1].offsetTop - children[i].offsetTop : children[i].offsetHeight;\n\n        if (blockOffset + blockLength > offset) {\n            return blockHeight * (offset - blockOffset) / blockLength + blockTop;\n        }\n    }\n    // 最后的offset可能是空格之类的没有渲染，直接滚到最后\n    return preview.scrollHeight - preview.clientHeight;\n}\n\nForkMDE.prototype.initScroll = function() {\n    var _this = this;\n    var inputArea = this.inputArea;\n    var preview = this.preview;\n    // 左右两侧的滚动效果会相互触发，左边滚动之后修改右侧的scrollTop就会再触发右侧的滚动事件，\n    // 所以用一个activeElement和activeTime来判断，假设依据是用户不会在100ms之内切换操作。（如果用户\n    // 真的这么操作了，也只是在100ms之内不连带滚动而已，没什么影响）\n    var lock = this.lock;\n    var rendering = null;\n\n    $(inputArea).scroll(function(e) {\n        if (rendering || !lock.check(inputArea)) {\n            return true;\n        }\n        rendering = true;\n        lock.update(inputArea);\n\n        // 找左侧的offset\n        var offset = _this.getInputScrollOffset();\n        // 根据左侧offset找右侧的偏移\n        lock.update(inputArea);\n        preview.scrollTop = _this.getPreviewTargetTop(offset);\n\n        rendering = false;\n    });\n\n    $(preview).scroll(function(e) {\n        if (!lock.check(preview)) {\n            return true;\n        }\n        lock.update(preview);\n        console.log('preview scroll???')\n\n        // 找右侧的offset\n        var offset = _this.getPreviewScrollOffset();\n        // 根据右侧offset找左侧的偏移\n        lock.update(preview);\n        inputArea.scrollTop = _this.getInputTargetTop(offset);\n    });\n}\n\nForkMDE.prototype.fillActions = function(actionsBar, optActions) {\n    var self = this;\n    var actions = [];\n    actions.push({\n        item: '<i class=\"fa fa-bold\" aria-hidden=\"true\" title=\"粗体\"></i>', \n        action: function() { self.textarea.round(\"**\", \"**\"); }\n    });\n\n    actions.push({\n        item: '<i class=\"fa fa-italic\" title=\"斜体\"></i>', \n        action: function() { self.textarea.round(\"*\", \"*\"); }\n    });\n\n    actions.push({\n        item: '<i class=\"fa fa-strikethrough\" title=\"删除线\"></i>', \n        action: function() { self.textarea.round(\"~~\", \"~~\"); }\n    });\n\n    actions.push({\n        item: '<i class=\"fa fa-underline\" title=\"下划线\"></i>', \n        action: function() { self.textarea.round(\"++\", \"++\"); }\n    });\n\n    actions.push({\n        item: '<i class=\"material-icons\" title=\"高亮\">highlight</i>', \n        action: function() { self.textarea.round(\"==\", \"==\"); }\n    });\n\n    actions.push({\n        item: '<i class=\"fa fa-quote-right\" title=\"引用\"></i>', \n        action: function() { self.textarea.insertLineStart(\">\"); }\n    });\n\n    actions.push({\n        item: '<i class=\"fa fa-code\" title=\"行内代码\"></i>', \n        action: function() { self.textarea.round(\"`\", \"`\"); }\n    });\n\n    actions.push({\n        item: '<i class=\"fa fa-file-code-o\" title=\"代码块\"></i>', \n        action: function() { self.textarea.insertLineStart(\"    \"); }\n    });\n\n    actions.push({\n        item: '<i class=\"fa fa-table\" title=\"表格\"></i>', \n        action: function() { self.textarea.round(\"\\nheader 1 | header 2\\n---|---\\nrow 1 col 1 | row 1 col 2\\nrow 2 col 1 | row 2 col 2\\n\\n\", \"\"); }\n    });\n\n    actions.push({\n        item: '<span title=\"仅首字母大写\">Aa</span>', \n        action: function() { self.textarea.changeCase(3); }\n    });\n\n    actions.push({\n        item: '<span title=\"选中部分全部转为大写\">AA</span>', \n        action: function() { self.textarea.changeCase(1); }\n    });\n\n    actions.push({\n        item: '<span title=\"选中部分全部转为小写\">aa</span>', \n        action: function() { self.textarea.changeCase(2); }\n    });\n\n    actions.push({\n        item: '<i class=\"fa fa-photo\" title=\"插入图片\"></i>', \n        action: function() { self.textarea.round(\"![image](https://github.com/fluidicon.png)\"); }\n    });\n\n    actions.push({\n        item: '<span title=\"h1\">H1</span>', \n        action: function() { self.textarea.insertLineStart(\"# \"); }\n    });\n\n    actions.push({\n        item: '<span title=\"h2\">H2</span>', \n        action: function() { self.textarea.insertLineStart(\"## \"); }\n    });\n\n    actions.push({\n        item: '<span title=\"h3\">H3</span>', \n        action: function() { self.textarea.insertLineStart(\"### \"); }\n    });\n\n    actions.push({\n        item: '<span title=\"h4\">H4</span>', \n        action: function() { self.textarea.insertLineStart(\"#### \"); }\n    });\n\n    actions.push({\n        item: '<span title=\"h5\">H5</span>', \n        action: function() { self.textarea.insertLineStart(\"##### \"); }\n    });\n\n    actions.push({\n        item: '<span title=\"h6\">H6</span>', \n        action: function() { self.textarea.insertLineStart(\"###### \"); }\n    });\n\n    actions.push({\n        item: '<i class=\"fa fa-minus\" title=\"横线\"></i>', \n        action: function() { self.textarea.round(\"\\n---\\n\", \"\"); }\n    });\n\n    actions.push({\n        item: '<i class=\"fa fa-link\" title=\"超链接\"></i>', \n        action: function() { self.textarea.round('[example](\"http://example.org\")', ''); }\n    });\n\n    actions.push({\n        item: '<i class=\"fa fa-list-ul\" title=\"无序列表\"></i>', \n        action: function() { self.textarea.insertList(false); }\n    });\n\n    actions.push({\n        item: '<i class=\"fa fa-list-ol\" title=\"有序列表\"></i>', \n        action: function() { self.textarea.insertList(true); }\n    });\n\n    actions.push({\n        item: '<i class=\"fa fa-subscript\" title=\"数学公式\"></i>', \n        action: function() { self.textarea.round('```\\nmath\\nc = \\\\pm\\\\sqrt{a^2 + b^2}\\n```\\n'); }\n    });\n\n    actions.push({\n        item: '<i class=\"fa fa-line-chart\" title=\"流程图\"></i>', \n        // action: function() { _this.insert('```\\nflowChart\\nst=>start: Start:>http://www.google.com[blank]\\ne=>end:>http://www.google.com\\nop1=>operation: My Operation\\nsub1=>subroutine: My Subroutine\\ncond=>condition: Yes or No?:>http://www.google.com\\nio=>inputoutput: catch something...\\n\\nst->op1->cond\\ncond(yes)->io->e\\ncond(no)->sub1(right)->op1\\n```\\n', ''); }\n        action: function() { self.textarea.round('```\\ngraph TD;\\n    A-->B;\\n    A-->C;\\n    B-->D;\\n    C-->D;\\n```\\n'); }\n    });\n\n    actions.push({\n        item: '<i class=\"fa fa-exchange\" title=\"时序图\"></i>', \n        // action: function() { _this.insert('```\\nhandseq\\nA->>C: How are you?\\nB->>A: Great!\\n```\\n', ''); }\n        action: function() { self.textarea.round('```\\nsequenceDiagram\\n    participant John\\n    participant Alice\\n    Alice->>John: Hello John, how are you?\\n    John-->>Alice: Great!\\n```\\n', ''); }\n    });\n\n    actions.push({\n        item: '<i class=\"fa fa-bars\" title=\"甘特图\"></i>', \n        action: function() { self.textarea.round('```\\ngantt\\n    title A Gantt Diagram\\n\\n    section Section\\n    A task           :a1, 2014-01-01, 30d\\n \\\n        Another task     :after a1  , 20d\\n    section Another\\n    Task in sec      :2014-01-12  , 12d\\n    anther task      : 24d\\n```\\n', ''); }\n    });\n\n    if (Array.isArray(optActions)) {\n        for (var i = 0 ; i < optActions.length ; i++) {\n            actions.push(optActions[i]);\n        }\n    }\n\n    actions.push({\n        item: '<i class=\"fa fa-download\" title=\"下载PDF\"></i>', \n        action: function() { \n            /*$print = $('<div class=\"forkmde-outer-content\"></div>');\n            $print.html($(_this.preview).html());\n            $print.css('width', '100%');\n            var options = {\n              mode : 'popup', \n              popClose : 'true', \n              popWd: $('body').width()*0.8 + 'px',\n              popX: $('body').width()*0.1 + 'px',\n              popY: '100px', \n              retainAttr: ['id', 'class', 'style'], \n              extraHead: '<meta charset=\"utf-8\" />,<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"/>'\n            }\n            $print.printArea(options); */\n        }\n    });\n\n    for (var i in actions) {\n        if (!actions[i].item || !actions[i].action) {\n            continue;\n        }\n        var item = document.createElement('button');\n        item.type = 'button';\n        item.setAttribute('idx', i);\n        item.innerHTML = actions[i].item;\n        item.onclick = function() {\n            actions[this.getAttribute('idx')].action(self);\n        }\n        actionsBar.appendChild(item);\n    }\n}\n\nForkMDE.prototype.setText = function(text) {\n    this.textarea.setContent(text);\n}\n\nForkMDE.prototype.getText = function() {\n    return this.textarea.getContent();\n}\n\n$.fn.forkmdeEditor = function(options) {\n    return new ForkMDE($(this), options)\n}\n\n$.fn.renderMarked = function(text) {\n    $(this).html(marked(text));\n    mermaid.init(undefined, \".mermaid\");\n}\n\nwindow.ForkMDE = {\n    renderMarked: function() {\n\n    }, \n    initEditor: function(element, options) {\n        return new ForkMDE(element, options);\n    }, \n    parse: function(text) {\n        return marked(text);\n    }\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9lbnRyeS5qcz84ZDI0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vY29tbW9uLmRlZmF1bHRzJyk7XG52YXIgdG9vbHMgPSByZXF1aXJlKCcuL2NvbW1vbi50b29scycpO1xudmFyIG1hcmtlZCA9IHJlcXVpcmUoJy4vbWFya2VkLmNvcmUnKTtcbnZhciBkaWZmID0gcmVxdWlyZSgnLi9kaWZmLnRleHQnKTtcbnZhciBTZWxlY3Rpb24gPSByZXF1aXJlKCcuL2RvcC5zZWxlY3Rpb24nKTtcbnZhciBUZXh0ID0gcmVxdWlyZSgnLi9kb3AudGV4dCcpO1xudmFyIFRpbWVvdXRMb2NrID0gdG9vbHMuVGltZW91dExvY2s7XG5cbi8qXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBiYXNlZO+8mmh0dHBzOi8vZ2l0aHViLmNvbS9jaGpqL21hcmtlZFxuICogZm9ya21kZVxuICog5Yqf6IO954K55Y+C6ICD77yaaHR0cHM6Ly9wYW5kYW8uZ2l0aHViLmlvL2VkaXRvci5tZC9cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gRm9ya01ERShwYXJlbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgY29udGVudE5hbWUgPSAob3B0aW9ucy5jb250ZW50TmFtZSApIFxuICAgICAgICA/IG9wdGlvbnMuY29udGVudE5hbWUgXG4gICAgICAgIDogZGVmYXVsdHMuY29udGVudE5hbWU7XG4gICAgdmFyIGNvbnRlbnRJZCA9IChvcHRpb25zLmNvbnRlbnRJZCkgXG4gICAgICAgID8gb3B0aW9ucy5jb250ZW50SWQgXG4gICAgICAgIDogZGVmYXVsdHMuY29udGVudElkO1xuXG4gICAgdmFyIGNlbnRlckNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjZW50ZXJDb250ZW50LmlkID0gJ2ZvcmttZGUtaW5uZXItZWRpdG9yJztcbiAgICBjZW50ZXJDb250ZW50LmNsYXNzTmFtZSA9ICdmb3JrbWRlLWlubmVyLWVkaXRvcic7XG5cbiAgICB2YXIgaW5wdXRBcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgaW5wdXRBcmVhLm5hbWUgPSBjb250ZW50TmFtZTtcbiAgICBpbnB1dEFyZWEuaWQgPSBjb250ZW50SWQ7XG4gICAgaW5wdXRBcmVhLmNsYXNzTmFtZSA9ICdmb3JrbWRlLWlubmVyLWNvbnRlbnQnXG4gICAgaW5wdXRBcmVhLmNvbnRlbnRFZGl0YWJsZSA9IHRydWU7XG4gICAgaW5wdXRBcmVhLmlubmVySFRNTCA9ICc8cD48YnI+PC9wPic7XG4gICAgdGhpcy5pbnB1dEFyZWEgPSBpbnB1dEFyZWE7XG4gICAgdGhpcy50ZXh0YXJlYSA9IG5ldyBUZXh0KGlucHV0QXJlYSk7XG5cbiAgICB2YXIgcHJldmlldyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHByZXZpZXcuaWQgPSAnZm9ya21kZS1vdXRlci1jb250ZW50JztcbiAgICBwcmV2aWV3LmNsYXNzTmFtZSA9ICdmb3JrbWRlLW91dGVyLWNvbnRlbnQnO1xuICAgIHRoaXMucHJldmlldyA9IHByZXZpZXc7XG5cbiAgICBjZW50ZXJDb250ZW50LmFwcGVuZENoaWxkKGlucHV0QXJlYSk7XG4gICAgY2VudGVyQ29udGVudC5hcHBlbmRDaGlsZChwcmV2aWV3KTtcblxuICAgIHZhciBhY3Rpb25zQmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYWN0aW9uc0Jhci5pZCA9ICdmb3JrbWRlLWlubmVyLWFjdGlvbnMnO1xuICAgIGFjdGlvbnNCYXIuY2xhc3NOYW1lID0gJ2ZvcmttZGUtaW5uZXItYWN0aW9ucyc7XG4gICAgdGhpcy5maWxsQWN0aW9ucyhhY3Rpb25zQmFyLCBvcHRpb25zLmFjdGlvbnMpO1xuXG4gICAgcGFyZW50LmFwcGVuZENoaWxkKGFjdGlvbnNCYXIpO1xuICAgIHBhcmVudC5hcHBlbmRDaGlsZChjZW50ZXJDb250ZW50KTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5sb2NrID0gbmV3IFRpbWVvdXRMb2NrKG51bGwsIDMwMCk7IC8vIOino+WGs+S4pOS+p3Njcm9sbOS6i+S7tuS6kuebuOW5suaJsOeahOmUgVxuXG4gICAgdGhpcy5wcmV2Q29tcHMgPSBuZXcgQXJyYXkoKTtcbiAgICB0aGlzLmluaXRTY3JvbGwoKTtcblxuICAgIC8qbWFya2VkLnNldE9wdGlvbnMoe1xuICAgICAgICBoaWdobGlnaHQ6IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBobGpzLmhpZ2hsaWdodEF1dG8oY29kZSkudmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTsqL1xuICAgIGlmICh0eXBlb2YgbWVybWFpZEFQSSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICBtZXJtYWlkQVBJLmluaXRpYWxpemUoe1xuICAgICAgICAgICAgc3RhcnRPbkxvYWQ6IGZhbHNlLCBcbiAgICAgICAgICAgIGxvZ0xldmVsOiA1XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdE9uQ2hhbmdlKCk7XG59XG5cbkZvcmtNREUucHJvdG90eXBlLmluaXRPbkNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy50ZXh0YXJlYS5pbml0Q2hhbmdlRGV0ZWN0KGZ1bmN0aW9uKCkge1xuICAgICAgICBfdGhpcy50cmlnZ2VyQ2hhbmdlKCk7XG4gICAgfSk7IC8vIOS4jeiDveebtOaOpWluaXRDaGFuZ2VEZXRlY3QoX3RoaXMudHJpZ2dlckNoYW5nZSnvvIzov5nmoLfkvJrmlLnlj5h0aGlz55qE5oyH5ZCRXG59XG5cbkZvcmtNREUucHJvdG90eXBlLnRyaWdnZXJDaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGV4dCA9IHRoaXMudGV4dGFyZWEuZ2V0Q29udGVudCgpO1xuICAgIHZhciB0aGlzQ29tcHMgPSBtYXJrZWQodGV4dCwge1xuICAgICAgICB0b0FycmF5OiB0cnVlXG4gICAgfSk7XG4gICAgdmFyIHNpbXBsZUNvbXBzID0gbmV3IEFycmF5KCk7XG4gICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgdGhpc0NvbXBzLmxlbmd0aCA7IGkrKykge1xuICAgICAgICBzaW1wbGVDb21wcy5wdXNoKHRoaXNDb21wc1tpXS5odG1sKTs7XG4gICAgfVxuICAgIHZhciBkcyA9IGRpZmYodGhpcy5wcmV2Q29tcHMsIHNpbXBsZUNvbXBzKTtcbiAgICAvL3ZhciBkczIgPSBkaWZmMih0aGlzLnByZXZDb21wcywgc2ltcGxlQ29tcHMpO1xuICAgIHRoaXMucHJldkNvbXBzID0gc2ltcGxlQ29tcHM7XG5cbiAgICAvKmNvbnNvbGUubG9nKHRoaXMucHJldkNvbXBzKTtcbiAgICBjb25zb2xlLmxvZyh0aGlzQ29tcHMpO1xuICAgIGNvbnNvbGUubG9nKGRzKTsqL1xuICAgIC8vY29uc29sZS5sb2coZHMyKTtcblxuICAgIGNoaWxkcmVuID0gdGhpcy5wcmV2aWV3LmNoaWxkcmVuO1xuICAgIGlmIChkcy5yZW1haW4gJiYgZHMucmVtYWluLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgZHMucmVtYWluLmxlbmd0aCA7IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBkcy5yZW1haW5baV07XG4gICAgICAgICAgICB2YXIgZnJvbSA9IGl0ZW0uZnJvbSwgdG8gPSBpdGVtLnRvO1xuICAgICAgICAgICAgY2hpbGRyZW5baXRlbS5mcm9tXS5zZXRBdHRyaWJ1dGUoJ29mZnNldCcsIHRoaXNDb21wc1t0b10ub2Zmc2V0KTtcbiAgICAgICAgICAgIGNoaWxkcmVuW2l0ZW0uZnJvbV0uc2V0QXR0cmlidXRlKCdsZW5ndGgnLCB0aGlzQ29tcHNbdG9dLmxlbmd0aCk7IFxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkcy5yZW1vdmVkICYmIGRzLnJlbW92ZWQubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBkcy5yZW1vdmVkLmxlbmd0aCA7IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBkcy5yZW1vdmVkW2ldO1xuICAgICAgICAgICAgdmFyIGZyb20gPSBpdGVtLmZyb207XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygncmVtb3ZlOiAnICsgY2hpbGRyZW5bZnJvbV0uaW5uZXJIVE1MKTtcbiAgICAgICAgICAgIHRoaXMubG9jay51cGRhdGUodGhpcy5pbnB1dEFyZWEpOyAvLyDkuI3opoHorqlwcmV2aWV355qE5o+S5YWlL+WIoOmZpOaTjeS9nOa/gOWPkei+k+WFpeahhueahHNjcm9sbFxuICAgICAgICAgICAgdGhpcy5wcmV2aWV3LnJlbW92ZUNoaWxkKGNoaWxkcmVuW2Zyb21dKVxuICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLnByZXZpZXcuY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRzLmFkZGVkICYmIGRzLmFkZGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgZHMuYWRkZWQubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGRzLmFkZGVkW2ldO1xuICAgICAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB2YXIgdG8gPSBpdGVtLnRvO1xuICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9ICc8ZGl2IG9mZnNldD1cIicgKyB0aGlzQ29tcHNbdG9dLm9mZnNldCArICdcIiBsZW5ndGg9XCInICsgdGhpc0NvbXBzW3RvXS5sZW5ndGggKyAnXCI+JyArIHRoaXNDb21wc1t0b10uaHRtbCArICc8L2Rpdj4nO1xuICAgICAgICAgICAgdmFyIHNwYW4gPSBkaXYuY2hpbGRyZW5bMF07IC8vIHNwYW7osozkvLzmi7/kuI3liLBvZmZzZXRIZWlnaHTvvIzmiYDku6XmjaLmiJDkuoZkaXZcbiAgICAgICAgICAgIHZhciBleGlzdGluZyA9IHRvIDwgY2hpbGRyZW4ubGVuZ3RoID8gY2hpbGRyZW5bdG9dIDogbnVsbDtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdpbnNlcnQ6ICcgKyBzcGFuLmlubmVySFRNTCk7XG4gICAgICAgICAgICB0aGlzLmxvY2sudXBkYXRlKHRoaXMuaW5wdXRBcmVhKTtcbiAgICAgICAgICAgIHRoaXMucHJldmlldy5pbnNlcnRCZWZvcmUoc3BhbiwgZXhpc3RpbmcpO1xuICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLnByZXZpZXcuY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDmuLLmn5PlrozkuYvlkI7opoHop6blj5HkuIDmrKHovpPlhaXmoYbnmoRzY3JvbGzvvIzorqnlj7Pkvqfmu5rliqjliLDlr7nlupTnmoTkvY3nva7kuIpcbiAgICAkKHRoaXMuaW5wdXRBcmVhKS5zY3JvbGwoKTtcbn1cblxuLy8g6I635Y+WaW5wdXRBcmVhID4gcOS4reeahOaWh+acrOWGheWuuVxuRm9ya01ERS5wcm90b3R5cGUucFRleHQgPSBmdW5jdGlvbihwKSB7XG4gICAgdmFyIHRleHQgPSBwLmlubmVyVGV4dDtcbiAgICByZXR1cm4gdGV4dCA9PSAnXFxuJyA/ICcnIDogdGV4dDtcbn1cblxuLy8g6I635Y+W6L6T5YWl5Yy65Z+f55qE5rua5Yqo5a2X56ym5YGP56e75YC8XG5Gb3JrTURFLnByb3RvdHlwZS5nZXRJbnB1dFNjcm9sbE9mZnNldCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbnB1dEFyZWEgPSB0aGlzLmlucHV0QXJlYTtcbiAgICB2YXIgY2hpbGRyZW4gPSBpbnB1dEFyZWEuY2hpbGRyZW47XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgY2hpbGRyZW4ubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgIHZhciBibG9ja0xlbmd0aCA9IHRoaXMucFRleHQoY2hpbGRyZW5baV0pLmxlbmd0aCArIDEsIC8vIDEgZm9yICdcXG4nXG4gICAgICAgICAgICBibG9ja1RvcCA9IGNoaWxkcmVuW2ldLm9mZnNldFRvcCwgXG4gICAgICAgICAgICBibG9ja0hlaWdodCA9IGkgPCBjaGlsZHJlbi5sZW5ndGggLSAxID8gY2hpbGRyZW5baSsxXS5vZmZzZXRUb3AgLSBjaGlsZHJlbltpXS5vZmZzZXRUb3AgOiBjaGlsZHJlbltpXS5vZmZzZXRIZWlnaHQsIFxuICAgICAgICAgICAgY29udGFpbmVyVG9wID0gaW5wdXRBcmVhLnNjcm9sbFRvcDtcblxuICAgICAgICBpZiAoYmxvY2tUb3AgPj0gY29udGFpbmVyVG9wKSB7IFxuICAgICAgICAgICAgLy8g55Sx5LqObWFyZ2lu55qE5a2Y5Zyo77yM6L+Z56eN5oOF5Ya15b6I5pmu6YGN77yM5LiK5LiA5Liq5YWD57Sg6L+YdG9wK2hlaWdodDw9Y29udGFpbmVyVG9w77yM5LiL5LiA5Liq5bCxdG9wPmNvbnRhaW5lclRvcOS6huOAglxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYmxvY2tUb3AgKyBibG9ja0hlaWdodCA+IGNvbnRhaW5lclRvcCkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnY29udGFpbmVyVG9wOiAnICsgY29udGFpbmVyVG9wKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2Jsb2NrVG9wOiAnICsgYmxvY2tUb3ApO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGJsb2NrTGVuZ3RoICogKGNvbnRhaW5lclRvcCAtIGJsb2NrVG9wKSAvIGJsb2NrSGVpZ2h0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ICs9IGJsb2NrTGVuZ3RoOyAvLyAxIGZvciAnXFxuJ1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0O1xufVxuXG5Gb3JrTURFLnByb3RvdHlwZS5nZXRJbnB1dFRhcmdldFRvcCA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgIHZhciBpbnB1dEFyZWEgPSB0aGlzLmlucHV0QXJlYTtcbiAgICB2YXIgY2hpbGRyZW4gPSBpbnB1dEFyZWEuY2hpbGRyZW47XG4gICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgY2hpbGRyZW4ubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgIHZhciBibG9ja0xlbmd0aCA9IHRoaXMucFRleHQoY2hpbGRyZW5baV0pLmxlbmd0aCArIDEsIFxuICAgICAgICAgICAgYmxvY2tUb3AgPSBjaGlsZHJlbltpXS5vZmZzZXRUb3AsIFxuICAgICAgICAgICAgYmxvY2tIZWlnaHQgPSBpIDwgY2hpbGRyZW4ubGVuZ3RoIC0gMSA/IGNoaWxkcmVuW2krMV0ub2Zmc2V0VG9wIC0gY2hpbGRyZW5baV0ub2Zmc2V0VG9wIDogY2hpbGRyZW5baV0ub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgIGlmIChibG9ja0xlbmd0aCA+IG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIGJsb2NrSGVpZ2h0ICogb2Zmc2V0IC8gYmxvY2tMZW5ndGgrIGJsb2NrVG9wO1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCAtPSBibG9ja0xlbmd0aDtcbiAgICB9XG5cbiAgICAvLyDmsqHmib7liLDlr7nlupTngrnnmoTor53nm7TmjqXmu5rliLDmnIDlkI5cbiAgICByZXR1cm4gaW5wdXRBcmVhLnNjcm9sbEhlaWdodCAtIGlucHV0QXJlYS5jbGllbnRIZWlnaHQ7XG59XG5cbkZvcmtNREUucHJvdG90eXBlLmdldFByZXZpZXdTY3JvbGxPZmZzZXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcHJldmlldyA9IHRoaXMucHJldmlldztcbiAgICB2YXIgY2hpbGRyZW4gPSBwcmV2aWV3LmNoaWxkcmVuO1xuICAgIHZhciBGT0UgPSAwOyAvLyDlpITnkIbmnoHnq6/mg4XlhrVcbiAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBjaGlsZHJlbi5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgdmFyIGJsb2NrT2Zmc2V0ID0gcGFyc2VJbnQoY2hpbGRyZW5baV0uZ2V0QXR0cmlidXRlKCdvZmZzZXQnKSksIFxuICAgICAgICAgICAgYmxvY2tMZW5ndGggPSBwYXJzZUludChjaGlsZHJlbltpXS5nZXRBdHRyaWJ1dGUoJ2xlbmd0aCcpKSwgXG4gICAgICAgICAgICBibG9ja1RvcCA9IGNoaWxkcmVuW2ldLm9mZnNldFRvcCwgXG4gICAgICAgICAgICBibG9ja0hlaWdodCA9IGkgPCBjaGlsZHJlbi5sZW5ndGggLSAxID8gY2hpbGRyZW5baSsxXS5vZmZzZXRUb3AgLSBjaGlsZHJlbltpXS5vZmZzZXRUb3AgOiBjaGlsZHJlbltpXS5vZmZzZXRIZWlnaHQsIFxuICAgICAgICAgICAgY29udGFpbmVyVG9wID0gcHJldmlldy5zY3JvbGxUb3A7XG5cbiAgICAgICAgRk9FID0gYmxvY2tPZmZzZXQgKyBibG9ja0xlbmd0aDtcbiAgICAgICAgaWYgKGJsb2NrVG9wICsgYmxvY2tIZWlnaHQgPiBjb250YWluZXJUb3ApIHtcbiAgICAgICAgICAgIHJldHVybiBibG9ja0xlbmd0aCAqIChjb250YWluZXJUb3AgLSBibG9ja1RvcCkgLyBibG9ja0hlaWdodCArIGJsb2NrT2Zmc2V0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBGT0U7XG59XG5cbi8vIOagueaNruWtl+espm9mZnNldOaKiumihOiniOWMuuWfn+a7muWKqOWIsOebruagh+S9jee9rlxuRm9ya01ERS5wcm90b3R5cGUuZ2V0UHJldmlld1RhcmdldFRvcCA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgIHZhciBwcmV2aWV3ID0gdGhpcy5wcmV2aWV3O1xuICAgIHZhciBjaGlsZHJlbiA9IHByZXZpZXcuY2hpbGRyZW47XG4gICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgY2hpbGRyZW4ubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgIHZhciBibG9ja09mZnNldCA9IHBhcnNlSW50KGNoaWxkcmVuW2ldLmdldEF0dHJpYnV0ZSgnb2Zmc2V0JykpLCBcbiAgICAgICAgICAgIGJsb2NrTGVuZ3RoID0gcGFyc2VJbnQoY2hpbGRyZW5baV0uZ2V0QXR0cmlidXRlKCdsZW5ndGgnKSksIFxuICAgICAgICAgICAgYmxvY2tUb3AgPSBjaGlsZHJlbltpXS5vZmZzZXRUb3AsIFxuICAgICAgICAgICAgYmxvY2tIZWlnaHQgPSBpIDwgY2hpbGRyZW4ubGVuZ3RoIC0gMSA/IGNoaWxkcmVuW2krMV0ub2Zmc2V0VG9wIC0gY2hpbGRyZW5baV0ub2Zmc2V0VG9wIDogY2hpbGRyZW5baV0ub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgIGlmIChibG9ja09mZnNldCArIGJsb2NrTGVuZ3RoID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gYmxvY2tIZWlnaHQgKiAob2Zmc2V0IC0gYmxvY2tPZmZzZXQpIC8gYmxvY2tMZW5ndGggKyBibG9ja1RvcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyDmnIDlkI7nmoRvZmZzZXTlj6/og73mmK/nqbrmoLzkuYvnsbvnmoTmsqHmnInmuLLmn5PvvIznm7TmjqXmu5rliLDmnIDlkI5cbiAgICByZXR1cm4gcHJldmlldy5zY3JvbGxIZWlnaHQgLSBwcmV2aWV3LmNsaWVudEhlaWdodDtcbn1cblxuRm9ya01ERS5wcm90b3R5cGUuaW5pdFNjcm9sbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGlucHV0QXJlYSA9IHRoaXMuaW5wdXRBcmVhO1xuICAgIHZhciBwcmV2aWV3ID0gdGhpcy5wcmV2aWV3O1xuICAgIC8vIOW3puWPs+S4pOS+p+eahOa7muWKqOaViOaenOS8muebuOS6kuinpuWPke+8jOW3pui+uea7muWKqOS5i+WQjuS/ruaUueWPs+S+p+eahHNjcm9sbFRvcOWwseS8muWGjeinpuWPkeWPs+S+p+eahOa7muWKqOS6i+S7tu+8jFxuICAgIC8vIOaJgOS7peeUqOS4gOS4qmFjdGl2ZUVsZW1lbnTlkoxhY3RpdmVUaW1l5p2l5Yik5pat77yM5YGH6K6+5L6d5o2u5piv55So5oi35LiN5Lya5ZyoMTAwbXPkuYvlhoXliIfmjaLmk43kvZzjgILvvIjlpoLmnpznlKjmiLdcbiAgICAvLyDnnJ/nmoTov5nkuYjmk43kvZzkuobvvIzkuZ/lj6rmmK/lnKgxMDBtc+S5i+WGheS4jei/nuW4pua7muWKqOiAjOW3su+8jOayoeS7gOS5iOW9seWTje+8iVxuICAgIHZhciBsb2NrID0gdGhpcy5sb2NrO1xuICAgIHZhciByZW5kZXJpbmcgPSBudWxsO1xuXG4gICAgJChpbnB1dEFyZWEpLnNjcm9sbChmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChyZW5kZXJpbmcgfHwgIWxvY2suY2hlY2soaW5wdXRBcmVhKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyaW5nID0gdHJ1ZTtcbiAgICAgICAgbG9jay51cGRhdGUoaW5wdXRBcmVhKTtcblxuICAgICAgICAvLyDmib7lt6bkvqfnmoRvZmZzZXRcbiAgICAgICAgdmFyIG9mZnNldCA9IF90aGlzLmdldElucHV0U2Nyb2xsT2Zmc2V0KCk7XG4gICAgICAgIC8vIOagueaNruW3puS+p29mZnNldOaJvuWPs+S+p+eahOWBj+enu1xuICAgICAgICBsb2NrLnVwZGF0ZShpbnB1dEFyZWEpO1xuICAgICAgICBwcmV2aWV3LnNjcm9sbFRvcCA9IF90aGlzLmdldFByZXZpZXdUYXJnZXRUb3Aob2Zmc2V0KTtcblxuICAgICAgICByZW5kZXJpbmcgPSBmYWxzZTtcbiAgICB9KTtcblxuICAgICQocHJldmlldykuc2Nyb2xsKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCFsb2NrLmNoZWNrKHByZXZpZXcpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsb2NrLnVwZGF0ZShwcmV2aWV3KTtcbiAgICAgICAgY29uc29sZS5sb2coJ3ByZXZpZXcgc2Nyb2xsPz8/JylcblxuICAgICAgICAvLyDmib7lj7PkvqfnmoRvZmZzZXRcbiAgICAgICAgdmFyIG9mZnNldCA9IF90aGlzLmdldFByZXZpZXdTY3JvbGxPZmZzZXQoKTtcbiAgICAgICAgLy8g5qC55o2u5Y+z5L6nb2Zmc2V05om+5bem5L6n55qE5YGP56e7XG4gICAgICAgIGxvY2sudXBkYXRlKHByZXZpZXcpO1xuICAgICAgICBpbnB1dEFyZWEuc2Nyb2xsVG9wID0gX3RoaXMuZ2V0SW5wdXRUYXJnZXRUb3Aob2Zmc2V0KTtcbiAgICB9KTtcbn1cblxuRm9ya01ERS5wcm90b3R5cGUuZmlsbEFjdGlvbnMgPSBmdW5jdGlvbihhY3Rpb25zQmFyLCBvcHRBY3Rpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhY3Rpb25zID0gW107XG4gICAgYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgaXRlbTogJzxpIGNsYXNzPVwiZmEgZmEtYm9sZFwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHRpdGxlPVwi57KX5L2TXCI+PC9pPicsIFxuICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkgeyBzZWxmLnRleHRhcmVhLnJvdW5kKFwiKipcIiwgXCIqKlwiKTsgfVxuICAgIH0pO1xuXG4gICAgYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgaXRlbTogJzxpIGNsYXNzPVwiZmEgZmEtaXRhbGljXCIgdGl0bGU9XCLmlpzkvZNcIj48L2k+JywgXG4gICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7IHNlbGYudGV4dGFyZWEucm91bmQoXCIqXCIsIFwiKlwiKTsgfVxuICAgIH0pO1xuXG4gICAgYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgaXRlbTogJzxpIGNsYXNzPVwiZmEgZmEtc3RyaWtldGhyb3VnaFwiIHRpdGxlPVwi5Yig6Zmk57q/XCI+PC9pPicsIFxuICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkgeyBzZWxmLnRleHRhcmVhLnJvdW5kKFwifn5cIiwgXCJ+flwiKTsgfVxuICAgIH0pO1xuXG4gICAgYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgaXRlbTogJzxpIGNsYXNzPVwiZmEgZmEtdW5kZXJsaW5lXCIgdGl0bGU9XCLkuIvliJLnur9cIj48L2k+JywgXG4gICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7IHNlbGYudGV4dGFyZWEucm91bmQoXCIrK1wiLCBcIisrXCIpOyB9XG4gICAgfSk7XG5cbiAgICBhY3Rpb25zLnB1c2goe1xuICAgICAgICBpdGVtOiAnPGkgY2xhc3M9XCJtYXRlcmlhbC1pY29uc1wiIHRpdGxlPVwi6auY5LquXCI+aGlnaGxpZ2h0PC9pPicsIFxuICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkgeyBzZWxmLnRleHRhcmVhLnJvdW5kKFwiPT1cIiwgXCI9PVwiKTsgfVxuICAgIH0pO1xuXG4gICAgYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgaXRlbTogJzxpIGNsYXNzPVwiZmEgZmEtcXVvdGUtcmlnaHRcIiB0aXRsZT1cIuW8leeUqFwiPjwvaT4nLCBcbiAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHsgc2VsZi50ZXh0YXJlYS5pbnNlcnRMaW5lU3RhcnQoXCI+XCIpOyB9XG4gICAgfSk7XG5cbiAgICBhY3Rpb25zLnB1c2goe1xuICAgICAgICBpdGVtOiAnPGkgY2xhc3M9XCJmYSBmYS1jb2RlXCIgdGl0bGU9XCLooYzlhoXku6PnoIFcIj48L2k+JywgXG4gICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7IHNlbGYudGV4dGFyZWEucm91bmQoXCJgXCIsIFwiYFwiKTsgfVxuICAgIH0pO1xuXG4gICAgYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgaXRlbTogJzxpIGNsYXNzPVwiZmEgZmEtZmlsZS1jb2RlLW9cIiB0aXRsZT1cIuS7o+eggeWdl1wiPjwvaT4nLCBcbiAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHsgc2VsZi50ZXh0YXJlYS5pbnNlcnRMaW5lU3RhcnQoXCIgICAgXCIpOyB9XG4gICAgfSk7XG5cbiAgICBhY3Rpb25zLnB1c2goe1xuICAgICAgICBpdGVtOiAnPGkgY2xhc3M9XCJmYSBmYS10YWJsZVwiIHRpdGxlPVwi6KGo5qC8XCI+PC9pPicsIFxuICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkgeyBzZWxmLnRleHRhcmVhLnJvdW5kKFwiXFxuaGVhZGVyIDEgfCBoZWFkZXIgMlxcbi0tLXwtLS1cXG5yb3cgMSBjb2wgMSB8IHJvdyAxIGNvbCAyXFxucm93IDIgY29sIDEgfCByb3cgMiBjb2wgMlxcblxcblwiLCBcIlwiKTsgfVxuICAgIH0pO1xuXG4gICAgYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgaXRlbTogJzxzcGFuIHRpdGxlPVwi5LuF6aaW5a2X5q+N5aSn5YaZXCI+QWE8L3NwYW4+JywgXG4gICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7IHNlbGYudGV4dGFyZWEuY2hhbmdlQ2FzZSgzKTsgfVxuICAgIH0pO1xuXG4gICAgYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgaXRlbTogJzxzcGFuIHRpdGxlPVwi6YCJ5Lit6YOo5YiG5YWo6YOo6L2s5Li65aSn5YaZXCI+QUE8L3NwYW4+JywgXG4gICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7IHNlbGYudGV4dGFyZWEuY2hhbmdlQ2FzZSgxKTsgfVxuICAgIH0pO1xuXG4gICAgYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgaXRlbTogJzxzcGFuIHRpdGxlPVwi6YCJ5Lit6YOo5YiG5YWo6YOo6L2s5Li65bCP5YaZXCI+YWE8L3NwYW4+JywgXG4gICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7IHNlbGYudGV4dGFyZWEuY2hhbmdlQ2FzZSgyKTsgfVxuICAgIH0pO1xuXG4gICAgYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgaXRlbTogJzxpIGNsYXNzPVwiZmEgZmEtcGhvdG9cIiB0aXRsZT1cIuaPkuWFpeWbvueJh1wiPjwvaT4nLCBcbiAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHsgc2VsZi50ZXh0YXJlYS5yb3VuZChcIiFbaW1hZ2VdKGh0dHBzOi8vZ2l0aHViLmNvbS9mbHVpZGljb24ucG5nKVwiKTsgfVxuICAgIH0pO1xuXG4gICAgYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgaXRlbTogJzxzcGFuIHRpdGxlPVwiaDFcIj5IMTwvc3Bhbj4nLCBcbiAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHsgc2VsZi50ZXh0YXJlYS5pbnNlcnRMaW5lU3RhcnQoXCIjIFwiKTsgfVxuICAgIH0pO1xuXG4gICAgYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgaXRlbTogJzxzcGFuIHRpdGxlPVwiaDJcIj5IMjwvc3Bhbj4nLCBcbiAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHsgc2VsZi50ZXh0YXJlYS5pbnNlcnRMaW5lU3RhcnQoXCIjIyBcIik7IH1cbiAgICB9KTtcblxuICAgIGFjdGlvbnMucHVzaCh7XG4gICAgICAgIGl0ZW06ICc8c3BhbiB0aXRsZT1cImgzXCI+SDM8L3NwYW4+JywgXG4gICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7IHNlbGYudGV4dGFyZWEuaW5zZXJ0TGluZVN0YXJ0KFwiIyMjIFwiKTsgfVxuICAgIH0pO1xuXG4gICAgYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgaXRlbTogJzxzcGFuIHRpdGxlPVwiaDRcIj5INDwvc3Bhbj4nLCBcbiAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHsgc2VsZi50ZXh0YXJlYS5pbnNlcnRMaW5lU3RhcnQoXCIjIyMjIFwiKTsgfVxuICAgIH0pO1xuXG4gICAgYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgaXRlbTogJzxzcGFuIHRpdGxlPVwiaDVcIj5INTwvc3Bhbj4nLCBcbiAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHsgc2VsZi50ZXh0YXJlYS5pbnNlcnRMaW5lU3RhcnQoXCIjIyMjIyBcIik7IH1cbiAgICB9KTtcblxuICAgIGFjdGlvbnMucHVzaCh7XG4gICAgICAgIGl0ZW06ICc8c3BhbiB0aXRsZT1cImg2XCI+SDY8L3NwYW4+JywgXG4gICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7IHNlbGYudGV4dGFyZWEuaW5zZXJ0TGluZVN0YXJ0KFwiIyMjIyMjIFwiKTsgfVxuICAgIH0pO1xuXG4gICAgYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgaXRlbTogJzxpIGNsYXNzPVwiZmEgZmEtbWludXNcIiB0aXRsZT1cIuaoque6v1wiPjwvaT4nLCBcbiAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHsgc2VsZi50ZXh0YXJlYS5yb3VuZChcIlxcbi0tLVxcblwiLCBcIlwiKTsgfVxuICAgIH0pO1xuXG4gICAgYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgaXRlbTogJzxpIGNsYXNzPVwiZmEgZmEtbGlua1wiIHRpdGxlPVwi6LaF6ZO+5o6lXCI+PC9pPicsIFxuICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkgeyBzZWxmLnRleHRhcmVhLnJvdW5kKCdbZXhhbXBsZV0oXCJodHRwOi8vZXhhbXBsZS5vcmdcIiknLCAnJyk7IH1cbiAgICB9KTtcblxuICAgIGFjdGlvbnMucHVzaCh7XG4gICAgICAgIGl0ZW06ICc8aSBjbGFzcz1cImZhIGZhLWxpc3QtdWxcIiB0aXRsZT1cIuaXoOW6j+WIl+ihqFwiPjwvaT4nLCBcbiAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHsgc2VsZi50ZXh0YXJlYS5pbnNlcnRMaXN0KGZhbHNlKTsgfVxuICAgIH0pO1xuXG4gICAgYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgaXRlbTogJzxpIGNsYXNzPVwiZmEgZmEtbGlzdC1vbFwiIHRpdGxlPVwi5pyJ5bqP5YiX6KGoXCI+PC9pPicsIFxuICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkgeyBzZWxmLnRleHRhcmVhLmluc2VydExpc3QodHJ1ZSk7IH1cbiAgICB9KTtcblxuICAgIGFjdGlvbnMucHVzaCh7XG4gICAgICAgIGl0ZW06ICc8aSBjbGFzcz1cImZhIGZhLXN1YnNjcmlwdFwiIHRpdGxlPVwi5pWw5a2m5YWs5byPXCI+PC9pPicsIFxuICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkgeyBzZWxmLnRleHRhcmVhLnJvdW5kKCdgYGBcXG5tYXRoXFxuYyA9IFxcXFxwbVxcXFxzcXJ0e2FeMiArIGJeMn1cXG5gYGBcXG4nKTsgfVxuICAgIH0pO1xuXG4gICAgYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgaXRlbTogJzxpIGNsYXNzPVwiZmEgZmEtbGluZS1jaGFydFwiIHRpdGxlPVwi5rWB56iL5Zu+XCI+PC9pPicsIFxuICAgICAgICAvLyBhY3Rpb246IGZ1bmN0aW9uKCkgeyBfdGhpcy5pbnNlcnQoJ2BgYFxcbmZsb3dDaGFydFxcbnN0PT5zdGFydDogU3RhcnQ6Pmh0dHA6Ly93d3cuZ29vZ2xlLmNvbVtibGFua11cXG5lPT5lbmQ6Pmh0dHA6Ly93d3cuZ29vZ2xlLmNvbVxcbm9wMT0+b3BlcmF0aW9uOiBNeSBPcGVyYXRpb25cXG5zdWIxPT5zdWJyb3V0aW5lOiBNeSBTdWJyb3V0aW5lXFxuY29uZD0+Y29uZGl0aW9uOiBZZXMgb3IgTm8/Oj5odHRwOi8vd3d3Lmdvb2dsZS5jb21cXG5pbz0+aW5wdXRvdXRwdXQ6IGNhdGNoIHNvbWV0aGluZy4uLlxcblxcbnN0LT5vcDEtPmNvbmRcXG5jb25kKHllcyktPmlvLT5lXFxuY29uZChubyktPnN1YjEocmlnaHQpLT5vcDFcXG5gYGBcXG4nLCAnJyk7IH1cbiAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHsgc2VsZi50ZXh0YXJlYS5yb3VuZCgnYGBgXFxuZ3JhcGggVEQ7XFxuICAgIEEtLT5CO1xcbiAgICBBLS0+QztcXG4gICAgQi0tPkQ7XFxuICAgIEMtLT5EO1xcbmBgYFxcbicpOyB9XG4gICAgfSk7XG5cbiAgICBhY3Rpb25zLnB1c2goe1xuICAgICAgICBpdGVtOiAnPGkgY2xhc3M9XCJmYSBmYS1leGNoYW5nZVwiIHRpdGxlPVwi5pe25bqP5Zu+XCI+PC9pPicsIFxuICAgICAgICAvLyBhY3Rpb246IGZ1bmN0aW9uKCkgeyBfdGhpcy5pbnNlcnQoJ2BgYFxcbmhhbmRzZXFcXG5BLT4+QzogSG93IGFyZSB5b3U/XFxuQi0+PkE6IEdyZWF0IVxcbmBgYFxcbicsICcnKTsgfVxuICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkgeyBzZWxmLnRleHRhcmVhLnJvdW5kKCdgYGBcXG5zZXF1ZW5jZURpYWdyYW1cXG4gICAgcGFydGljaXBhbnQgSm9oblxcbiAgICBwYXJ0aWNpcGFudCBBbGljZVxcbiAgICBBbGljZS0+PkpvaG46IEhlbGxvIEpvaG4sIGhvdyBhcmUgeW91P1xcbiAgICBKb2huLS0+PkFsaWNlOiBHcmVhdCFcXG5gYGBcXG4nLCAnJyk7IH1cbiAgICB9KTtcblxuICAgIGFjdGlvbnMucHVzaCh7XG4gICAgICAgIGl0ZW06ICc8aSBjbGFzcz1cImZhIGZhLWJhcnNcIiB0aXRsZT1cIueUmOeJueWbvlwiPjwvaT4nLCBcbiAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHsgc2VsZi50ZXh0YXJlYS5yb3VuZCgnYGBgXFxuZ2FudHRcXG4gICAgdGl0bGUgQSBHYW50dCBEaWFncmFtXFxuXFxuICAgIHNlY3Rpb24gU2VjdGlvblxcbiAgICBBIHRhc2sgICAgICAgICAgIDphMSwgMjAxNC0wMS0wMSwgMzBkXFxuIFxcXG4gICAgICAgIEFub3RoZXIgdGFzayAgICAgOmFmdGVyIGExICAsIDIwZFxcbiAgICBzZWN0aW9uIEFub3RoZXJcXG4gICAgVGFzayBpbiBzZWMgICAgICA6MjAxNC0wMS0xMiAgLCAxMmRcXG4gICAgYW50aGVyIHRhc2sgICAgICA6IDI0ZFxcbmBgYFxcbicsICcnKTsgfVxuICAgIH0pO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0QWN0aW9ucykpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgb3B0QWN0aW9ucy5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgICAgIGFjdGlvbnMucHVzaChvcHRBY3Rpb25zW2ldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFjdGlvbnMucHVzaCh7XG4gICAgICAgIGl0ZW06ICc8aSBjbGFzcz1cImZhIGZhLWRvd25sb2FkXCIgdGl0bGU9XCLkuIvovb1QREZcIj48L2k+JywgXG4gICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7IFxuICAgICAgICAgICAgLyokcHJpbnQgPSAkKCc8ZGl2IGNsYXNzPVwiZm9ya21kZS1vdXRlci1jb250ZW50XCI+PC9kaXY+Jyk7XG4gICAgICAgICAgICAkcHJpbnQuaHRtbCgkKF90aGlzLnByZXZpZXcpLmh0bWwoKSk7XG4gICAgICAgICAgICAkcHJpbnQuY3NzKCd3aWR0aCcsICcxMDAlJyk7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgbW9kZSA6ICdwb3B1cCcsIFxuICAgICAgICAgICAgICBwb3BDbG9zZSA6ICd0cnVlJywgXG4gICAgICAgICAgICAgIHBvcFdkOiAkKCdib2R5Jykud2lkdGgoKSowLjggKyAncHgnLFxuICAgICAgICAgICAgICBwb3BYOiAkKCdib2R5Jykud2lkdGgoKSowLjEgKyAncHgnLFxuICAgICAgICAgICAgICBwb3BZOiAnMTAwcHgnLCBcbiAgICAgICAgICAgICAgcmV0YWluQXR0cjogWydpZCcsICdjbGFzcycsICdzdHlsZSddLCBcbiAgICAgICAgICAgICAgZXh0cmFIZWFkOiAnPG1ldGEgY2hhcnNldD1cInV0Zi04XCIgLz4sPG1ldGEgaHR0cC1lcXVpdj1cIlgtVUEtQ29tcGF0aWJsZVwiIGNvbnRlbnQ9XCJJRT1lZGdlXCIvPidcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRwcmludC5wcmludEFyZWEob3B0aW9ucyk7ICovXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZvciAodmFyIGkgaW4gYWN0aW9ucykge1xuICAgICAgICBpZiAoIWFjdGlvbnNbaV0uaXRlbSB8fCAhYWN0aW9uc1tpXS5hY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIGl0ZW0udHlwZSA9ICdidXR0b24nO1xuICAgICAgICBpdGVtLnNldEF0dHJpYnV0ZSgnaWR4JywgaSk7XG4gICAgICAgIGl0ZW0uaW5uZXJIVE1MID0gYWN0aW9uc1tpXS5pdGVtO1xuICAgICAgICBpdGVtLm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGFjdGlvbnNbdGhpcy5nZXRBdHRyaWJ1dGUoJ2lkeCcpXS5hY3Rpb24oc2VsZik7XG4gICAgICAgIH1cbiAgICAgICAgYWN0aW9uc0Jhci5hcHBlbmRDaGlsZChpdGVtKTtcbiAgICB9XG59XG5cbkZvcmtNREUucHJvdG90eXBlLnNldFRleHQgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdGhpcy50ZXh0YXJlYS5zZXRDb250ZW50KHRleHQpO1xufVxuXG5Gb3JrTURFLnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dGFyZWEuZ2V0Q29udGVudCgpO1xufVxuXG4kLmZuLmZvcmttZGVFZGl0b3IgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBGb3JrTURFKCQodGhpcyksIG9wdGlvbnMpXG59XG5cbiQuZm4ucmVuZGVyTWFya2VkID0gZnVuY3Rpb24odGV4dCkge1xuICAgICQodGhpcykuaHRtbChtYXJrZWQodGV4dCkpO1xuICAgIG1lcm1haWQuaW5pdCh1bmRlZmluZWQsIFwiLm1lcm1haWRcIik7XG59XG5cbndpbmRvdy5Gb3JrTURFID0ge1xuICAgIHJlbmRlck1hcmtlZDogZnVuY3Rpb24oKSB7XG5cbiAgICB9LCBcbiAgICBpbml0RWRpdG9yOiBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgRm9ya01ERShlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9LCBcbiAgICBwYXJzZTogZnVuY3Rpb24odGV4dCkge1xuICAgICAgICByZXR1cm4gbWFya2VkKHRleHQpO1xuICAgIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9lbnRyeS5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * markdown的语法解析器，脱胎于https://github.com/chjj/marked\n * @author zhangfucheng zhfchdev@gmail.com\n */\n\n;(function() {\n\n/**\n * Block-Level Grammar\n */\nvar bgs = new Array(); // blockGrammars\nvar bgm = { // blockGrammarsMap\n    // 命名规范，regex用单下划线前缀，字符串用双下划线前缀\n    __tag: '(?!(?:'\n        + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'\n        + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'\n        + '|span|br|wbr|ins|del|img)\\\\b)\\\\w+(?!:/|[^\\\\w\\\\s@]*@)\\\\b',  \n    _bullet: /(?:[*+-]|\\d+\\.)/\n}; \nvar brenders = {}; // blockGrammars Renders\n\n// 参与匹配计算的模式定义\nbgm['newline'] = {\n    pattern: /^\\n+/, \n    test: function(src, lexer) {\n        var cap = this.pattern.exec(src);\n        if (!cap) return {match: false};\n        if (cap[0].length > 1) {\n            lexer.tokens.push({\n                type: 'space', \n                offset: lexer.raw.length - src.length, \n                length: cap[0].length\n            });\n        }\n        return {match: true, group: cap[0]};\n    }, \n    render: function(parser) {\n        return parser.renderer.empty();\n    }\n};\nbgs.push(bgm.newline);\nbrenders['space'] = bgm.newline.render;\n\nbgm['handseq'] = {\n    pattern: /^ *`{3}\\s*handseq\\s+([\\s\\S]+?)`{3}/, \n    test: function(src, lexer) {\n        var cap = this.pattern.exec(src);\n        if (!cap) return {match: false};\n        lexer.tokens.push({\n            type: 'handseq',\n            text: cap[1], \n            offset: lexer.raw.length - src.length, \n            length: cap[0].length\n          });\n        return {match: true, group: cap[0]};\n    }, \n    render: function(parser) {\n        var token = parser.token;\n        return parser.renderer.handseq(token.text);\n    }\n}\nbgs.push(bgm.handseq);\nbrenders['handseq'] = bgm.handseq.render;\n\nbgm['flowchart'] = {\n    pattern: /^ *`{3}\\s*flowchart\\s+([\\s\\S]+?)`{3}/, \n    test: function(src, lexer) {\n        var cap = this.pattern.exec(src);\n        if (!cap) return {match: false};\n        lexer.tokens.push({\n            type: 'flowchart',\n            text: cap[1], \n            offset: lexer.raw.length - src.length, \n            length: cap[0].length\n        });\n        return {match: true, group: cap[0]};\n    }, \n    render: function(parser) {\n        var token = parser.token;\n        return parser.renderer.flowchart(token.text);\n    }\n}\nbgs.push(bgm.flowchart);\nbrenders['flowchart'] = bgm.flowchart.render;\n\nbgm['katex'] = {\n    pattern: /^ *`{3}\\s*math\\s+([\\s\\S]+?)`{3}/, \n    test: function(src, lexer) {\n        var cap = this.pattern.exec(src);\n        if (!cap) return {match: false};\n        lexer.tokens.push({\n            type: 'katex',\n            text: cap[1], \n            offset: lexer.raw.length - src.length, \n            length: cap[0].length\n        });\n        return {match: true, group: cap[0]};\n    }, \n    render: function(parser) {\n        var token = parser.token;\n        return parser.renderer.katex(token.text);\n    }\n}\nbgs.push(bgm.katex);\nbrenders['katex'] = bgm.katex.render;\n\nbgm['mermaid'] = {\n    pattern: /^ *`{3}\\s*mermaid\\s+([\\s\\S]+?)`{3}/, \n    test: function(src, lexer) {\n        var cap = this.pattern.exec(src);\n        if (!cap) return {match: false};\n        lexer.tokens.push({\n            type: 'mermaid',\n            text: cap[1], \n            offset: lexer.raw.length - src.length, \n            length: cap[0].length\n        });\n        return {match: true, group: cap[0]};\n    }, \n    render: function(parser) {\n        var token = parser.token;\n        return parser.renderer.mermaid(token.text);\n    }\n}\nbgs.push(bgm.mermaid);\nbrenders['mermaid'] = bgm.mermaid.render;\n\n// extend feature, alert stype by bootcss\nbgm['bootalert'] = {\n    pattern: /^ *:{3}\\s*([^\\s]+)\\s*([\\s\\S]+?):{3}/, \n    test: function(src, lexer) {\n        var cap = this.pattern.exec(src);\n        if (!cap) return {match: false};\n        lexer.tokens.push({\n            type: 'bootalert',\n            style: cap[1],\n            text: cap[2], \n            offset: lexer.raw.length - src.length, \n            length: cap[0].length\n        });\n        return {match: true, group: cap[0]};\n    }, \n    render: function(parser) {\n        var token = parser.token;\n        return parser.renderer.bootalert(token.style, parser.inline.output(token.text));\n    }\n}\nbgs.push(bgm.bootalert);\nbrenders['bootalert'] = bgm.bootalert.render;\n\nbgm['code'] = {\n    pattern: /^( {4}[^\\n]+\\n*)+/, \n    test: function(src, lexer) {\n        var cap = this.pattern.exec(src);\n        if (!cap) return {match: false};\n        var cap0 = cap[0].replace(/^ {4}/gm, '');\n        lexer.tokens.push({\n            type: 'code',\n            text: lexer.options.pedantic ? cap0 : cap0.replace(/\\n+$/, ''), \n            offset: lexer.raw.length - src.length, \n            length: cap[0].length\n        });\n        return {match: true, group: cap[0]};\n    }, \n    render: function(parser) {\n        var token = parser.token;\n        return parser.renderer.code(token.text,\n                token.lang,\n                token.escaped);\n    }\n};\nbgs.push(bgm['code']);\nbrenders['code'] = bgm.code.render;\n\nbgm['fences'] = { // (gfm)\n    pattern: /^ *(`{3,}|~{3,})[ \\.]*(\\S+)? *\\n([\\s\\S]*?)\\s*\\1 *(?:\\n+|$)/, \n    test: function(src, lexer) {\n        if (!lexer.options.gfm) return {match: false};\n        var cap = this.pattern.exec(src);\n        if (!cap) return {match: false};\n        lexer.tokens.push({\n            type: 'code',\n            lang: cap[2],\n            text: cap[3] || '', \n            offset: lexer.raw.length - src.length, \n            length: cap[0].length\n        });\n        return {match: true, group: cap[0]};\n    }\n};\nbgs.push(bgm['fences']);\n\nbgm['heading'] = { // (gfm)\n    pattern: /^ *(#{1,6}) *([^\\n]+?) *#* *(?:\\n+|$)/, \n    gfm: /^ *(#{1,6}) +([^\\n]+?) *#* *(?:\\n+|$)/, \n    test: function(src, lexer) {\n        var p = (lexer.options.gfm) ? this.gfm : this.pattern;\n        var cap = p.exec(src);\n        if (!cap) return {match: false};\n        lexer.tokens.push({\n            type: 'heading',\n            depth: cap[1].length,\n            text: cap[2], \n            offset: lexer.raw.length - src.length, \n            length: cap[0].length\n        });\n        return {match: true, group: cap[0]};\n    }, \n    render: function(parser) {\n        var token = parser.token;\n        return parser.renderer.heading(\n                parser.inline.output(token.text),\n                token.depth,\n                token.text);\n    }\n};\nbgs.push(bgm.heading);\nbrenders['heading'] = bgm.heading.render;\n\nbgm['nptable'] = { // table no leading pipe (gfm)\n    pattern: /^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*/, \n    test: function(src, lexer, flag) {\n        if (!lexer.options.tables) return {match: false};\n        if (!flag.top) return {match: false}; // 如果不是从top level调用，不能生成表格\n        var cap = this.pattern.exec(src);\n        if (!cap) return {match: false};\n\n        var item = {\n            type: 'table',\n            header: cap[1].replace(/^ *| *\\| *$/g, '').split(/ *\\| */),\n            align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n            cells: cap[3].replace(/\\n$/, '').split('\\n'), \n            offset: lexer.raw.length - src.length, \n            length: cap[0].length\n        };\n\n        for (i = 0; i < item.align.length; i++) {\n            if (/^ *-+: *$/.test(item.align[i])) {\n                item.align[i] = 'right';\n            } else if (/^ *:-+: *$/.test(item.align[i])) {\n                item.align[i] = 'center';\n            } else if (/^ *:-+ *$/.test(item.align[i])) {\n                item.align[i] = 'left';\n            } else {\n                item.align[i] = null;\n            }\n        }\n\n        for (i = 0; i < item.cells.length; i++) {\n            item.cells[i] = item.cells[i].split(/ *\\| */);\n        }\n\n        lexer.tokens.push(item);\n        return {match: true, group: cap[0]};\n    }, \n    render: function(parser) {\n        var header = '', body = '';\n        var row, cell;\n        var token = parser.token;\n        var renderer = parser.renderer;\n\n        cell = '';\n        for (var i = 0; i < token.header.length; i++) {\n            cell += renderer.tablecell(\n                parser.inline.output(token.header[i]),\n                { header: true, align: token.align[i] }\n            );\n        }\n        header += renderer.tablerow(cell);\n\n        for (var i = 0; i < token.cells.length; i++) {\n            row = token.cells[i];\n            cell = '';\n            for (var j = 0; j < row.length; j++) {\n                cell += renderer.tablecell(\n                    parser.inline.output(row[j]),\n                    { header: false, align: token.align[j] }\n                );\n            }\n            body += renderer.tablerow(cell);\n        }\n        return renderer.table(header, body);\n    }\n};\nbgs.push(bgm.nptable);\nbrenders['table'] = bgm.nptable.render;\n\nbgm['lheading'] = {\n    pattern: /^([^\\n]+)\\n *(=|-){2,} *(?:\\n+|$)/, \n    test: function(src, lexer) {\n        var cap = this.pattern.exec(src);\n        if (!cap) return {match: false};\n        lexer.tokens.push({\n            type: 'heading',\n            depth: cap[2] === '=' ? 1 : 2,\n            text: cap[1], \n            offset: lexer.raw.length - src.length, \n            length: cap[0].length\n        });\n        return {match: true, group: cap[0]};\n    }\n};\nbgs.push(bgm['lheading']); // render和heading相同\n\nbgm['hr'] = {\n    pattern: /^( *[-*_]){3,} *(?:\\n+|$)/, \n    test: function(src, lexer) {\n        var cap = this.pattern.exec(src);\n        if (!cap) return {match: false};\n        lexer.tokens.push({\n            type: 'hr', \n            offset: lexer.raw.length - src.length, \n            length: cap[0].length\n        });\n        return {match: true, group: cap[0]};\n    }, \n    render: function( parser) {\n        return parser.renderer.hr();\n    }\n};\nbgs.push(bgm.hr);\nbrenders['hr'] = bgm.hr.render;\n\nbgm['blockquote'] = {\n    pattern: /^( *>[^\\n]+(\\n(?!def)[^\\n]+)*\\n*)+/, \n    test: function(src, lexer, flag) {\n        var cap = this.pattern.exec(src);\n        if (!cap) return {match: false};\n        lexer.tokens.push({\n            type: 'blockquote_start', \n            offset: lexer.raw.length - src.length, \n            length: cap[0].length\n        });\n\n        var cap0 = cap[0].replace(/^ *> ?/gm, '');\n        // Pass `top` to keep the current \"toplevel\" state. This is exactly\n        // how markdown.pl works.\n        lexer.token(cap0, flag.top, true);\n\n        lexer.tokens.push({\n            type: 'blockquote_end', \n            offset: lexer.raw.length - src.length - cap[0].length, \n            length: 0\n        });\n        return {match: true, group: cap[0]};\n    }, \n    render: function(parser) {\n        var token = parser.token;\n        if (token.type == 'blockquote_end') {\n            return;\n        }\n        var body = '';\n        while (parser.next().type !== 'blockquote_end') {\n            body += parser.tok();\n        }\n        return parser.renderer.blockquote(body);\n    }\n};\nbgs.push(bgm.blockquote);\nbrenders['blockquote_start'] = bgm.blockquote.render;\nbrenders['blockquote_end'] = bgm.blockquote.render;\n\nbgm['list'] = {\n    pattern: /^( *)(bull) [\\s\\S]+?(?:hr|def|\\n{2,}(?! )(?!\\1bull )\\n*|\\s*$)/, \n    item: /^( *)(bull) [^\\n]*(?:\\n(?!\\1bull )[^\\n]*)*/, \n    test: function(src, lexer, flag) {\n        var cap = this.pattern.exec(src);\n        if (!cap) return {match: false};\n        bull = cap[2];\n\n        lexer.tokens.push({\n            type: 'list_start', \n            ordered: bull.length > 1, \n            offset: lexer.raw.length - src.length, \n            length: cap[0].length\n        });\n\n        // Get each top-level item.\n        var cap0 = cap[0].match(this.item);\n\n        var next = false;\n        var total = 0;\n        for (var i = 0 ; i < cap0.length; i++) {\n            item = cap0[i];\n\n            // Remove the list item's bullet\n            // so it is seen as the next token.\n            var space = item.length;\n            item = item.replace(/^ *([*+-]|\\d+\\.) +/, '');\n\n            // Outdent whatever the\n            // list item contains. Hacky.\n            if (~item.indexOf('\\n ')) {\n                space -= item.length;\n                item = !lexer.options.pedantic\n                    ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')\n                    : item.replace(/^ {1,4}/gm, '');\n            }\n\n            // Determine whether the next list item belongs here.\n            // Backpedal if it does not belong in this list.\n            if (lexer.options.smartLists && i !== cap0.length - 1) {\n                b = bgm._bullet.exec(cap0[i + 1])[0];\n                if (bull !== b && !(bull.length > 1 && b.length > 1)) {\n                    src = cap0.slice(i + 1).join('\\n') + src;\n                    i = cap0.length - 1;\n                }\n            }\n\n            // Determine whether item is loose or not.\n            // Use: /(^|\\n)(?! )[^\\n]+\\n\\n(?!\\s*$)/\n            // for discount behavior.\n            loose = next || /\\n\\n(?!\\s*$)/.test(item);\n            if (i !== cap0.length - 1) {\n                next = item.charAt(item.length - 1) === '\\n';\n                if (!loose) loose = next;\n            }\n\n            lexer.tokens.push({\n                type: loose ? 'loose_item_start' : 'list_item_start', \n                offset: lexer.raw.length - src.length + total, \n                length: item.length\n            });\n\n            // Recurse.\n            lexer.token(item, false, flag.bq);\n\n            lexer.tokens.push({\n                type: 'list_item_end', \n                offset: lexer.raw.length - src.length + total + item.length, \n                length: 0\n            });\n            total += item.length;\n        }\n\n        lexer.tokens.push({\n            type: 'list_end', \n            offset: lexer.raw.length - src.length - cap[0].length, \n            length: 0\n        });\n        return {match: true, group: cap[0]};\n    }, \n    render: function(parser) {\n        var tokenType = parser.token.type;\n        switch(tokenType) {\n            case 'list_start': {\n                var ordered = parser.token.ordered;\n                var body = '';\n                while (parser.next().type !== 'list_end') {\n                    body += parser.tok();\n                }\n                return parser.renderer.list(body, ordered);\n            }\n            case 'list_item_start': {\n                var body = '';\n                while (parser.next().type !== 'list_item_end') {\n                    body += parser.token.type === 'text'\n                        ? parser.parseText()\n                        : parser.tok();\n                }\n                return parser.renderer.listitem(body);\n            }\n            case 'loose_item_start': {\n                var body = '';\n                while (parser.next().type !== 'list_item_end') {\n                    body += parser.tok();\n                }\n                return parser.renderer.listitem(body);\n            }\n        }\n    }\n};\nbgs.push(bgm.list);\nbrenders['list_start'] = bgm.list.render;\nbrenders['list_end'] = bgm.list.render;\nbrenders['list_item_start'] = bgm.list.render;\nbrenders['list_item_end'] = bgm.list.render;\nbrenders['loose_item_start'] = bgm.list.render;\n\nbgm['html'] = {\n    pattern: /^ *(?:comment *(?:\\n|\\s*$)|closed *(?:\\n{2,}|\\s*$)|closing *(?:\\n{2,}|\\s*$))/, \n    test: function(src, lexer) {\n        var cap = this.pattern.exec(src);\n        if (!cap) return {match: false};\n        lexer.tokens.push({\n            type: lexer.options.sanitize ? 'paragraph' : 'html',\n            pre: !lexer.options.sanitizer && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\n            text: cap[0], \n            offset: lexer.raw.length - src.length, \n            length: cap[0].length\n        });\n        return {match: true, group: cap[0]};\n    }, \n    render: function(parser) {\n        var html = !parser.token.pre && !parser.options.pedantic\n                ? parser.inline.output(parser.token.text)\n                : parser.token.text;\n        return parser.renderer.html(html);\n    }\n};\nbgs.push(bgm.html);\nbrenders['html'] = bgm.html.render;\n\nbgm['def'] = {\n    pattern: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +[\"(]([^\\n]+)[\")])? *(?:\\n+|$)/, \n    test: function(src, lexer, flag) {\n        var bq = flag.bq;\n        var top = flag.top;\n        if (bq || !top) return {match: false};\n        var cap = this.pattern.exec(src);\n        if (!cap) return {match: false};\n        lexer.tokens.links[cap[1].toLowerCase()] = {\n            href: cap[2],\n            title: cap[3], \n            offset: lexer.raw.length - src.length, \n            length: cap[0].length\n        };\n        return {match: true, group: cap[0]};\n    }\n};\nbgs.push(bgm.def);\n\nbgm['table'] = { // table (gfm)\n    pattern: /^ *\\|(.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*/, \n    test: function(src, lexer, flag) {\n        var tables = lexer.options.tables;\n        var top = flag.top;\n        if (!tables) return {match: false};\n        if (!top) return {match: false}; // 如果不是从top level调用，不能生成表格\n        var cap = this.pattern.exec(src);\n        if (!cap) return {match: false};\n\n\n        item = {\n            type: 'table',\n            header: cap[1].replace(/^ *| *\\| *$/g, '').split(/ *\\| */),\n            align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n            cells: cap[3].replace(/(?: *\\| *)?\\n$/, '').split('\\n'), \n            offset: lexer.raw.length - src.length, \n            length: cap[0].length\n        };\n\n        for (i = 0; i < item.align.length; i++) {\n            if (/^ *-+: *$/.test(item.align[i])) {\n                item.align[i] = 'right';\n            } else if (/^ *:-+: *$/.test(item.align[i])) {\n                item.align[i] = 'center';\n            } else if (/^ *:-+ *$/.test(item.align[i])) {\n                item.align[i] = 'left';\n            } else {\n                item.align[i] = null;\n            }\n        }\n\n        for (i = 0; i < item.cells.length; i++) {\n            item.cells[i] = item.cells[i]\n                .replace(/^ *\\| *| *\\| *$/g, '')\n                .split(/ *\\| */);\n        }\n\n        lexer.tokens.push(item);\n        return {match: true, group: cap[0]};\n    }\n};\nbgs.push(bgm.table); // render和nptable是一样的\n\nbgm['paragraph'] = { // top-level paragraph\n    pattern: /^((?:[^\\n]+\\n?(?!hr|heading|lheading|blockquote|tag|def))+)\\n*/, \n    gfm: /^/, \n    test: function(src, lexer, flag) {\n        if (!flag.top) return {match: false};\n        var p = (lexer.options.gfm) ? this.gfm : this.pattern;\n        var cap = p.exec(src);\n        if (!cap) return {match: false};\n        lexer.tokens.push({\n            type: 'paragraph',\n            text: cap[1].charAt(cap[1].length - 1) === '\\n'\n                ? cap[1].slice(0, -1)\n                : cap[1], \n            offset: lexer.raw.length - src.length, \n            length: cap[0].length\n        });\n        return {match: true, group: cap[0]};\n    }, \n    render: function(parser) {\n        return parser.renderer.paragraph(parser.inline.output(parser.token.text));\n    }\n};\nbgs.push(bgm.paragraph);\nbrenders['paragraph'] = bgm.paragraph.render;\n\nbgm['text'] = {\n    pattern: /^[^\\n]+/, \n    test: function(src, lexer) {\n        // Top-level should never reach here.\n        var cap = this.pattern.exec(src);\n        if (!cap) return {match: false};\n        lexer.tokens.push({\n            type: 'text',\n            text: cap[0], \n            offset: lexer.raw.length - src.length, \n            length: cap[0].length\n        });\n        return {match: true, group: cap[0]};\n    }, \n    render: function(parser) {\n        return parser.renderer.paragraph(parser.parseText());\n    }\n};\nbgs.push(bgm.text);\nbrenders['text'] = bgm.text.render;\n\n\nbgm.blockquote.pattern = replace(bgm.blockquote.pattern)\n    ('def', bgm.def.pattern)\n    ();\nbgm.list.pattern = replace(bgm.list.pattern)\n    (/bull/g, bgm._bullet)\n    ('hr', '\\\\n+(?=\\\\1?(?:[-*_] *){3,}(?:\\\\n+|$))')\n    ('def', '\\\\n+(?=' + bgm.def.pattern.source + ')')\n    ();\nbgm.list.item = replace(bgm.list.item, 'gm')\n    (/bull/g, bgm._bullet)\n    ();\nbgm.html.pattern = replace(bgm.html.pattern)\n    ('comment', /<!--[\\s\\S]*?-->/)\n    ('closed', /<(tag)[\\s\\S]+?<\\/\\1>/)\n    ('closing', /<tag(?:\"[^\"]*\"|'[^']*'|[^'\">])*?>/)\n    (/tag/g, bgm.__tag)\n    ();\nbgm.paragraph.pattern = replace(bgm.paragraph.pattern)\n    ('hr', bgm.hr.pattern)\n    ('heading', bgm.heading.pattern)\n    ('lheading', bgm.lheading.pattern)\n    ('blockquote', bgm.blockquote.pattern)\n    ('tag', '<' + bgm.__tag)\n    ('def', bgm.def.pattern)\n    ();\nbgm.paragraph.gfm = replace(bgm.paragraph.pattern)\n    ('(?!', '(?!'\n    + bgm.fences.pattern.source.replace('\\\\1', '\\\\2') + '|'\n    + bgm.list.pattern.source.replace('\\\\1', '\\\\3') + '|')\n    ();\n\n\n/**\n * Block Lexer\n */\nfunction Lexer(options) {\n    this.tokens = [];\n    this.tokens.links = {};\n    this.options = options || marked.defaults;\n    this.raw = '';\n}\n\n/**\n * Static Lex Method\n */\nLexer.lex = function(src, options) {\n    var lexer = new Lexer(options);\n    lexer.raw = src;\n    return lexer.lex(src);\n};\n\n/**\n * Preprocessing\n */\nLexer.prototype.lex = function(src) {\n    src = src\n        .replace(/\\r\\n|\\r/g, '\\n')\n        .replace(/\\t/g, '    ')\n        .replace(/\\u00a0/g, ' ')\n        .replace(/\\u2424/g, '\\n');\n\n  return this.token(src, true);\n};\n\n/**\n * Lexing\n */\nLexer.prototype.token = function(src, top, bq) {\n    var src = src.replace(/^ +$/gm, '');\n\n    var flag = {\n        top: top, \n        bq: bq\n    }\n\n    while (src) {\n        var loop = false;\n        for (var i = 0 ; i < bgs.length ; i++) {\n            var blockGrammar = bgs[i];\n            var entry = blockGrammar.test(src, this, flag);\n            if (entry.match) {\n                loop = true;\n                src = src.substring(entry.group.length);\n                break;\n            }\n        }\n        if (loop) {\n            continue;\n        }\n        if (src) {\n            throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));\n        }\n    }\n    return this.tokens;\n};\n\n/**\n * Inline-Level Grammar\n */\nvar igs = new Array(); // InlineGrammars\nvar igm = { // InlineGrammarsMap\n    _inside: /(?:\\[[^\\]]*\\]|[^\\[\\]]|\\](?=[^\\[]*\\]))*/,\n    _href: /\\s*<?([\\s\\S]*?)>?(?:\\s+['\"]([\\s\\S]*?)['\"])?\\s*/\n};\n\nigm['escape'] = {  // 取消转义\n    pattern: /^\\\\([\\\\`*{}\\[\\]()#+\\-.!_<>])/, \n    gfm: /^/,\n    test: function(src, lexer) {\n        var opts = lexer.options;\n        var p = opts.gfm ? this.gfm : this.pattern;\n        var cap = p.exec(src);\n        if (!cap) return {match: false};\n        return {match: true, group: cap[0], out: escape(cap[1])};\n    }\n};\nigs.push(igm['escape']);\n\nigm['katex'] = {\n    pattern: /^`\\$([^\\$]+)\\$`/, \n    test: function(src, lexer) {\n        var cap = this.pattern.exec(src);\n        if (!cap) return {match: false};\n        var out = lexer.renderer.katex(cap[1]);\n        return {match: true, group: cap[0], out: out};\n    }\n};\nigs.push(igm['katex']);\n\nigm['autolink'] = {\n    pattern: /^<([^ >]+(@|:\\/)[^ >]+)>/, \n    test: function(src, lexer) {\n        var opts = lexer.options;\n        var localMangle = opts.mangle ? mangle : function(text) {return text;}\n        var cap = this.pattern.exec(src);\n        if (!cap) return {match: false};\n        if (cap[2] === '@') {\n            text = cap[1].charAt(6) === ':'\n                ? localMangle(cap[1].substring(7))\n                : localMangle(cap[1]);\n            href = localMangle('mailto:') + text;\n        } else {\n            text = escape(cap[1]);\n            href = text;\n        }\n        var out = lexer.renderer.link(href, null, text, opts);\n        return {match: true, group: cap[0], out: out};\n    }\n};\nigs.push(igm['autolink']);\n\nigm['url'] = { // gfm\n    pattern: /^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/, \n    test: function(src, lexer) {\n        var opts = lexer.options;\n        if (lexer.inlink || !opts.gfm) return {match: false};\n        var cap = this.pattern.exec(src);\n        if (!cap) return {match: false};\n        var text = escape(cap[1]);\n        var href = text;\n        var out = lexer.renderer.link(href, null, text, opts);\n        return {match: true, group: cap[0], out: out};\n    }\n};\nigs.push(igm['url']);\n\nigm['tag'] = {\n    pattern: /^<!--[\\s\\S]*?-->|^<\\/?\\w+(?:\"[^\"]*\"|'[^']*'|[^'\">])*?>/, \n    test: function(src, lexer) {\n        var opts = lexer.options;\n        var cap = this.pattern.exec(src);\n        if (!cap) return {match: false};\n        if (!lexer.inlink && /^<a /i.test(cap[0])) {\n            lexer.inlink = true;\n        } else if (lexer.inlink && /^<\\/a>/i.test(cap[0])) {\n            lexer.inlink = false;\n        }\n        out = opts.sanitize \n                ? opts.sanitizer\n                    ? opts.sanitizer(cap[0])\n                    : escape(cap[0])\n                : cap[0];\n        return {match: true, group: cap[0], out: out};\n    }\n};\nigs.push(igm['tag']);\n\nigm['link'] = {\n    pattern: /^!?\\[(inside)\\]\\(href\\)/, \n    test: function(src, lexer) {\n        var cap = this.pattern.exec(src);\n        if (!cap) return {match: false};\n        lexer.inlink = true;\n        out = lexer.outputLink(cap, {\n            href: cap[2],\n            title: cap[3]\n        });\n        lexer.inlink = false;\n        return {match: true, group: cap[0], out: out};\n    }\n};\nigs.push(igm['link']);\n\nigm['reflink'] = { // reflink, nolink\n    ref: /^!?\\[(inside)\\]\\s*\\[([^\\]]*)\\]/, \n    no: /^!?\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]/, \n    test: function(src, lexer) {\n        var cap = this.ref.exec(src);\n        if (!cap) {\n            cap = this.no.exec(src);\n        }\n        if (!cap) return {match: false};\n        var link = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n        var link = lexer.links[link.toLowerCase()];\n        if (!link || !link.href) {\n            var out = cap[0].charAt(0);\n            return {match: true, group: cap[0].charAt(0), out: out};\n        }\n        lexer.inlink = true;\n        var out = lexer.outputLink(cap, link);\n        lexer.inlink = false;\n        return {match: true, group: cap[0], out: out};\n    }\n};\nigs.push(igm['reflink']);\n\nigm['strong'] = {\n    pattern: /^__([\\s\\S]+?)__(?!_)|^\\*\\*([\\s\\S]+?)\\*\\*(?!\\*)/, \n    pedantic: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/, \n    test: function(src, lexer) {\n        var p = lexer.options.pedantic ? this.pedantic : this.pattern;\n        var cap = p.exec(src);\n        if (!cap) return {match: false};\n        var out = lexer.renderer.strong(lexer.output(cap[2] || cap[1]));\n        return {match: true, group: cap[0], out: out};\n    }\n};\nigs.push(igm['strong']);\n\nigm['mark'] = {\n    pattern: /^==([\\s\\S]+?)==(?!=)/, \n    test: function(src, lexer) {\n        var cap = this.pattern.exec(src);\n        if (!cap) return {match: false};\n        var out = lexer.renderer.mark(lexer.output(cap[1]));\n        return {match: true, group: cap[0], out: out};\n    }\n};\nigs.push(igm['mark']);\n\nigm['underline'] = {\n    pattern: /^\\+\\+([\\s\\S]+?)\\+\\+(?!\\+)/, \n    test: function(src, lexer) {\n        var cap = this.pattern.exec(src);\n        if (!cap) return {match: false};\n        var out = lexer.renderer.underline(lexer.output(cap[1]));\n        return {match: true, group: cap[0], out: out};\n    }\n};\nigs.push(igm['underline']);\n\nigm['emoji'] = {\n    pattern: /^:([\\S]+?):(?!:)/, \n    test: function(src, lexer) {\n        var cap = this.pattern.exec(src);\n        if (!cap) return {match: false};\n        var out = lexer.renderer.emoji(cap[0]);\n        return {match: true, group: cap[0], out: out};\n    }\n};\nigs.push(igm['emoji']);\n\nigm['em'] = {\n    pattern: /^\\b_((?:[^_]|__)+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, \n    pedantic: /^_(?=\\S)([\\s\\S]*?\\S)_(?!_)|^\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)/, \n    test: function(src, lexer) {\n        var p = lexer.options.pedantic ? this.pedantic : this.pattern;\n        var cap = p.exec(src);\n        if (!cap) return {match: false};\n        var out = lexer.renderer.em(lexer.output(cap[2] || cap[1]));\n        return {match: true, group: cap[0], out: out};\n    }\n};\nigs.push(igm['em']);\n\nigm['code'] = {\n    pattern: /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/, \n    test: function(src, lexer) {\n        var cap = this.pattern.exec(src);\n        if (!cap) return {match: false};\n        var out = lexer.renderer.codespan(escape(cap[2], true));\n        return {match: true, group: cap[0], out: out};\n    }\n};\nigs.push(igm['code']);\n\nigm['br'] = {\n    pattern: /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/, \n    breaks: /^/, \n    test: function(src, lexer) {\n        var p = lexer.options.breaks ? this.breaks : this.pattern;\n        var cap = p.exec(src);\n        if (!cap) return {match: false};\n        var out = lexer.renderer.br(lexer.options);\n        return {match: true, group: cap[0], out: out};\n    }\n};\nigs.push(igm['br']);\n\nigm['del'] = {\n    gfm: /^~~(?=\\S)([\\s\\S]*?\\S)~~/, \n    test: function(src, lexer) {\n        var cap = this.gfm.exec(src);\n        if (!cap) return {match: false};\n        var out = lexer.renderer.del(lexer.output(cap[1]));\n        return {match: true, group: cap[0], out: out};\n    }\n};\nigs.push(igm['del']);\n\nigm['text'] = {\n    pattern: /^[\\s\\S]+?(?=[\\\\:<!\\~=[_*`]| {2,}\\n|$)/, \n    gfm: /^/,\n    breaks: /^/, \n    test: function(src, lexer) {\n        var p = lexer.options.breaks ? this.breaks : this.pattern;\n        var cap = p.exec(src);\n        if (!cap) return {match: false};\n        var out = lexer.renderer.text(escape(lexer.smartypants(cap[0])));\n        return {match: true, group: cap[0], out: out};\n    }\n};\nigs.push(igm['text']);\n\nigm.escape.gfm = replace(igm.escape.pattern)\n    ('])', '~|])')\n    ();\nigm.link.pattern = replace(igm.link.pattern)\n    ('inside', igm._inside)\n    ('href', igm._href)\n    ();\nigm.reflink.ref = replace(igm.reflink.ref)\n    ('inside', igm._inside)\n    ();\nigm.br.breaks = replace(igm.br.pattern)\n    ('{2,}', '*')\n    ();\nigm.text.gfm = replace(igm.text.pattern)\n    (']|', '~]|')\n    ('|', '|https?://|')\n    ();\nigm.text.breaks = replace(igm.text.gfm)\n    ('{2,}', '*')\n    ();\n\n\n/**\n * Inline Lexer & Compiler\n */\nfunction InlineLexer(links, options) {\n    this.options = options || marked.defaults;\n    this.links = links;\n    this.renderer = this.options.renderer || new Renderer;\n\n    if (!this.links) {\n        throw new Error('Tokens array requires a `links` property.');\n    }\n}\n\n/**\n * Static Lexing/Compiling Method\n */\nInlineLexer.output = function(src, links, options) {\n    var inline = new InlineLexer(links, options);\n    return inline.output(src);\n};\n\n/**\n * Lexing/Compiling\n */\nInlineLexer.prototype.output = function(src) {\n    var out = '';\n\n    while (src) {\n        var loop = false;\n        for (var i = 0 ; i < igs.length ; i++) {\n            var inlineGrammar = igs[i];\n            var entry = inlineGrammar.test(src, this);\n            if (entry.out) {\n                out += entry.out;\n            }\n            if (entry.match) {\n                loop = true;\n                src = src.substring(entry.group.length);\n                break;\n            }\n        }\n        if (loop) {\n            continue;\n        }\n\n        if (src) {\n            throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));\n        }\n    }\n    return out;\n};\n\n/**\n * Compile Link\n */\n\nInlineLexer.prototype.outputLink = function(cap, link) {\n    var href = escape(link.href)\n        , title = link.title ? escape(link.title) : null;\n\n    return cap[0].charAt(0) !== '!'\n        ? this.renderer.link(href, title, this.output(cap[1]), this.options)\n        : this.renderer.image(href, title, escape(cap[1]));\n};\n\n/**\n * Smartypants Transformations\n */\n\nInlineLexer.prototype.smartypants = function(text) {\n    if (!this.options.smartypants) return text;\n    return text\n        // em-dashes\n        .replace(/---/g, '\\u2014')\n        // en-dashes\n        .replace(/--/g, '\\u2013')\n        // opening singles\n        .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, '$1\\u2018')\n        // closing singles & apostrophes\n        .replace(/'/g, '\\u2019')\n        // opening doubles\n        .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, '$1\\u201c')\n        // closing doubles\n        .replace(/\"/g, '\\u201d')\n        // ellipses\n        .replace(/\\.{3}/g, '\\u2026');\n};\n\n/**\n * Renderer\n */\nfunction Renderer(options) {\n    this.options = options || {};\n}\n\nRenderer.prototype.empty = function() {\n    return '';\n}\n\nRenderer.prototype.code = function(code, lang, escaped) {\n    if (this.options.highlight) {\n        var out = opts.highlight(code, lang);\n        if (out != null && out !== code) {\n            escaped = true;\n            code = out;\n        }\n    }\n\n    code = (escaped ? code : escape(code, true));\n    if (!lang) {\n        return `<pre><code>${code}\\n</code></pre>`;\n    }\n\n    var classPrefix = this.options.langPrefix;\n    return stringformat('<pre><code class=\"{}{}\">{}\\n</code></pre>\\n', classPrefix, escape(lang, true), code);\n};\n\nRenderer.prototype.blockquote = function(quote) {\n    return stringformat('<blockquote>\\n{}</blockquote>\\n', quote);\n};\n\nRenderer.prototype.html = function(html) {\n    return html;\n};\n\nRenderer.prototype.heading = function(text, level, raw) {\n    // var headerPrefix = this.options.headerPrefix;\n    // return stringformat('<h{} id=\"{}{}\">{}</h{}>\\n', level, headerPrefix, raw.toLowerCase().replace(/[^\\w]+/g, '-'), text, level);\n    return stringformat('<h{}>{}</h{}>\\n', level, text, level);\n};\n\nRenderer.prototype.hr = function() {\n    return this.options.xhtml ? '<hr/>\\n' : '<hr>\\n';\n};\n\nRenderer.prototype.list = function(body, ordered) {\n    var type = ordered ? 'ol' : 'ul';\n    return stringformat('<{}>\\n{}</{}>\\n', type, body, type);\n};\n\nRenderer.prototype.listitem = function(text) {\n    return stringformat('<li>{}</li>\\n', text);\n};\n\nRenderer.prototype.paragraph = function(text) {\n    return stringformat('<p>{}</p>\\n', text);\n};\n\nRenderer.prototype.table = function(header, body) {\n    return stringformat('<table>\\n<thead>\\n{}\\n</thead>\\n<tbody>\\n{}\\n</tbody>\\n</table>\\n', header, body);\n};\n\nRenderer.prototype.tablerow = function(content) {\n    return stringformat('<tr>\\n{}</tr>\\n', content);\n};\n\nRenderer.prototype.tablecell = function(content, flags) {\n    var type = flags.header ? 'th' : 'td';\n    var tagStart = flags.align\n        ? stringformat('<{} style=\"text-align:{}\">', type, flags.align)\n        : stringformat('<{}>', type);\n    var tagEnd = stringformat('</{}>\\n', type);\n    return tagStart + content + tagEnd;\n};\n\n// span level renderer\nRenderer.prototype.strong = function(text) {\n    return `<strong>${text}</strong>`;\n};\n\nRenderer.prototype.mark = function(text) {\n    return `<mark>${text}</mark>`;\n};\n\nRenderer.prototype.underline = function(text) {\n    return `<u>${text}</u>`;\n};\n\nRenderer.prototype.emoji = function(text) {\n    console.log(text);\n    if (emojione) {\n        return emojione.shortnameToImage(text);\n    } else {\n        return text;\n    }\n};\n\nRenderer.prototype.em = function(text) {\n    return `<em>${text}</em>`;\n};\n\nRenderer.prototype.codespan = function(text) {\n    return `<code>${text}</code>`;\n};\n\nRenderer.prototype.br = function() {\n    return this.options.xhtml ? '<br/>' : '<br>';\n};\n\nRenderer.prototype.del = function(text) {\n    return `<del>${text}</del>`;\n};\n\nRenderer.prototype.link = function(href, title, text) {\n    if (this.options.sanitize) {\n        try {\n            var prot = decodeURIComponent(unescape(href))\n              .replace(/[^\\w:]/g, '')\n              .toLowerCase();\n        } catch (e) {\n            return '';\n        }\n        if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {\n            return '';\n        }\n    }\n    var out = `<a href=\"${href}\"`;\n    if (title) {\n        out += ` title=\"${text}\"`;\n    }\n    if (/^(?!javascript:|vbscript:|#)/.test(href)) {\n        out += ' target=\"__blank\"';\n    }\n    out += `'>${text}</a>`;\n    return out;\n};\n\nRenderer.prototype.image = function(href, title, text) {\n    var style = '';\n    var m; // matcher\n    if (title && (m = /\\/w\\/([^\\/]+)/.exec(title))) {\n        title = title.replace(m[0], '');\n        m = m[1];\n        style += `width: ${m};`;\n    }\n    if (title && (m = /\\/h\\/([^\\/]+)/.exec(title))) {\n        title = title.replace(m[0], '');\n        m = m[1];\n        style += `height: ${m};`;\n    }\n    var out;\n    if (title) {\n        out = `<img src=\"${href}\" alt=\"${text}\" title=\"${title}\" style=\"${style}\"`;\n    } else {\n        out = `<img src=\"${href}\" alt=\"${text}\" style=\"${style}\"`;\n    }\n    out += this.options.xhtml ? '/>' : '>';\n    return out;\n};\n\nRenderer.prototype.text = function(text) {\n    return text;\n};\n\nRenderer.prototype.handseq = function(text) {\n    var container = document.createElement('div');\n    // $container.sequenceDiagram({theme: 'hand'});\n    var d = Diagram.parse(text);\n    var options = {theme: 'hand'};\n    d.drawSVG(container, options);\n    // 如果引用snap.svg-min.js，好像是在异步渲染，innerHTML会取不到\n    return stringformat('<div>{}</div>', container.innerHTML);\n}\n\nRenderer.prototype.flowchart = function(text) {\n    try {\n        var diagram = flowchart.parse(text);\n        //var $container = $('<div id=\"zmd-inner-flowchart\" style=\"display:none;\"></div>');\n        //$('body').append($container);\n        var container = document.createElement('div');\n        diagram.drawSVG(container, {\n            'x': 0,\n            'y': 0,\n            'line-width': 2,\n            'line-length': 30,\n            'text-margin': 10,\n            'font-size': 14,\n            'font-color': 'black',\n            'line-color': 'black',\n            'element-color': 'rgb(108, 108, 108)',\n            'fill': 'white',\n            'yes-text': 'yes',\n            'no-text': 'no',\n            'arrow-end': 'block',\n            'scale': 1,\n            // style symbol types\n            'symbols': {\n              'start': {\n                'font-color': 'red',\n                'element-color': 'rgb(108, 108, 108)',\n                'fill': 'yellow'\n              },\n              'end':{\n                'class': 'end-element'\n              }\n            },\n            // even flowstate support ;-)\n            'flowstate' : {\n              'past' : { 'fill' : '#CCCCCC', 'font-size' : 12},\n              'current' : {'fill' : 'rgb(236, 236, 255)', 'font-color' : 'red', 'font-weight' : 'bold'},\n              'future' : { 'fill' : 'rgb(236, 236, 255)'},\n              'request' : { 'fill' : 'blue'},\n              'invalid': {'fill' : '#444444'},\n              'approved' : { 'fill' : '#58C4A3', 'font-size' : 12, 'yes-text' : 'APPROVED', 'no-text' : 'n/a' },\n              'rejected' : { 'fill' : '#C45879', 'font-size' : 12, 'yes-text' : 'n/a', 'no-text' : 'REJECTED' }\n            }\n          });\n        return stringformat('<div>{}</div>', container.innerHTML);\n    } catch (e) {\n        return text;\n    }\n}\n\n\nRenderer.prototype.katex = function(text) {\n    // var items = text.split(/\\n{2,}/);\n    var items = text.split(/\\n{2}/);\n    var out = '';\n    for (var i = 0 ; i < items.length ; i++) {\n        try {\n            out += katex.renderToString(items[i]);\n        } catch(e) {\n            console.log('render katex error: ' + e);\n            out += items[i];\n        }\n    }\n    return out;\n}\n\nRenderer.prototype.mermaid = function(text) {\n    var container = document.createElement('div');\n    container.id = \"mermaid\" + (new Date()).getTime();\n    if (typeof(mermaidAPI) != \"undefined\") {\n        var graph = mermaidAPI.render(container.id, text.trim(), function(code) {});\n        return stringformat('<div>{}</div>', graph);\n    } else {\n        console.log('please include mermaidAPI.js');\n        return stringformat('<div>{}</div>', text);\n    }\n    \n}\n\nRenderer.prototype.bootalert = function(style, text) {\n    return stringformat('<div class=\"alert alert-{}\">{}</div>', style, text);\n}\n\n/**\n * Parsing & Compiling\n */\n\nfunction Parser(options) {\n    this.tokens = [];\n    this.token = null;\n    this.options = options || marked.defaults;\n    this.options.renderer = this.options.renderer || new Renderer;\n    this.renderer = this.options.renderer;\n    this.renderer.options = this.options;\n}\n\n/**\n * Static Parse Method\n */\nParser.parse = function(tokens, options, renderer) {\n    var parser = new Parser(options, renderer);\n    return parser.parse(tokens);\n};\n\n/**\n * Parse Loop\n */\nParser.prototype.parse = function(tokens) {\n    this.inline = new InlineLexer(tokens.links, this.options, this.renderer);\n    this.tokens = tokens.reverse();\n\n    if (this.options.toArray) {\n        var out = new Array();\n        while (this.next()) {\n            var token = this.token;\n            var fragment = this.tok();\n            if (fragment) {\n                out.push({\n                    html: fragment, \n                    offset: token.offset, \n                    length: token.length\n                });\n            }\n        }\n        return out;\n    } else {\n        var out = '';\n        while (this.next()) {\n            out += this.tok();\n        }\n        return out;\n    }\n};\n\n/**\n * Next Token\n */\nParser.prototype.next = function() {\n    return this.token = this.tokens.pop();\n};\n\n/**\n * Preview Next Token\n */\nParser.prototype.peek = function() {\n    return this.tokens[this.tokens.length - 1] || 0;\n};\n\n/**\n * Parse Text Tokens\n */\nParser.prototype.parseText = function() {\n    var body = this.token.text;\n    while (this.peek().type === 'text') {\n        body += '\\n' + this.next().text;\n    }\n    return this.inline.output(body);\n};\n\n/**\n * Parse Current Token ( for block grammar)\n */\nParser.prototype.tok = function() {\n    var renderFunc = brenders[this.token.type];\n    if (renderFunc) {\n        return renderFunc(this);\n    }\n};\n\n/**\n * Helpers\n */\nfunction escape(html, encode) {\n    return html\n        .replace(!encode ? /&(?!#?\\w+;)/g : /&/g, '&amp;')\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n        .replace(/\"/g, '&quot;')\n        .replace(/'/g, '&#39;');\n}\n\nfunction unescape(html) {\n    // explicitly match decimal, hex, and named HTML entities \n    return html.replace(/&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/g, function(_, n) {\n        n = n.toLowerCase();\n        if (n === 'colon') return ':';\n        if (n.charAt(0) === '#') {\n            return n.charAt(1) === 'x'\n                ? String.fromCharCode(parseInt(n.substring(2), 16))\n                : String.fromCharCode(+n.substring(1));\n        }\n        return '';\n    });\n}\n\nfunction replace(regex, opt) {\n    regex = regex.source;\n    opt = opt || '';\n    return function self(name, val) {\n        if (!name) return new RegExp(regex, opt);\n        val = val.source || val;\n        val = val.replace(/(^|[^\\[])\\^/g, '$1');\n        regex = regex.replace(name, val);\n        return self;\n    };\n}\n\nfunction merge(obj) {\n    var i = 1\n        , target\n        , key;\n\n    for (; i < arguments.length; i++) {\n        target = arguments[i];\n        for (key in target) {\n            if (Object.prototype.hasOwnProperty.call(target, key)) {\n                obj[key] = target[key];\n            }\n        }\n    }\n    return obj;\n}\n\nfunction stringformat(str) {\n    for (var i = 1 ; i < arguments.length; i++) {\n        str = str.replace('{}', arguments[i]);\n    }\n    return str;\n}\n\n/**\n * Mangle Links\n */\nfunction mangle(text) {\n    var out = '';\n    for (var i = 0; i < text.length ; i++) {\n        var ch = text.charCodeAt(i);\n        if (Math.random() > 0.5) {\n            ch = 'x' + ch.toString(16);\n        }\n        out += '&#' + ch + ';';\n    }\n    return out;\n};\n\n/**\n * Marked\n */\nfunction marked(src, opt, callback) {\n    if (callback || typeof opt === 'function') {\n        if (!callback) {\n            callback = opt;\n            opt = null;\n        }\n\n        opt = merge({}, marked.defaults, opt || {});\n\n        var highlight = opt.highlight\n            , tokens\n            , pending;\n\n        try {\n            tokens = Lexer.lex(src, opt)\n        } catch (e) {\n            return callback(e);\n        }\n\n        pending = tokens.length;\n\n        var done = function(err) {\n            if (err) {\n                opt.highlight = highlight;\n                return callback(err);\n            }\n\n            var out;\n            try {\n                out = Parser.parse(tokens, opt);\n            } catch (e) {\n                err = e;\n            }\n\n            opt.highlight = highlight;\n\n            return err ? callback(err) : callback(null, out);\n        };\n\n        if (!highlight || highlight.length < 3) {\n            return done();\n        }\n\n        delete opt.highlight;\n\n        if (!pending) return done();\n\n        for (var i = 0 ; i < tokens.length ; i++) {\n            (function(token) {\n                if (token.type !== 'code') {\n                    return --pending || done();\n                }\n                return highlight(token.text, token.lang, function(err, code) {\n                    if (err) return done(err);\n                    if (code == null || code === token.text) {\n                        return --pending || done();\n                    }\n                    token.text = code;\n                    token.escaped = true;\n                    --pending || done();\n                });\n            })(tokens[i]);\n        }\n\n        return;\n    }\n    try {\n        if (opt) opt = merge({}, marked.defaults, opt);\n        return Parser.parse(Lexer.lex(src, opt), opt);\n    } catch (e) {\n        e.message += '\\nPlease report this to zhfchdev@gmail.com.';\n        if ((opt || marked.defaults).silent) {\n            return stringformat('<p>An error occured:</p><pre>{}</pre>', escape(e.message + '', true));\n        }\n        throw e;\n    }\n}\n\n/**\n * Options\n */\nmarked.options =\nmarked.setOptions = function(opt) {\n    merge(marked.defaults, opt);\n    return marked;\n};\n\nmarked.defaults = {\n    gfm: true,\n    tables: true,\n    breaks: false,\n    pedantic: false,\n    sanitize: false,\n    sanitizer: null,\n    mangle: true,\n    smartLists: false,\n    silent: false,\n    highlight: null,\n    langPrefix: 'lang-',\n    smartypants: false,\n    headerPrefix: '',\n    xhtml: false, \n    toArray: false\n};\n\n/**\n * Expose\n */\nmarked.Parser = Parser;\nmarked.parser = Parser.parse;\n\nmarked.renderer = new Renderer;\n\nmarked.Lexer = Lexer;\nmarked.lexer = Lexer.lex;\n\nmarked.InlineLexer = InlineLexer;\nmarked.inlineLexer = InlineLexer.output;\n\nmarked.parse = marked;\n\nif (true) {\n    module.exports = marked;\n} else if (typeof define === 'function' && define.amd) {\n    define(function() { return marked; });\n} else {\n    this.marked = marked;\n}\n\n}).call(function() {\n  return this || (typeof window !== 'undefined' ? window : global);\n}());\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../../../../../usr/local/lib/~/webpack/buildin/global.js */ 2)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFya2VkLmNvcmUuanM/YmFmZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIG1hcmtkb3du55qE6K+t5rOV6Kej5p6Q5Zmo77yM6ISx6IOO5LqOaHR0cHM6Ly9naXRodWIuY29tL2NoamovbWFya2VkXG4gKiBAYXV0aG9yIHpoYW5nZnVjaGVuZyB6aGZjaGRldkBnbWFpbC5jb21cbiAqL1xuXG47KGZ1bmN0aW9uKCkge1xuXG4vKipcbiAqIEJsb2NrLUxldmVsIEdyYW1tYXJcbiAqL1xudmFyIGJncyA9IG5ldyBBcnJheSgpOyAvLyBibG9ja0dyYW1tYXJzXG52YXIgYmdtID0geyAvLyBibG9ja0dyYW1tYXJzTWFwXG4gICAgLy8g5ZG95ZCN6KeE6IyD77yMcmVnZXjnlKjljZXkuIvliJLnur/liY3nvIDvvIzlrZfnrKbkuLLnlKjlj4zkuIvliJLnur/liY3nvIBcbiAgICBfX3RhZzogJyg/ISg/OidcbiAgICAgICAgKyAnYXxlbXxzdHJvbmd8c21hbGx8c3xjaXRlfHF8ZGZufGFiYnJ8ZGF0YXx0aW1lfGNvZGUnXG4gICAgICAgICsgJ3x2YXJ8c2FtcHxrYmR8c3VifHN1cHxpfGJ8dXxtYXJrfHJ1Ynl8cnR8cnB8YmRpfGJkbydcbiAgICAgICAgKyAnfHNwYW58YnJ8d2JyfGluc3xkZWx8aW1nKVxcXFxiKVxcXFx3Kyg/ITovfFteXFxcXHdcXFxcc0BdKkApXFxcXGInLCAgXG4gICAgX2J1bGxldDogLyg/OlsqKy1dfFxcZCtcXC4pL1xufTsgXG52YXIgYnJlbmRlcnMgPSB7fTsgLy8gYmxvY2tHcmFtbWFycyBSZW5kZXJzXG5cbi8vIOWPguS4juWMuemFjeiuoeeul+eahOaooeW8j+WumuS5iVxuYmdtWyduZXdsaW5lJ10gPSB7XG4gICAgcGF0dGVybjogL15cXG4rLywgXG4gICAgdGVzdDogZnVuY3Rpb24oc3JjLCBsZXhlcikge1xuICAgICAgICB2YXIgY2FwID0gdGhpcy5wYXR0ZXJuLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKCFjYXApIHJldHVybiB7bWF0Y2g6IGZhbHNlfTtcbiAgICAgICAgaWYgKGNhcFswXS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsZXhlci50b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NwYWNlJywgXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBsZXhlci5yYXcubGVuZ3RoIC0gc3JjLmxlbmd0aCwgXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBjYXBbMF0ubGVuZ3RoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge21hdGNoOiB0cnVlLCBncm91cDogY2FwWzBdfTtcbiAgICB9LCBcbiAgICByZW5kZXI6IGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgICByZXR1cm4gcGFyc2VyLnJlbmRlcmVyLmVtcHR5KCk7XG4gICAgfVxufTtcbmJncy5wdXNoKGJnbS5uZXdsaW5lKTtcbmJyZW5kZXJzWydzcGFjZSddID0gYmdtLm5ld2xpbmUucmVuZGVyO1xuXG5iZ21bJ2hhbmRzZXEnXSA9IHtcbiAgICBwYXR0ZXJuOiAvXiAqYHszfVxccypoYW5kc2VxXFxzKyhbXFxzXFxTXSs/KWB7M30vLCBcbiAgICB0ZXN0OiBmdW5jdGlvbihzcmMsIGxleGVyKSB7XG4gICAgICAgIHZhciBjYXAgPSB0aGlzLnBhdHRlcm4uZXhlYyhzcmMpO1xuICAgICAgICBpZiAoIWNhcCkgcmV0dXJuIHttYXRjaDogZmFsc2V9O1xuICAgICAgICBsZXhlci50b2tlbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnaGFuZHNlcScsXG4gICAgICAgICAgICB0ZXh0OiBjYXBbMV0sIFxuICAgICAgICAgICAgb2Zmc2V0OiBsZXhlci5yYXcubGVuZ3RoIC0gc3JjLmxlbmd0aCwgXG4gICAgICAgICAgICBsZW5ndGg6IGNhcFswXS5sZW5ndGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHttYXRjaDogdHJ1ZSwgZ3JvdXA6IGNhcFswXX07XG4gICAgfSwgXG4gICAgcmVuZGVyOiBmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgICAgdmFyIHRva2VuID0gcGFyc2VyLnRva2VuO1xuICAgICAgICByZXR1cm4gcGFyc2VyLnJlbmRlcmVyLmhhbmRzZXEodG9rZW4udGV4dCk7XG4gICAgfVxufVxuYmdzLnB1c2goYmdtLmhhbmRzZXEpO1xuYnJlbmRlcnNbJ2hhbmRzZXEnXSA9IGJnbS5oYW5kc2VxLnJlbmRlcjtcblxuYmdtWydmbG93Y2hhcnQnXSA9IHtcbiAgICBwYXR0ZXJuOiAvXiAqYHszfVxccypmbG93Y2hhcnRcXHMrKFtcXHNcXFNdKz8pYHszfS8sIFxuICAgIHRlc3Q6IGZ1bmN0aW9uKHNyYywgbGV4ZXIpIHtcbiAgICAgICAgdmFyIGNhcCA9IHRoaXMucGF0dGVybi5leGVjKHNyYyk7XG4gICAgICAgIGlmICghY2FwKSByZXR1cm4ge21hdGNoOiBmYWxzZX07XG4gICAgICAgIGxleGVyLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdmbG93Y2hhcnQnLFxuICAgICAgICAgICAgdGV4dDogY2FwWzFdLCBcbiAgICAgICAgICAgIG9mZnNldDogbGV4ZXIucmF3Lmxlbmd0aCAtIHNyYy5sZW5ndGgsIFxuICAgICAgICAgICAgbGVuZ3RoOiBjYXBbMF0ubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge21hdGNoOiB0cnVlLCBncm91cDogY2FwWzBdfTtcbiAgICB9LCBcbiAgICByZW5kZXI6IGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgICB2YXIgdG9rZW4gPSBwYXJzZXIudG9rZW47XG4gICAgICAgIHJldHVybiBwYXJzZXIucmVuZGVyZXIuZmxvd2NoYXJ0KHRva2VuLnRleHQpO1xuICAgIH1cbn1cbmJncy5wdXNoKGJnbS5mbG93Y2hhcnQpO1xuYnJlbmRlcnNbJ2Zsb3djaGFydCddID0gYmdtLmZsb3djaGFydC5yZW5kZXI7XG5cbmJnbVsna2F0ZXgnXSA9IHtcbiAgICBwYXR0ZXJuOiAvXiAqYHszfVxccyptYXRoXFxzKyhbXFxzXFxTXSs/KWB7M30vLCBcbiAgICB0ZXN0OiBmdW5jdGlvbihzcmMsIGxleGVyKSB7XG4gICAgICAgIHZhciBjYXAgPSB0aGlzLnBhdHRlcm4uZXhlYyhzcmMpO1xuICAgICAgICBpZiAoIWNhcCkgcmV0dXJuIHttYXRjaDogZmFsc2V9O1xuICAgICAgICBsZXhlci50b2tlbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAna2F0ZXgnLFxuICAgICAgICAgICAgdGV4dDogY2FwWzFdLCBcbiAgICAgICAgICAgIG9mZnNldDogbGV4ZXIucmF3Lmxlbmd0aCAtIHNyYy5sZW5ndGgsIFxuICAgICAgICAgICAgbGVuZ3RoOiBjYXBbMF0ubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge21hdGNoOiB0cnVlLCBncm91cDogY2FwWzBdfTtcbiAgICB9LCBcbiAgICByZW5kZXI6IGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgICB2YXIgdG9rZW4gPSBwYXJzZXIudG9rZW47XG4gICAgICAgIHJldHVybiBwYXJzZXIucmVuZGVyZXIua2F0ZXgodG9rZW4udGV4dCk7XG4gICAgfVxufVxuYmdzLnB1c2goYmdtLmthdGV4KTtcbmJyZW5kZXJzWydrYXRleCddID0gYmdtLmthdGV4LnJlbmRlcjtcblxuYmdtWydtZXJtYWlkJ10gPSB7XG4gICAgcGF0dGVybjogL14gKmB7M31cXHMqbWVybWFpZFxccysoW1xcc1xcU10rPylgezN9LywgXG4gICAgdGVzdDogZnVuY3Rpb24oc3JjLCBsZXhlcikge1xuICAgICAgICB2YXIgY2FwID0gdGhpcy5wYXR0ZXJuLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKCFjYXApIHJldHVybiB7bWF0Y2g6IGZhbHNlfTtcbiAgICAgICAgbGV4ZXIudG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ21lcm1haWQnLFxuICAgICAgICAgICAgdGV4dDogY2FwWzFdLCBcbiAgICAgICAgICAgIG9mZnNldDogbGV4ZXIucmF3Lmxlbmd0aCAtIHNyYy5sZW5ndGgsIFxuICAgICAgICAgICAgbGVuZ3RoOiBjYXBbMF0ubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge21hdGNoOiB0cnVlLCBncm91cDogY2FwWzBdfTtcbiAgICB9LCBcbiAgICByZW5kZXI6IGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgICB2YXIgdG9rZW4gPSBwYXJzZXIudG9rZW47XG4gICAgICAgIHJldHVybiBwYXJzZXIucmVuZGVyZXIubWVybWFpZCh0b2tlbi50ZXh0KTtcbiAgICB9XG59XG5iZ3MucHVzaChiZ20ubWVybWFpZCk7XG5icmVuZGVyc1snbWVybWFpZCddID0gYmdtLm1lcm1haWQucmVuZGVyO1xuXG4vLyBleHRlbmQgZmVhdHVyZSwgYWxlcnQgc3R5cGUgYnkgYm9vdGNzc1xuYmdtWydib290YWxlcnQnXSA9IHtcbiAgICBwYXR0ZXJuOiAvXiAqOnszfVxccyooW15cXHNdKylcXHMqKFtcXHNcXFNdKz8pOnszfS8sIFxuICAgIHRlc3Q6IGZ1bmN0aW9uKHNyYywgbGV4ZXIpIHtcbiAgICAgICAgdmFyIGNhcCA9IHRoaXMucGF0dGVybi5leGVjKHNyYyk7XG4gICAgICAgIGlmICghY2FwKSByZXR1cm4ge21hdGNoOiBmYWxzZX07XG4gICAgICAgIGxleGVyLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdib290YWxlcnQnLFxuICAgICAgICAgICAgc3R5bGU6IGNhcFsxXSxcbiAgICAgICAgICAgIHRleHQ6IGNhcFsyXSwgXG4gICAgICAgICAgICBvZmZzZXQ6IGxleGVyLnJhdy5sZW5ndGggLSBzcmMubGVuZ3RoLCBcbiAgICAgICAgICAgIGxlbmd0aDogY2FwWzBdLmxlbmd0aFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHttYXRjaDogdHJ1ZSwgZ3JvdXA6IGNhcFswXX07XG4gICAgfSwgXG4gICAgcmVuZGVyOiBmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgICAgdmFyIHRva2VuID0gcGFyc2VyLnRva2VuO1xuICAgICAgICByZXR1cm4gcGFyc2VyLnJlbmRlcmVyLmJvb3RhbGVydCh0b2tlbi5zdHlsZSwgcGFyc2VyLmlubGluZS5vdXRwdXQodG9rZW4udGV4dCkpO1xuICAgIH1cbn1cbmJncy5wdXNoKGJnbS5ib290YWxlcnQpO1xuYnJlbmRlcnNbJ2Jvb3RhbGVydCddID0gYmdtLmJvb3RhbGVydC5yZW5kZXI7XG5cbmJnbVsnY29kZSddID0ge1xuICAgIHBhdHRlcm46IC9eKCB7NH1bXlxcbl0rXFxuKikrLywgXG4gICAgdGVzdDogZnVuY3Rpb24oc3JjLCBsZXhlcikge1xuICAgICAgICB2YXIgY2FwID0gdGhpcy5wYXR0ZXJuLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKCFjYXApIHJldHVybiB7bWF0Y2g6IGZhbHNlfTtcbiAgICAgICAgdmFyIGNhcDAgPSBjYXBbMF0ucmVwbGFjZSgvXiB7NH0vZ20sICcnKTtcbiAgICAgICAgbGV4ZXIudG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICAgICAgdGV4dDogbGV4ZXIub3B0aW9ucy5wZWRhbnRpYyA/IGNhcDAgOiBjYXAwLnJlcGxhY2UoL1xcbiskLywgJycpLCBcbiAgICAgICAgICAgIG9mZnNldDogbGV4ZXIucmF3Lmxlbmd0aCAtIHNyYy5sZW5ndGgsIFxuICAgICAgICAgICAgbGVuZ3RoOiBjYXBbMF0ubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge21hdGNoOiB0cnVlLCBncm91cDogY2FwWzBdfTtcbiAgICB9LCBcbiAgICByZW5kZXI6IGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgICB2YXIgdG9rZW4gPSBwYXJzZXIudG9rZW47XG4gICAgICAgIHJldHVybiBwYXJzZXIucmVuZGVyZXIuY29kZSh0b2tlbi50ZXh0LFxuICAgICAgICAgICAgICAgIHRva2VuLmxhbmcsXG4gICAgICAgICAgICAgICAgdG9rZW4uZXNjYXBlZCk7XG4gICAgfVxufTtcbmJncy5wdXNoKGJnbVsnY29kZSddKTtcbmJyZW5kZXJzWydjb2RlJ10gPSBiZ20uY29kZS5yZW5kZXI7XG5cbmJnbVsnZmVuY2VzJ10gPSB7IC8vIChnZm0pXG4gICAgcGF0dGVybjogL14gKihgezMsfXx+ezMsfSlbIFxcLl0qKFxcUyspPyAqXFxuKFtcXHNcXFNdKj8pXFxzKlxcMSAqKD86XFxuK3wkKS8sIFxuICAgIHRlc3Q6IGZ1bmN0aW9uKHNyYywgbGV4ZXIpIHtcbiAgICAgICAgaWYgKCFsZXhlci5vcHRpb25zLmdmbSkgcmV0dXJuIHttYXRjaDogZmFsc2V9O1xuICAgICAgICB2YXIgY2FwID0gdGhpcy5wYXR0ZXJuLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKCFjYXApIHJldHVybiB7bWF0Y2g6IGZhbHNlfTtcbiAgICAgICAgbGV4ZXIudG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICAgICAgbGFuZzogY2FwWzJdLFxuICAgICAgICAgICAgdGV4dDogY2FwWzNdIHx8ICcnLCBcbiAgICAgICAgICAgIG9mZnNldDogbGV4ZXIucmF3Lmxlbmd0aCAtIHNyYy5sZW5ndGgsIFxuICAgICAgICAgICAgbGVuZ3RoOiBjYXBbMF0ubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge21hdGNoOiB0cnVlLCBncm91cDogY2FwWzBdfTtcbiAgICB9XG59O1xuYmdzLnB1c2goYmdtWydmZW5jZXMnXSk7XG5cbmJnbVsnaGVhZGluZyddID0geyAvLyAoZ2ZtKVxuICAgIHBhdHRlcm46IC9eICooI3sxLDZ9KSAqKFteXFxuXSs/KSAqIyogKig/Olxcbit8JCkvLCBcbiAgICBnZm06IC9eICooI3sxLDZ9KSArKFteXFxuXSs/KSAqIyogKig/Olxcbit8JCkvLCBcbiAgICB0ZXN0OiBmdW5jdGlvbihzcmMsIGxleGVyKSB7XG4gICAgICAgIHZhciBwID0gKGxleGVyLm9wdGlvbnMuZ2ZtKSA/IHRoaXMuZ2ZtIDogdGhpcy5wYXR0ZXJuO1xuICAgICAgICB2YXIgY2FwID0gcC5leGVjKHNyYyk7XG4gICAgICAgIGlmICghY2FwKSByZXR1cm4ge21hdGNoOiBmYWxzZX07XG4gICAgICAgIGxleGVyLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICAgICAgICAgIGRlcHRoOiBjYXBbMV0ubGVuZ3RoLFxuICAgICAgICAgICAgdGV4dDogY2FwWzJdLCBcbiAgICAgICAgICAgIG9mZnNldDogbGV4ZXIucmF3Lmxlbmd0aCAtIHNyYy5sZW5ndGgsIFxuICAgICAgICAgICAgbGVuZ3RoOiBjYXBbMF0ubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge21hdGNoOiB0cnVlLCBncm91cDogY2FwWzBdfTtcbiAgICB9LCBcbiAgICByZW5kZXI6IGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgICB2YXIgdG9rZW4gPSBwYXJzZXIudG9rZW47XG4gICAgICAgIHJldHVybiBwYXJzZXIucmVuZGVyZXIuaGVhZGluZyhcbiAgICAgICAgICAgICAgICBwYXJzZXIuaW5saW5lLm91dHB1dCh0b2tlbi50ZXh0KSxcbiAgICAgICAgICAgICAgICB0b2tlbi5kZXB0aCxcbiAgICAgICAgICAgICAgICB0b2tlbi50ZXh0KTtcbiAgICB9XG59O1xuYmdzLnB1c2goYmdtLmhlYWRpbmcpO1xuYnJlbmRlcnNbJ2hlYWRpbmcnXSA9IGJnbS5oZWFkaW5nLnJlbmRlcjtcblxuYmdtWyducHRhYmxlJ10gPSB7IC8vIHRhYmxlIG5vIGxlYWRpbmcgcGlwZSAoZ2ZtKVxuICAgIHBhdHRlcm46IC9eICooXFxTLipcXHwuKilcXG4gKihbLTpdKyAqXFx8Wy18IDpdKilcXG4oKD86LipcXHwuKig/OlxcbnwkKSkqKVxcbiovLCBcbiAgICB0ZXN0OiBmdW5jdGlvbihzcmMsIGxleGVyLCBmbGFnKSB7XG4gICAgICAgIGlmICghbGV4ZXIub3B0aW9ucy50YWJsZXMpIHJldHVybiB7bWF0Y2g6IGZhbHNlfTtcbiAgICAgICAgaWYgKCFmbGFnLnRvcCkgcmV0dXJuIHttYXRjaDogZmFsc2V9OyAvLyDlpoLmnpzkuI3mmK/ku450b3AgbGV2ZWzosIPnlKjvvIzkuI3og73nlJ/miJDooajmoLxcbiAgICAgICAgdmFyIGNhcCA9IHRoaXMucGF0dGVybi5leGVjKHNyYyk7XG4gICAgICAgIGlmICghY2FwKSByZXR1cm4ge21hdGNoOiBmYWxzZX07XG5cbiAgICAgICAgdmFyIGl0ZW0gPSB7XG4gICAgICAgICAgICB0eXBlOiAndGFibGUnLFxuICAgICAgICAgICAgaGVhZGVyOiBjYXBbMV0ucmVwbGFjZSgvXiAqfCAqXFx8ICokL2csICcnKS5zcGxpdCgvICpcXHwgKi8pLFxuICAgICAgICAgICAgYWxpZ246IGNhcFsyXS5yZXBsYWNlKC9eICp8XFx8ICokL2csICcnKS5zcGxpdCgvICpcXHwgKi8pLFxuICAgICAgICAgICAgY2VsbHM6IGNhcFszXS5yZXBsYWNlKC9cXG4kLywgJycpLnNwbGl0KCdcXG4nKSwgXG4gICAgICAgICAgICBvZmZzZXQ6IGxleGVyLnJhdy5sZW5ndGggLSBzcmMubGVuZ3RoLCBcbiAgICAgICAgICAgIGxlbmd0aDogY2FwWzBdLmxlbmd0aFxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtLmFsaWduLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoL14gKi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAncmlnaHQnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnY2VudGVyJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL14gKjotKyAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnbGVmdCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW0uY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0uY2VsbHNbaV0gPSBpdGVtLmNlbGxzW2ldLnNwbGl0KC8gKlxcfCAqLyk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXhlci50b2tlbnMucHVzaChpdGVtKTtcbiAgICAgICAgcmV0dXJuIHttYXRjaDogdHJ1ZSwgZ3JvdXA6IGNhcFswXX07XG4gICAgfSwgXG4gICAgcmVuZGVyOiBmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgICAgdmFyIGhlYWRlciA9ICcnLCBib2R5ID0gJyc7XG4gICAgICAgIHZhciByb3csIGNlbGw7XG4gICAgICAgIHZhciB0b2tlbiA9IHBhcnNlci50b2tlbjtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gcGFyc2VyLnJlbmRlcmVyO1xuXG4gICAgICAgIGNlbGwgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbi5oZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNlbGwgKz0gcmVuZGVyZXIudGFibGVjZWxsKFxuICAgICAgICAgICAgICAgIHBhcnNlci5pbmxpbmUub3V0cHV0KHRva2VuLmhlYWRlcltpXSksXG4gICAgICAgICAgICAgICAgeyBoZWFkZXI6IHRydWUsIGFsaWduOiB0b2tlbi5hbGlnbltpXSB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGhlYWRlciArPSByZW5kZXJlci50YWJsZXJvdyhjZWxsKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2VuLmNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByb3cgPSB0b2tlbi5jZWxsc1tpXTtcbiAgICAgICAgICAgIGNlbGwgPSAnJztcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcm93Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY2VsbCArPSByZW5kZXJlci50YWJsZWNlbGwoXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlci5pbmxpbmUub3V0cHV0KHJvd1tqXSksXG4gICAgICAgICAgICAgICAgICAgIHsgaGVhZGVyOiBmYWxzZSwgYWxpZ246IHRva2VuLmFsaWduW2pdIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm9keSArPSByZW5kZXJlci50YWJsZXJvdyhjZWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVuZGVyZXIudGFibGUoaGVhZGVyLCBib2R5KTtcbiAgICB9XG59O1xuYmdzLnB1c2goYmdtLm5wdGFibGUpO1xuYnJlbmRlcnNbJ3RhYmxlJ10gPSBiZ20ubnB0YWJsZS5yZW5kZXI7XG5cbmJnbVsnbGhlYWRpbmcnXSA9IHtcbiAgICBwYXR0ZXJuOiAvXihbXlxcbl0rKVxcbiAqKD18LSl7Mix9ICooPzpcXG4rfCQpLywgXG4gICAgdGVzdDogZnVuY3Rpb24oc3JjLCBsZXhlcikge1xuICAgICAgICB2YXIgY2FwID0gdGhpcy5wYXR0ZXJuLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKCFjYXApIHJldHVybiB7bWF0Y2g6IGZhbHNlfTtcbiAgICAgICAgbGV4ZXIudG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgICAgICAgZGVwdGg6IGNhcFsyXSA9PT0gJz0nID8gMSA6IDIsXG4gICAgICAgICAgICB0ZXh0OiBjYXBbMV0sIFxuICAgICAgICAgICAgb2Zmc2V0OiBsZXhlci5yYXcubGVuZ3RoIC0gc3JjLmxlbmd0aCwgXG4gICAgICAgICAgICBsZW5ndGg6IGNhcFswXS5sZW5ndGhcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7bWF0Y2g6IHRydWUsIGdyb3VwOiBjYXBbMF19O1xuICAgIH1cbn07XG5iZ3MucHVzaChiZ21bJ2xoZWFkaW5nJ10pOyAvLyByZW5kZXLlkoxoZWFkaW5n55u45ZCMXG5cbmJnbVsnaHInXSA9IHtcbiAgICBwYXR0ZXJuOiAvXiggKlstKl9dKXszLH0gKig/Olxcbit8JCkvLCBcbiAgICB0ZXN0OiBmdW5jdGlvbihzcmMsIGxleGVyKSB7XG4gICAgICAgIHZhciBjYXAgPSB0aGlzLnBhdHRlcm4uZXhlYyhzcmMpO1xuICAgICAgICBpZiAoIWNhcCkgcmV0dXJuIHttYXRjaDogZmFsc2V9O1xuICAgICAgICBsZXhlci50b2tlbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnaHInLCBcbiAgICAgICAgICAgIG9mZnNldDogbGV4ZXIucmF3Lmxlbmd0aCAtIHNyYy5sZW5ndGgsIFxuICAgICAgICAgICAgbGVuZ3RoOiBjYXBbMF0ubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge21hdGNoOiB0cnVlLCBncm91cDogY2FwWzBdfTtcbiAgICB9LCBcbiAgICByZW5kZXI6IGZ1bmN0aW9uKCBwYXJzZXIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5yZW5kZXJlci5ocigpO1xuICAgIH1cbn07XG5iZ3MucHVzaChiZ20uaHIpO1xuYnJlbmRlcnNbJ2hyJ10gPSBiZ20uaHIucmVuZGVyO1xuXG5iZ21bJ2Jsb2NrcXVvdGUnXSA9IHtcbiAgICBwYXR0ZXJuOiAvXiggKj5bXlxcbl0rKFxcbig/IWRlZilbXlxcbl0rKSpcXG4qKSsvLCBcbiAgICB0ZXN0OiBmdW5jdGlvbihzcmMsIGxleGVyLCBmbGFnKSB7XG4gICAgICAgIHZhciBjYXAgPSB0aGlzLnBhdHRlcm4uZXhlYyhzcmMpO1xuICAgICAgICBpZiAoIWNhcCkgcmV0dXJuIHttYXRjaDogZmFsc2V9O1xuICAgICAgICBsZXhlci50b2tlbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnYmxvY2txdW90ZV9zdGFydCcsIFxuICAgICAgICAgICAgb2Zmc2V0OiBsZXhlci5yYXcubGVuZ3RoIC0gc3JjLmxlbmd0aCwgXG4gICAgICAgICAgICBsZW5ndGg6IGNhcFswXS5sZW5ndGhcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGNhcDAgPSBjYXBbMF0ucmVwbGFjZSgvXiAqPiA/L2dtLCAnJyk7XG4gICAgICAgIC8vIFBhc3MgYHRvcGAgdG8ga2VlcCB0aGUgY3VycmVudCBcInRvcGxldmVsXCIgc3RhdGUuIFRoaXMgaXMgZXhhY3RseVxuICAgICAgICAvLyBob3cgbWFya2Rvd24ucGwgd29ya3MuXG4gICAgICAgIGxleGVyLnRva2VuKGNhcDAsIGZsYWcudG9wLCB0cnVlKTtcblxuICAgICAgICBsZXhlci50b2tlbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnYmxvY2txdW90ZV9lbmQnLCBcbiAgICAgICAgICAgIG9mZnNldDogbGV4ZXIucmF3Lmxlbmd0aCAtIHNyYy5sZW5ndGggLSBjYXBbMF0ubGVuZ3RoLCBcbiAgICAgICAgICAgIGxlbmd0aDogMFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHttYXRjaDogdHJ1ZSwgZ3JvdXA6IGNhcFswXX07XG4gICAgfSwgXG4gICAgcmVuZGVyOiBmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgICAgdmFyIHRva2VuID0gcGFyc2VyLnRva2VuO1xuICAgICAgICBpZiAodG9rZW4udHlwZSA9PSAnYmxvY2txdW90ZV9lbmQnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJvZHkgPSAnJztcbiAgICAgICAgd2hpbGUgKHBhcnNlci5uZXh0KCkudHlwZSAhPT0gJ2Jsb2NrcXVvdGVfZW5kJykge1xuICAgICAgICAgICAgYm9keSArPSBwYXJzZXIudG9rKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlci5yZW5kZXJlci5ibG9ja3F1b3RlKGJvZHkpO1xuICAgIH1cbn07XG5iZ3MucHVzaChiZ20uYmxvY2txdW90ZSk7XG5icmVuZGVyc1snYmxvY2txdW90ZV9zdGFydCddID0gYmdtLmJsb2NrcXVvdGUucmVuZGVyO1xuYnJlbmRlcnNbJ2Jsb2NrcXVvdGVfZW5kJ10gPSBiZ20uYmxvY2txdW90ZS5yZW5kZXI7XG5cbmJnbVsnbGlzdCddID0ge1xuICAgIHBhdHRlcm46IC9eKCAqKShidWxsKSBbXFxzXFxTXSs/KD86aHJ8ZGVmfFxcbnsyLH0oPyEgKSg/IVxcMWJ1bGwgKVxcbip8XFxzKiQpLywgXG4gICAgaXRlbTogL14oICopKGJ1bGwpIFteXFxuXSooPzpcXG4oPyFcXDFidWxsIClbXlxcbl0qKSovLCBcbiAgICB0ZXN0OiBmdW5jdGlvbihzcmMsIGxleGVyLCBmbGFnKSB7XG4gICAgICAgIHZhciBjYXAgPSB0aGlzLnBhdHRlcm4uZXhlYyhzcmMpO1xuICAgICAgICBpZiAoIWNhcCkgcmV0dXJuIHttYXRjaDogZmFsc2V9O1xuICAgICAgICBidWxsID0gY2FwWzJdO1xuXG4gICAgICAgIGxleGVyLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdsaXN0X3N0YXJ0JywgXG4gICAgICAgICAgICBvcmRlcmVkOiBidWxsLmxlbmd0aCA+IDEsIFxuICAgICAgICAgICAgb2Zmc2V0OiBsZXhlci5yYXcubGVuZ3RoIC0gc3JjLmxlbmd0aCwgXG4gICAgICAgICAgICBsZW5ndGg6IGNhcFswXS5sZW5ndGhcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gR2V0IGVhY2ggdG9wLWxldmVsIGl0ZW0uXG4gICAgICAgIHZhciBjYXAwID0gY2FwWzBdLm1hdGNoKHRoaXMuaXRlbSk7XG5cbiAgICAgICAgdmFyIG5leHQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgY2FwMC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaXRlbSA9IGNhcDBbaV07XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbGlzdCBpdGVtJ3MgYnVsbGV0XG4gICAgICAgICAgICAvLyBzbyBpdCBpcyBzZWVuIGFzIHRoZSBuZXh0IHRva2VuLlxuICAgICAgICAgICAgdmFyIHNwYWNlID0gaXRlbS5sZW5ndGg7XG4gICAgICAgICAgICBpdGVtID0gaXRlbS5yZXBsYWNlKC9eICooWyorLV18XFxkK1xcLikgKy8sICcnKTtcblxuICAgICAgICAgICAgLy8gT3V0ZGVudCB3aGF0ZXZlciB0aGVcbiAgICAgICAgICAgIC8vIGxpc3QgaXRlbSBjb250YWlucy4gSGFja3kuXG4gICAgICAgICAgICBpZiAofml0ZW0uaW5kZXhPZignXFxuICcpKSB7XG4gICAgICAgICAgICAgICAgc3BhY2UgLT0gaXRlbS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaXRlbSA9ICFsZXhlci5vcHRpb25zLnBlZGFudGljXG4gICAgICAgICAgICAgICAgICAgID8gaXRlbS5yZXBsYWNlKG5ldyBSZWdFeHAoJ14gezEsJyArIHNwYWNlICsgJ30nLCAnZ20nKSwgJycpXG4gICAgICAgICAgICAgICAgICAgIDogaXRlbS5yZXBsYWNlKC9eIHsxLDR9L2dtLCAnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERldGVybWluZSB3aGV0aGVyIHRoZSBuZXh0IGxpc3QgaXRlbSBiZWxvbmdzIGhlcmUuXG4gICAgICAgICAgICAvLyBCYWNrcGVkYWwgaWYgaXQgZG9lcyBub3QgYmVsb25nIGluIHRoaXMgbGlzdC5cbiAgICAgICAgICAgIGlmIChsZXhlci5vcHRpb25zLnNtYXJ0TGlzdHMgJiYgaSAhPT0gY2FwMC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgYiA9IGJnbS5fYnVsbGV0LmV4ZWMoY2FwMFtpICsgMV0pWzBdO1xuICAgICAgICAgICAgICAgIGlmIChidWxsICE9PSBiICYmICEoYnVsbC5sZW5ndGggPiAxICYmIGIubGVuZ3RoID4gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3JjID0gY2FwMC5zbGljZShpICsgMSkuam9pbignXFxuJykgKyBzcmM7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBjYXAwLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgd2hldGhlciBpdGVtIGlzIGxvb3NlIG9yIG5vdC5cbiAgICAgICAgICAgIC8vIFVzZTogLyhefFxcbikoPyEgKVteXFxuXStcXG5cXG4oPyFcXHMqJCkvXG4gICAgICAgICAgICAvLyBmb3IgZGlzY291bnQgYmVoYXZpb3IuXG4gICAgICAgICAgICBsb29zZSA9IG5leHQgfHwgL1xcblxcbig/IVxccyokKS8udGVzdChpdGVtKTtcbiAgICAgICAgICAgIGlmIChpICE9PSBjYXAwLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gaXRlbS5jaGFyQXQoaXRlbS5sZW5ndGggLSAxKSA9PT0gJ1xcbic7XG4gICAgICAgICAgICAgICAgaWYgKCFsb29zZSkgbG9vc2UgPSBuZXh0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXhlci50b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogbG9vc2UgPyAnbG9vc2VfaXRlbV9zdGFydCcgOiAnbGlzdF9pdGVtX3N0YXJ0JywgXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBsZXhlci5yYXcubGVuZ3RoIC0gc3JjLmxlbmd0aCArIHRvdGFsLCBcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGl0ZW0ubGVuZ3RoXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gUmVjdXJzZS5cbiAgICAgICAgICAgIGxleGVyLnRva2VuKGl0ZW0sIGZhbHNlLCBmbGFnLmJxKTtcblxuICAgICAgICAgICAgbGV4ZXIudG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdsaXN0X2l0ZW1fZW5kJywgXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBsZXhlci5yYXcubGVuZ3RoIC0gc3JjLmxlbmd0aCArIHRvdGFsICsgaXRlbS5sZW5ndGgsIFxuICAgICAgICAgICAgICAgIGxlbmd0aDogMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0b3RhbCArPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxleGVyLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdsaXN0X2VuZCcsIFxuICAgICAgICAgICAgb2Zmc2V0OiBsZXhlci5yYXcubGVuZ3RoIC0gc3JjLmxlbmd0aCAtIGNhcFswXS5sZW5ndGgsIFxuICAgICAgICAgICAgbGVuZ3RoOiAwXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge21hdGNoOiB0cnVlLCBncm91cDogY2FwWzBdfTtcbiAgICB9LCBcbiAgICByZW5kZXI6IGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgICB2YXIgdG9rZW5UeXBlID0gcGFyc2VyLnRva2VuLnR5cGU7XG4gICAgICAgIHN3aXRjaCh0b2tlblR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2xpc3Rfc3RhcnQnOiB7XG4gICAgICAgICAgICAgICAgdmFyIG9yZGVyZWQgPSBwYXJzZXIudG9rZW4ub3JkZXJlZDtcbiAgICAgICAgICAgICAgICB2YXIgYm9keSA9ICcnO1xuICAgICAgICAgICAgICAgIHdoaWxlIChwYXJzZXIubmV4dCgpLnR5cGUgIT09ICdsaXN0X2VuZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSArPSBwYXJzZXIudG9rKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZXIucmVuZGVyZXIubGlzdChib2R5LCBvcmRlcmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2xpc3RfaXRlbV9zdGFydCc6IHtcbiAgICAgICAgICAgICAgICB2YXIgYm9keSA9ICcnO1xuICAgICAgICAgICAgICAgIHdoaWxlIChwYXJzZXIubmV4dCgpLnR5cGUgIT09ICdsaXN0X2l0ZW1fZW5kJykge1xuICAgICAgICAgICAgICAgICAgICBib2R5ICs9IHBhcnNlci50b2tlbi50eXBlID09PSAndGV4dCdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcGFyc2VyLnBhcnNlVGV4dCgpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHBhcnNlci50b2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlci5yZW5kZXJlci5saXN0aXRlbShib2R5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2xvb3NlX2l0ZW1fc3RhcnQnOiB7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHkgPSAnJztcbiAgICAgICAgICAgICAgICB3aGlsZSAocGFyc2VyLm5leHQoKS50eXBlICE9PSAnbGlzdF9pdGVtX2VuZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSArPSBwYXJzZXIudG9rKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZXIucmVuZGVyZXIubGlzdGl0ZW0oYm9keSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuYmdzLnB1c2goYmdtLmxpc3QpO1xuYnJlbmRlcnNbJ2xpc3Rfc3RhcnQnXSA9IGJnbS5saXN0LnJlbmRlcjtcbmJyZW5kZXJzWydsaXN0X2VuZCddID0gYmdtLmxpc3QucmVuZGVyO1xuYnJlbmRlcnNbJ2xpc3RfaXRlbV9zdGFydCddID0gYmdtLmxpc3QucmVuZGVyO1xuYnJlbmRlcnNbJ2xpc3RfaXRlbV9lbmQnXSA9IGJnbS5saXN0LnJlbmRlcjtcbmJyZW5kZXJzWydsb29zZV9pdGVtX3N0YXJ0J10gPSBiZ20ubGlzdC5yZW5kZXI7XG5cbmJnbVsnaHRtbCddID0ge1xuICAgIHBhdHRlcm46IC9eICooPzpjb21tZW50ICooPzpcXG58XFxzKiQpfGNsb3NlZCAqKD86XFxuezIsfXxcXHMqJCl8Y2xvc2luZyAqKD86XFxuezIsfXxcXHMqJCkpLywgXG4gICAgdGVzdDogZnVuY3Rpb24oc3JjLCBsZXhlcikge1xuICAgICAgICB2YXIgY2FwID0gdGhpcy5wYXR0ZXJuLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKCFjYXApIHJldHVybiB7bWF0Y2g6IGZhbHNlfTtcbiAgICAgICAgbGV4ZXIudG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogbGV4ZXIub3B0aW9ucy5zYW5pdGl6ZSA/ICdwYXJhZ3JhcGgnIDogJ2h0bWwnLFxuICAgICAgICAgICAgcHJlOiAhbGV4ZXIub3B0aW9ucy5zYW5pdGl6ZXIgJiYgKGNhcFsxXSA9PT0gJ3ByZScgfHwgY2FwWzFdID09PSAnc2NyaXB0JyB8fCBjYXBbMV0gPT09ICdzdHlsZScpLFxuICAgICAgICAgICAgdGV4dDogY2FwWzBdLCBcbiAgICAgICAgICAgIG9mZnNldDogbGV4ZXIucmF3Lmxlbmd0aCAtIHNyYy5sZW5ndGgsIFxuICAgICAgICAgICAgbGVuZ3RoOiBjYXBbMF0ubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge21hdGNoOiB0cnVlLCBncm91cDogY2FwWzBdfTtcbiAgICB9LCBcbiAgICByZW5kZXI6IGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgICB2YXIgaHRtbCA9ICFwYXJzZXIudG9rZW4ucHJlICYmICFwYXJzZXIub3B0aW9ucy5wZWRhbnRpY1xuICAgICAgICAgICAgICAgID8gcGFyc2VyLmlubGluZS5vdXRwdXQocGFyc2VyLnRva2VuLnRleHQpXG4gICAgICAgICAgICAgICAgOiBwYXJzZXIudG9rZW4udGV4dDtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5yZW5kZXJlci5odG1sKGh0bWwpO1xuICAgIH1cbn07XG5iZ3MucHVzaChiZ20uaHRtbCk7XG5icmVuZGVyc1snaHRtbCddID0gYmdtLmh0bWwucmVuZGVyO1xuXG5iZ21bJ2RlZiddID0ge1xuICAgIHBhdHRlcm46IC9eICpcXFsoW15cXF1dKylcXF06ICo8PyhbXlxccz5dKyk+Pyg/OiArW1wiKF0oW15cXG5dKylbXCIpXSk/ICooPzpcXG4rfCQpLywgXG4gICAgdGVzdDogZnVuY3Rpb24oc3JjLCBsZXhlciwgZmxhZykge1xuICAgICAgICB2YXIgYnEgPSBmbGFnLmJxO1xuICAgICAgICB2YXIgdG9wID0gZmxhZy50b3A7XG4gICAgICAgIGlmIChicSB8fCAhdG9wKSByZXR1cm4ge21hdGNoOiBmYWxzZX07XG4gICAgICAgIHZhciBjYXAgPSB0aGlzLnBhdHRlcm4uZXhlYyhzcmMpO1xuICAgICAgICBpZiAoIWNhcCkgcmV0dXJuIHttYXRjaDogZmFsc2V9O1xuICAgICAgICBsZXhlci50b2tlbnMubGlua3NbY2FwWzFdLnRvTG93ZXJDYXNlKCldID0ge1xuICAgICAgICAgICAgaHJlZjogY2FwWzJdLFxuICAgICAgICAgICAgdGl0bGU6IGNhcFszXSwgXG4gICAgICAgICAgICBvZmZzZXQ6IGxleGVyLnJhdy5sZW5ndGggLSBzcmMubGVuZ3RoLCBcbiAgICAgICAgICAgIGxlbmd0aDogY2FwWzBdLmxlbmd0aFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge21hdGNoOiB0cnVlLCBncm91cDogY2FwWzBdfTtcbiAgICB9XG59O1xuYmdzLnB1c2goYmdtLmRlZik7XG5cbmJnbVsndGFibGUnXSA9IHsgLy8gdGFibGUgKGdmbSlcbiAgICBwYXR0ZXJuOiAvXiAqXFx8KC4rKVxcbiAqXFx8KCAqWy06XStbLXwgOl0qKVxcbigoPzogKlxcfC4qKD86XFxufCQpKSopXFxuKi8sIFxuICAgIHRlc3Q6IGZ1bmN0aW9uKHNyYywgbGV4ZXIsIGZsYWcpIHtcbiAgICAgICAgdmFyIHRhYmxlcyA9IGxleGVyLm9wdGlvbnMudGFibGVzO1xuICAgICAgICB2YXIgdG9wID0gZmxhZy50b3A7XG4gICAgICAgIGlmICghdGFibGVzKSByZXR1cm4ge21hdGNoOiBmYWxzZX07XG4gICAgICAgIGlmICghdG9wKSByZXR1cm4ge21hdGNoOiBmYWxzZX07IC8vIOWmguaenOS4jeaYr+S7jnRvcCBsZXZlbOiwg+eUqO+8jOS4jeiDveeUn+aIkOihqOagvFxuICAgICAgICB2YXIgY2FwID0gdGhpcy5wYXR0ZXJuLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKCFjYXApIHJldHVybiB7bWF0Y2g6IGZhbHNlfTtcblxuXG4gICAgICAgIGl0ZW0gPSB7XG4gICAgICAgICAgICB0eXBlOiAndGFibGUnLFxuICAgICAgICAgICAgaGVhZGVyOiBjYXBbMV0ucmVwbGFjZSgvXiAqfCAqXFx8ICokL2csICcnKS5zcGxpdCgvICpcXHwgKi8pLFxuICAgICAgICAgICAgYWxpZ246IGNhcFsyXS5yZXBsYWNlKC9eICp8XFx8ICokL2csICcnKS5zcGxpdCgvICpcXHwgKi8pLFxuICAgICAgICAgICAgY2VsbHM6IGNhcFszXS5yZXBsYWNlKC8oPzogKlxcfCAqKT9cXG4kLywgJycpLnNwbGl0KCdcXG4nKSwgXG4gICAgICAgICAgICBvZmZzZXQ6IGxleGVyLnJhdy5sZW5ndGggLSBzcmMubGVuZ3RoLCBcbiAgICAgICAgICAgIGxlbmd0aDogY2FwWzBdLmxlbmd0aFxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtLmFsaWduLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoL14gKi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAncmlnaHQnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnY2VudGVyJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL14gKjotKyAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnbGVmdCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW0uY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0uY2VsbHNbaV0gPSBpdGVtLmNlbGxzW2ldXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL14gKlxcfCAqfCAqXFx8ICokL2csICcnKVxuICAgICAgICAgICAgICAgIC5zcGxpdCgvICpcXHwgKi8pO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV4ZXIudG9rZW5zLnB1c2goaXRlbSk7XG4gICAgICAgIHJldHVybiB7bWF0Y2g6IHRydWUsIGdyb3VwOiBjYXBbMF19O1xuICAgIH1cbn07XG5iZ3MucHVzaChiZ20udGFibGUpOyAvLyByZW5kZXLlkoxucHRhYmxl5piv5LiA5qC355qEXG5cbmJnbVsncGFyYWdyYXBoJ10gPSB7IC8vIHRvcC1sZXZlbCBwYXJhZ3JhcGhcbiAgICBwYXR0ZXJuOiAvXigoPzpbXlxcbl0rXFxuPyg/IWhyfGhlYWRpbmd8bGhlYWRpbmd8YmxvY2txdW90ZXx0YWd8ZGVmKSkrKVxcbiovLCBcbiAgICBnZm06IC9eLywgXG4gICAgdGVzdDogZnVuY3Rpb24oc3JjLCBsZXhlciwgZmxhZykge1xuICAgICAgICBpZiAoIWZsYWcudG9wKSByZXR1cm4ge21hdGNoOiBmYWxzZX07XG4gICAgICAgIHZhciBwID0gKGxleGVyLm9wdGlvbnMuZ2ZtKSA/IHRoaXMuZ2ZtIDogdGhpcy5wYXR0ZXJuO1xuICAgICAgICB2YXIgY2FwID0gcC5leGVjKHNyYyk7XG4gICAgICAgIGlmICghY2FwKSByZXR1cm4ge21hdGNoOiBmYWxzZX07XG4gICAgICAgIGxleGVyLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdwYXJhZ3JhcGgnLFxuICAgICAgICAgICAgdGV4dDogY2FwWzFdLmNoYXJBdChjYXBbMV0ubGVuZ3RoIC0gMSkgPT09ICdcXG4nXG4gICAgICAgICAgICAgICAgPyBjYXBbMV0uc2xpY2UoMCwgLTEpXG4gICAgICAgICAgICAgICAgOiBjYXBbMV0sIFxuICAgICAgICAgICAgb2Zmc2V0OiBsZXhlci5yYXcubGVuZ3RoIC0gc3JjLmxlbmd0aCwgXG4gICAgICAgICAgICBsZW5ndGg6IGNhcFswXS5sZW5ndGhcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7bWF0Y2g6IHRydWUsIGdyb3VwOiBjYXBbMF19O1xuICAgIH0sIFxuICAgIHJlbmRlcjogZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICAgIHJldHVybiBwYXJzZXIucmVuZGVyZXIucGFyYWdyYXBoKHBhcnNlci5pbmxpbmUub3V0cHV0KHBhcnNlci50b2tlbi50ZXh0KSk7XG4gICAgfVxufTtcbmJncy5wdXNoKGJnbS5wYXJhZ3JhcGgpO1xuYnJlbmRlcnNbJ3BhcmFncmFwaCddID0gYmdtLnBhcmFncmFwaC5yZW5kZXI7XG5cbmJnbVsndGV4dCddID0ge1xuICAgIHBhdHRlcm46IC9eW15cXG5dKy8sIFxuICAgIHRlc3Q6IGZ1bmN0aW9uKHNyYywgbGV4ZXIpIHtcbiAgICAgICAgLy8gVG9wLWxldmVsIHNob3VsZCBuZXZlciByZWFjaCBoZXJlLlxuICAgICAgICB2YXIgY2FwID0gdGhpcy5wYXR0ZXJuLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKCFjYXApIHJldHVybiB7bWF0Y2g6IGZhbHNlfTtcbiAgICAgICAgbGV4ZXIudG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgdGV4dDogY2FwWzBdLCBcbiAgICAgICAgICAgIG9mZnNldDogbGV4ZXIucmF3Lmxlbmd0aCAtIHNyYy5sZW5ndGgsIFxuICAgICAgICAgICAgbGVuZ3RoOiBjYXBbMF0ubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge21hdGNoOiB0cnVlLCBncm91cDogY2FwWzBdfTtcbiAgICB9LCBcbiAgICByZW5kZXI6IGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgICByZXR1cm4gcGFyc2VyLnJlbmRlcmVyLnBhcmFncmFwaChwYXJzZXIucGFyc2VUZXh0KCkpO1xuICAgIH1cbn07XG5iZ3MucHVzaChiZ20udGV4dCk7XG5icmVuZGVyc1sndGV4dCddID0gYmdtLnRleHQucmVuZGVyO1xuXG5cbmJnbS5ibG9ja3F1b3RlLnBhdHRlcm4gPSByZXBsYWNlKGJnbS5ibG9ja3F1b3RlLnBhdHRlcm4pXG4gICAgKCdkZWYnLCBiZ20uZGVmLnBhdHRlcm4pXG4gICAgKCk7XG5iZ20ubGlzdC5wYXR0ZXJuID0gcmVwbGFjZShiZ20ubGlzdC5wYXR0ZXJuKVxuICAgICgvYnVsbC9nLCBiZ20uX2J1bGxldClcbiAgICAoJ2hyJywgJ1xcXFxuKyg/PVxcXFwxPyg/OlstKl9dICopezMsfSg/OlxcXFxuK3wkKSknKVxuICAgICgnZGVmJywgJ1xcXFxuKyg/PScgKyBiZ20uZGVmLnBhdHRlcm4uc291cmNlICsgJyknKVxuICAgICgpO1xuYmdtLmxpc3QuaXRlbSA9IHJlcGxhY2UoYmdtLmxpc3QuaXRlbSwgJ2dtJylcbiAgICAoL2J1bGwvZywgYmdtLl9idWxsZXQpXG4gICAgKCk7XG5iZ20uaHRtbC5wYXR0ZXJuID0gcmVwbGFjZShiZ20uaHRtbC5wYXR0ZXJuKVxuICAgICgnY29tbWVudCcsIC88IS0tW1xcc1xcU10qPy0tPi8pXG4gICAgKCdjbG9zZWQnLCAvPCh0YWcpW1xcc1xcU10rPzxcXC9cXDE+LylcbiAgICAoJ2Nsb3NpbmcnLCAvPHRhZyg/OlwiW15cIl0qXCJ8J1teJ10qJ3xbXidcIj5dKSo/Pi8pXG4gICAgKC90YWcvZywgYmdtLl9fdGFnKVxuICAgICgpO1xuYmdtLnBhcmFncmFwaC5wYXR0ZXJuID0gcmVwbGFjZShiZ20ucGFyYWdyYXBoLnBhdHRlcm4pXG4gICAgKCdocicsIGJnbS5oci5wYXR0ZXJuKVxuICAgICgnaGVhZGluZycsIGJnbS5oZWFkaW5nLnBhdHRlcm4pXG4gICAgKCdsaGVhZGluZycsIGJnbS5saGVhZGluZy5wYXR0ZXJuKVxuICAgICgnYmxvY2txdW90ZScsIGJnbS5ibG9ja3F1b3RlLnBhdHRlcm4pXG4gICAgKCd0YWcnLCAnPCcgKyBiZ20uX190YWcpXG4gICAgKCdkZWYnLCBiZ20uZGVmLnBhdHRlcm4pXG4gICAgKCk7XG5iZ20ucGFyYWdyYXBoLmdmbSA9IHJlcGxhY2UoYmdtLnBhcmFncmFwaC5wYXR0ZXJuKVxuICAgICgnKD8hJywgJyg/ISdcbiAgICArIGJnbS5mZW5jZXMucGF0dGVybi5zb3VyY2UucmVwbGFjZSgnXFxcXDEnLCAnXFxcXDInKSArICd8J1xuICAgICsgYmdtLmxpc3QucGF0dGVybi5zb3VyY2UucmVwbGFjZSgnXFxcXDEnLCAnXFxcXDMnKSArICd8JylcbiAgICAoKTtcblxuXG4vKipcbiAqIEJsb2NrIExleGVyXG4gKi9cbmZ1bmN0aW9uIExleGVyKG9wdGlvbnMpIHtcbiAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgIHRoaXMudG9rZW5zLmxpbmtzID0ge307XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBtYXJrZWQuZGVmYXVsdHM7XG4gICAgdGhpcy5yYXcgPSAnJztcbn1cblxuLyoqXG4gKiBTdGF0aWMgTGV4IE1ldGhvZFxuICovXG5MZXhlci5sZXggPSBmdW5jdGlvbihzcmMsIG9wdGlvbnMpIHtcbiAgICB2YXIgbGV4ZXIgPSBuZXcgTGV4ZXIob3B0aW9ucyk7XG4gICAgbGV4ZXIucmF3ID0gc3JjO1xuICAgIHJldHVybiBsZXhlci5sZXgoc3JjKTtcbn07XG5cbi8qKlxuICogUHJlcHJvY2Vzc2luZ1xuICovXG5MZXhlci5wcm90b3R5cGUubGV4ID0gZnVuY3Rpb24oc3JjKSB7XG4gICAgc3JjID0gc3JjXG4gICAgICAgIC5yZXBsYWNlKC9cXHJcXG58XFxyL2csICdcXG4nKVxuICAgICAgICAucmVwbGFjZSgvXFx0L2csICcgICAgJylcbiAgICAgICAgLnJlcGxhY2UoL1xcdTAwYTAvZywgJyAnKVxuICAgICAgICAucmVwbGFjZSgvXFx1MjQyNC9nLCAnXFxuJyk7XG5cbiAgcmV0dXJuIHRoaXMudG9rZW4oc3JjLCB0cnVlKTtcbn07XG5cbi8qKlxuICogTGV4aW5nXG4gKi9cbkxleGVyLnByb3RvdHlwZS50b2tlbiA9IGZ1bmN0aW9uKHNyYywgdG9wLCBicSkge1xuICAgIHZhciBzcmMgPSBzcmMucmVwbGFjZSgvXiArJC9nbSwgJycpO1xuXG4gICAgdmFyIGZsYWcgPSB7XG4gICAgICAgIHRvcDogdG9wLCBcbiAgICAgICAgYnE6IGJxXG4gICAgfVxuXG4gICAgd2hpbGUgKHNyYykge1xuICAgICAgICB2YXIgbG9vcCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBiZ3MubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYmxvY2tHcmFtbWFyID0gYmdzW2ldO1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gYmxvY2tHcmFtbWFyLnRlc3Qoc3JjLCB0aGlzLCBmbGFnKTtcbiAgICAgICAgICAgIGlmIChlbnRyeS5tYXRjaCkge1xuICAgICAgICAgICAgICAgIGxvb3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoZW50cnkuZ3JvdXAubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobG9vcCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmZpbml0ZSBsb29wIG9uIGJ5dGU6ICcgKyBzcmMuY2hhckNvZGVBdCgwKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudG9rZW5zO1xufTtcblxuLyoqXG4gKiBJbmxpbmUtTGV2ZWwgR3JhbW1hclxuICovXG52YXIgaWdzID0gbmV3IEFycmF5KCk7IC8vIElubGluZUdyYW1tYXJzXG52YXIgaWdtID0geyAvLyBJbmxpbmVHcmFtbWFyc01hcFxuICAgIF9pbnNpZGU6IC8oPzpcXFtbXlxcXV0qXFxdfFteXFxbXFxdXXxcXF0oPz1bXlxcW10qXFxdKSkqLyxcbiAgICBfaHJlZjogL1xccyo8PyhbXFxzXFxTXSo/KT4/KD86XFxzK1snXCJdKFtcXHNcXFNdKj8pWydcIl0pP1xccyovXG59O1xuXG5pZ21bJ2VzY2FwZSddID0geyAgLy8g5Y+W5raI6L2s5LmJXG4gICAgcGF0dGVybjogL15cXFxcKFtcXFxcYCp7fVxcW1xcXSgpIytcXC0uIV88Pl0pLywgXG4gICAgZ2ZtOiAvXi8sXG4gICAgdGVzdDogZnVuY3Rpb24oc3JjLCBsZXhlcikge1xuICAgICAgICB2YXIgb3B0cyA9IGxleGVyLm9wdGlvbnM7XG4gICAgICAgIHZhciBwID0gb3B0cy5nZm0gPyB0aGlzLmdmbSA6IHRoaXMucGF0dGVybjtcbiAgICAgICAgdmFyIGNhcCA9IHAuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoIWNhcCkgcmV0dXJuIHttYXRjaDogZmFsc2V9O1xuICAgICAgICByZXR1cm4ge21hdGNoOiB0cnVlLCBncm91cDogY2FwWzBdLCBvdXQ6IGVzY2FwZShjYXBbMV0pfTtcbiAgICB9XG59O1xuaWdzLnB1c2goaWdtWydlc2NhcGUnXSk7XG5cbmlnbVsna2F0ZXgnXSA9IHtcbiAgICBwYXR0ZXJuOiAvXmBcXCQoW15cXCRdKylcXCRgLywgXG4gICAgdGVzdDogZnVuY3Rpb24oc3JjLCBsZXhlcikge1xuICAgICAgICB2YXIgY2FwID0gdGhpcy5wYXR0ZXJuLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKCFjYXApIHJldHVybiB7bWF0Y2g6IGZhbHNlfTtcbiAgICAgICAgdmFyIG91dCA9IGxleGVyLnJlbmRlcmVyLmthdGV4KGNhcFsxXSk7XG4gICAgICAgIHJldHVybiB7bWF0Y2g6IHRydWUsIGdyb3VwOiBjYXBbMF0sIG91dDogb3V0fTtcbiAgICB9XG59O1xuaWdzLnB1c2goaWdtWydrYXRleCddKTtcblxuaWdtWydhdXRvbGluayddID0ge1xuICAgIHBhdHRlcm46IC9ePChbXiA+XSsoQHw6XFwvKVteID5dKyk+LywgXG4gICAgdGVzdDogZnVuY3Rpb24oc3JjLCBsZXhlcikge1xuICAgICAgICB2YXIgb3B0cyA9IGxleGVyLm9wdGlvbnM7XG4gICAgICAgIHZhciBsb2NhbE1hbmdsZSA9IG9wdHMubWFuZ2xlID8gbWFuZ2xlIDogZnVuY3Rpb24odGV4dCkge3JldHVybiB0ZXh0O31cbiAgICAgICAgdmFyIGNhcCA9IHRoaXMucGF0dGVybi5leGVjKHNyYyk7XG4gICAgICAgIGlmICghY2FwKSByZXR1cm4ge21hdGNoOiBmYWxzZX07XG4gICAgICAgIGlmIChjYXBbMl0gPT09ICdAJykge1xuICAgICAgICAgICAgdGV4dCA9IGNhcFsxXS5jaGFyQXQoNikgPT09ICc6J1xuICAgICAgICAgICAgICAgID8gbG9jYWxNYW5nbGUoY2FwWzFdLnN1YnN0cmluZyg3KSlcbiAgICAgICAgICAgICAgICA6IGxvY2FsTWFuZ2xlKGNhcFsxXSk7XG4gICAgICAgICAgICBocmVmID0gbG9jYWxNYW5nbGUoJ21haWx0bzonKSArIHRleHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0ID0gZXNjYXBlKGNhcFsxXSk7XG4gICAgICAgICAgICBocmVmID0gdGV4dDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0ID0gbGV4ZXIucmVuZGVyZXIubGluayhocmVmLCBudWxsLCB0ZXh0LCBvcHRzKTtcbiAgICAgICAgcmV0dXJuIHttYXRjaDogdHJ1ZSwgZ3JvdXA6IGNhcFswXSwgb3V0OiBvdXR9O1xuICAgIH1cbn07XG5pZ3MucHVzaChpZ21bJ2F1dG9saW5rJ10pO1xuXG5pZ21bJ3VybCddID0geyAvLyBnZm1cbiAgICBwYXR0ZXJuOiAvXihodHRwcz86XFwvXFwvW15cXHM8XStbXjwuLDo7XCInKVxcXVxcc10pLywgXG4gICAgdGVzdDogZnVuY3Rpb24oc3JjLCBsZXhlcikge1xuICAgICAgICB2YXIgb3B0cyA9IGxleGVyLm9wdGlvbnM7XG4gICAgICAgIGlmIChsZXhlci5pbmxpbmsgfHwgIW9wdHMuZ2ZtKSByZXR1cm4ge21hdGNoOiBmYWxzZX07XG4gICAgICAgIHZhciBjYXAgPSB0aGlzLnBhdHRlcm4uZXhlYyhzcmMpO1xuICAgICAgICBpZiAoIWNhcCkgcmV0dXJuIHttYXRjaDogZmFsc2V9O1xuICAgICAgICB2YXIgdGV4dCA9IGVzY2FwZShjYXBbMV0pO1xuICAgICAgICB2YXIgaHJlZiA9IHRleHQ7XG4gICAgICAgIHZhciBvdXQgPSBsZXhlci5yZW5kZXJlci5saW5rKGhyZWYsIG51bGwsIHRleHQsIG9wdHMpO1xuICAgICAgICByZXR1cm4ge21hdGNoOiB0cnVlLCBncm91cDogY2FwWzBdLCBvdXQ6IG91dH07XG4gICAgfVxufTtcbmlncy5wdXNoKGlnbVsndXJsJ10pO1xuXG5pZ21bJ3RhZyddID0ge1xuICAgIHBhdHRlcm46IC9ePCEtLVtcXHNcXFNdKj8tLT58XjxcXC8/XFx3Kyg/OlwiW15cIl0qXCJ8J1teJ10qJ3xbXidcIj5dKSo/Pi8sIFxuICAgIHRlc3Q6IGZ1bmN0aW9uKHNyYywgbGV4ZXIpIHtcbiAgICAgICAgdmFyIG9wdHMgPSBsZXhlci5vcHRpb25zO1xuICAgICAgICB2YXIgY2FwID0gdGhpcy5wYXR0ZXJuLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKCFjYXApIHJldHVybiB7bWF0Y2g6IGZhbHNlfTtcbiAgICAgICAgaWYgKCFsZXhlci5pbmxpbmsgJiYgL148YSAvaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgICAgIGxleGVyLmlubGluayA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAobGV4ZXIuaW5saW5rICYmIC9ePFxcL2E+L2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgICBsZXhlci5pbmxpbmsgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBvdXQgPSBvcHRzLnNhbml0aXplIFxuICAgICAgICAgICAgICAgID8gb3B0cy5zYW5pdGl6ZXJcbiAgICAgICAgICAgICAgICAgICAgPyBvcHRzLnNhbml0aXplcihjYXBbMF0pXG4gICAgICAgICAgICAgICAgICAgIDogZXNjYXBlKGNhcFswXSlcbiAgICAgICAgICAgICAgICA6IGNhcFswXTtcbiAgICAgICAgcmV0dXJuIHttYXRjaDogdHJ1ZSwgZ3JvdXA6IGNhcFswXSwgb3V0OiBvdXR9O1xuICAgIH1cbn07XG5pZ3MucHVzaChpZ21bJ3RhZyddKTtcblxuaWdtWydsaW5rJ10gPSB7XG4gICAgcGF0dGVybjogL14hP1xcWyhpbnNpZGUpXFxdXFwoaHJlZlxcKS8sIFxuICAgIHRlc3Q6IGZ1bmN0aW9uKHNyYywgbGV4ZXIpIHtcbiAgICAgICAgdmFyIGNhcCA9IHRoaXMucGF0dGVybi5leGVjKHNyYyk7XG4gICAgICAgIGlmICghY2FwKSByZXR1cm4ge21hdGNoOiBmYWxzZX07XG4gICAgICAgIGxleGVyLmlubGluayA9IHRydWU7XG4gICAgICAgIG91dCA9IGxleGVyLm91dHB1dExpbmsoY2FwLCB7XG4gICAgICAgICAgICBocmVmOiBjYXBbMl0sXG4gICAgICAgICAgICB0aXRsZTogY2FwWzNdXG4gICAgICAgIH0pO1xuICAgICAgICBsZXhlci5pbmxpbmsgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHttYXRjaDogdHJ1ZSwgZ3JvdXA6IGNhcFswXSwgb3V0OiBvdXR9O1xuICAgIH1cbn07XG5pZ3MucHVzaChpZ21bJ2xpbmsnXSk7XG5cbmlnbVsncmVmbGluayddID0geyAvLyByZWZsaW5rLCBub2xpbmtcbiAgICByZWY6IC9eIT9cXFsoaW5zaWRlKVxcXVxccypcXFsoW15cXF1dKilcXF0vLCBcbiAgICBubzogL14hP1xcWygoPzpcXFtbXlxcXV0qXFxdfFteXFxbXFxdXSkqKVxcXS8sIFxuICAgIHRlc3Q6IGZ1bmN0aW9uKHNyYywgbGV4ZXIpIHtcbiAgICAgICAgdmFyIGNhcCA9IHRoaXMucmVmLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKCFjYXApIHtcbiAgICAgICAgICAgIGNhcCA9IHRoaXMubm8uZXhlYyhzcmMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2FwKSByZXR1cm4ge21hdGNoOiBmYWxzZX07XG4gICAgICAgIHZhciBsaW5rID0gKGNhcFsyXSB8fCBjYXBbMV0pLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICAgICAgdmFyIGxpbmsgPSBsZXhlci5saW5rc1tsaW5rLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICBpZiAoIWxpbmsgfHwgIWxpbmsuaHJlZikge1xuICAgICAgICAgICAgdmFyIG91dCA9IGNhcFswXS5jaGFyQXQoMCk7XG4gICAgICAgICAgICByZXR1cm4ge21hdGNoOiB0cnVlLCBncm91cDogY2FwWzBdLmNoYXJBdCgwKSwgb3V0OiBvdXR9O1xuICAgICAgICB9XG4gICAgICAgIGxleGVyLmlubGluayA9IHRydWU7XG4gICAgICAgIHZhciBvdXQgPSBsZXhlci5vdXRwdXRMaW5rKGNhcCwgbGluayk7XG4gICAgICAgIGxleGVyLmlubGluayA9IGZhbHNlO1xuICAgICAgICByZXR1cm4ge21hdGNoOiB0cnVlLCBncm91cDogY2FwWzBdLCBvdXQ6IG91dH07XG4gICAgfVxufTtcbmlncy5wdXNoKGlnbVsncmVmbGluayddKTtcblxuaWdtWydzdHJvbmcnXSA9IHtcbiAgICBwYXR0ZXJuOiAvXl9fKFtcXHNcXFNdKz8pX18oPyFfKXxeXFwqXFwqKFtcXHNcXFNdKz8pXFwqXFwqKD8hXFwqKS8sIFxuICAgIHBlZGFudGljOiAvXl9fKD89XFxTKShbXFxzXFxTXSo/XFxTKV9fKD8hXyl8XlxcKlxcKig/PVxcUykoW1xcc1xcU10qP1xcUylcXCpcXCooPyFcXCopLywgXG4gICAgdGVzdDogZnVuY3Rpb24oc3JjLCBsZXhlcikge1xuICAgICAgICB2YXIgcCA9IGxleGVyLm9wdGlvbnMucGVkYW50aWMgPyB0aGlzLnBlZGFudGljIDogdGhpcy5wYXR0ZXJuO1xuICAgICAgICB2YXIgY2FwID0gcC5leGVjKHNyYyk7XG4gICAgICAgIGlmICghY2FwKSByZXR1cm4ge21hdGNoOiBmYWxzZX07XG4gICAgICAgIHZhciBvdXQgPSBsZXhlci5yZW5kZXJlci5zdHJvbmcobGV4ZXIub3V0cHV0KGNhcFsyXSB8fCBjYXBbMV0pKTtcbiAgICAgICAgcmV0dXJuIHttYXRjaDogdHJ1ZSwgZ3JvdXA6IGNhcFswXSwgb3V0OiBvdXR9O1xuICAgIH1cbn07XG5pZ3MucHVzaChpZ21bJ3N0cm9uZyddKTtcblxuaWdtWydtYXJrJ10gPSB7XG4gICAgcGF0dGVybjogL149PShbXFxzXFxTXSs/KT09KD8hPSkvLCBcbiAgICB0ZXN0OiBmdW5jdGlvbihzcmMsIGxleGVyKSB7XG4gICAgICAgIHZhciBjYXAgPSB0aGlzLnBhdHRlcm4uZXhlYyhzcmMpO1xuICAgICAgICBpZiAoIWNhcCkgcmV0dXJuIHttYXRjaDogZmFsc2V9O1xuICAgICAgICB2YXIgb3V0ID0gbGV4ZXIucmVuZGVyZXIubWFyayhsZXhlci5vdXRwdXQoY2FwWzFdKSk7XG4gICAgICAgIHJldHVybiB7bWF0Y2g6IHRydWUsIGdyb3VwOiBjYXBbMF0sIG91dDogb3V0fTtcbiAgICB9XG59O1xuaWdzLnB1c2goaWdtWydtYXJrJ10pO1xuXG5pZ21bJ3VuZGVybGluZSddID0ge1xuICAgIHBhdHRlcm46IC9eXFwrXFwrKFtcXHNcXFNdKz8pXFwrXFwrKD8hXFwrKS8sIFxuICAgIHRlc3Q6IGZ1bmN0aW9uKHNyYywgbGV4ZXIpIHtcbiAgICAgICAgdmFyIGNhcCA9IHRoaXMucGF0dGVybi5leGVjKHNyYyk7XG4gICAgICAgIGlmICghY2FwKSByZXR1cm4ge21hdGNoOiBmYWxzZX07XG4gICAgICAgIHZhciBvdXQgPSBsZXhlci5yZW5kZXJlci51bmRlcmxpbmUobGV4ZXIub3V0cHV0KGNhcFsxXSkpO1xuICAgICAgICByZXR1cm4ge21hdGNoOiB0cnVlLCBncm91cDogY2FwWzBdLCBvdXQ6IG91dH07XG4gICAgfVxufTtcbmlncy5wdXNoKGlnbVsndW5kZXJsaW5lJ10pO1xuXG5pZ21bJ2Vtb2ppJ10gPSB7XG4gICAgcGF0dGVybjogL146KFtcXFNdKz8pOig/ITopLywgXG4gICAgdGVzdDogZnVuY3Rpb24oc3JjLCBsZXhlcikge1xuICAgICAgICB2YXIgY2FwID0gdGhpcy5wYXR0ZXJuLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKCFjYXApIHJldHVybiB7bWF0Y2g6IGZhbHNlfTtcbiAgICAgICAgdmFyIG91dCA9IGxleGVyLnJlbmRlcmVyLmVtb2ppKGNhcFswXSk7XG4gICAgICAgIHJldHVybiB7bWF0Y2g6IHRydWUsIGdyb3VwOiBjYXBbMF0sIG91dDogb3V0fTtcbiAgICB9XG59O1xuaWdzLnB1c2goaWdtWydlbW9qaSddKTtcblxuaWdtWydlbSddID0ge1xuICAgIHBhdHRlcm46IC9eXFxiXygoPzpbXl9dfF9fKSs/KV9cXGJ8XlxcKigoPzpcXCpcXCp8W1xcc1xcU10pKz8pXFwqKD8hXFwqKS8sIFxuICAgIHBlZGFudGljOiAvXl8oPz1cXFMpKFtcXHNcXFNdKj9cXFMpXyg/IV8pfF5cXCooPz1cXFMpKFtcXHNcXFNdKj9cXFMpXFwqKD8hXFwqKS8sIFxuICAgIHRlc3Q6IGZ1bmN0aW9uKHNyYywgbGV4ZXIpIHtcbiAgICAgICAgdmFyIHAgPSBsZXhlci5vcHRpb25zLnBlZGFudGljID8gdGhpcy5wZWRhbnRpYyA6IHRoaXMucGF0dGVybjtcbiAgICAgICAgdmFyIGNhcCA9IHAuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoIWNhcCkgcmV0dXJuIHttYXRjaDogZmFsc2V9O1xuICAgICAgICB2YXIgb3V0ID0gbGV4ZXIucmVuZGVyZXIuZW0obGV4ZXIub3V0cHV0KGNhcFsyXSB8fCBjYXBbMV0pKTtcbiAgICAgICAgcmV0dXJuIHttYXRjaDogdHJ1ZSwgZ3JvdXA6IGNhcFswXSwgb3V0OiBvdXR9O1xuICAgIH1cbn07XG5pZ3MucHVzaChpZ21bJ2VtJ10pO1xuXG5pZ21bJ2NvZGUnXSA9IHtcbiAgICBwYXR0ZXJuOiAvXihgKylcXHMqKFtcXHNcXFNdKj9bXmBdKVxccypcXDEoPyFgKS8sIFxuICAgIHRlc3Q6IGZ1bmN0aW9uKHNyYywgbGV4ZXIpIHtcbiAgICAgICAgdmFyIGNhcCA9IHRoaXMucGF0dGVybi5leGVjKHNyYyk7XG4gICAgICAgIGlmICghY2FwKSByZXR1cm4ge21hdGNoOiBmYWxzZX07XG4gICAgICAgIHZhciBvdXQgPSBsZXhlci5yZW5kZXJlci5jb2Rlc3Bhbihlc2NhcGUoY2FwWzJdLCB0cnVlKSk7XG4gICAgICAgIHJldHVybiB7bWF0Y2g6IHRydWUsIGdyb3VwOiBjYXBbMF0sIG91dDogb3V0fTtcbiAgICB9XG59O1xuaWdzLnB1c2goaWdtWydjb2RlJ10pO1xuXG5pZ21bJ2JyJ10gPSB7XG4gICAgcGF0dGVybjogL14oYCspXFxzKihbXFxzXFxTXSo/W15gXSlcXHMqXFwxKD8hYCkvLCBcbiAgICBicmVha3M6IC9eLywgXG4gICAgdGVzdDogZnVuY3Rpb24oc3JjLCBsZXhlcikge1xuICAgICAgICB2YXIgcCA9IGxleGVyLm9wdGlvbnMuYnJlYWtzID8gdGhpcy5icmVha3MgOiB0aGlzLnBhdHRlcm47XG4gICAgICAgIHZhciBjYXAgPSBwLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKCFjYXApIHJldHVybiB7bWF0Y2g6IGZhbHNlfTtcbiAgICAgICAgdmFyIG91dCA9IGxleGVyLnJlbmRlcmVyLmJyKGxleGVyLm9wdGlvbnMpO1xuICAgICAgICByZXR1cm4ge21hdGNoOiB0cnVlLCBncm91cDogY2FwWzBdLCBvdXQ6IG91dH07XG4gICAgfVxufTtcbmlncy5wdXNoKGlnbVsnYnInXSk7XG5cbmlnbVsnZGVsJ10gPSB7XG4gICAgZ2ZtOiAvXn5+KD89XFxTKShbXFxzXFxTXSo/XFxTKX5+LywgXG4gICAgdGVzdDogZnVuY3Rpb24oc3JjLCBsZXhlcikge1xuICAgICAgICB2YXIgY2FwID0gdGhpcy5nZm0uZXhlYyhzcmMpO1xuICAgICAgICBpZiAoIWNhcCkgcmV0dXJuIHttYXRjaDogZmFsc2V9O1xuICAgICAgICB2YXIgb3V0ID0gbGV4ZXIucmVuZGVyZXIuZGVsKGxleGVyLm91dHB1dChjYXBbMV0pKTtcbiAgICAgICAgcmV0dXJuIHttYXRjaDogdHJ1ZSwgZ3JvdXA6IGNhcFswXSwgb3V0OiBvdXR9O1xuICAgIH1cbn07XG5pZ3MucHVzaChpZ21bJ2RlbCddKTtcblxuaWdtWyd0ZXh0J10gPSB7XG4gICAgcGF0dGVybjogL15bXFxzXFxTXSs/KD89W1xcXFw6PCFcXH49W18qYF18IHsyLH1cXG58JCkvLCBcbiAgICBnZm06IC9eLyxcbiAgICBicmVha3M6IC9eLywgXG4gICAgdGVzdDogZnVuY3Rpb24oc3JjLCBsZXhlcikge1xuICAgICAgICB2YXIgcCA9IGxleGVyLm9wdGlvbnMuYnJlYWtzID8gdGhpcy5icmVha3MgOiB0aGlzLnBhdHRlcm47XG4gICAgICAgIHZhciBjYXAgPSBwLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKCFjYXApIHJldHVybiB7bWF0Y2g6IGZhbHNlfTtcbiAgICAgICAgdmFyIG91dCA9IGxleGVyLnJlbmRlcmVyLnRleHQoZXNjYXBlKGxleGVyLnNtYXJ0eXBhbnRzKGNhcFswXSkpKTtcbiAgICAgICAgcmV0dXJuIHttYXRjaDogdHJ1ZSwgZ3JvdXA6IGNhcFswXSwgb3V0OiBvdXR9O1xuICAgIH1cbn07XG5pZ3MucHVzaChpZ21bJ3RleHQnXSk7XG5cbmlnbS5lc2NhcGUuZ2ZtID0gcmVwbGFjZShpZ20uZXNjYXBlLnBhdHRlcm4pXG4gICAgKCddKScsICd+fF0pJylcbiAgICAoKTtcbmlnbS5saW5rLnBhdHRlcm4gPSByZXBsYWNlKGlnbS5saW5rLnBhdHRlcm4pXG4gICAgKCdpbnNpZGUnLCBpZ20uX2luc2lkZSlcbiAgICAoJ2hyZWYnLCBpZ20uX2hyZWYpXG4gICAgKCk7XG5pZ20ucmVmbGluay5yZWYgPSByZXBsYWNlKGlnbS5yZWZsaW5rLnJlZilcbiAgICAoJ2luc2lkZScsIGlnbS5faW5zaWRlKVxuICAgICgpO1xuaWdtLmJyLmJyZWFrcyA9IHJlcGxhY2UoaWdtLmJyLnBhdHRlcm4pXG4gICAgKCd7Mix9JywgJyonKVxuICAgICgpO1xuaWdtLnRleHQuZ2ZtID0gcmVwbGFjZShpZ20udGV4dC5wYXR0ZXJuKVxuICAgICgnXXwnLCAnfl18JylcbiAgICAoJ3wnLCAnfGh0dHBzPzovL3wnKVxuICAgICgpO1xuaWdtLnRleHQuYnJlYWtzID0gcmVwbGFjZShpZ20udGV4dC5nZm0pXG4gICAgKCd7Mix9JywgJyonKVxuICAgICgpO1xuXG5cbi8qKlxuICogSW5saW5lIExleGVyICYgQ29tcGlsZXJcbiAqL1xuZnVuY3Rpb24gSW5saW5lTGV4ZXIobGlua3MsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IG1hcmtlZC5kZWZhdWx0cztcbiAgICB0aGlzLmxpbmtzID0gbGlua3M7XG4gICAgdGhpcy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCBuZXcgUmVuZGVyZXI7XG5cbiAgICBpZiAoIXRoaXMubGlua3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb2tlbnMgYXJyYXkgcmVxdWlyZXMgYSBgbGlua3NgIHByb3BlcnR5LicpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBTdGF0aWMgTGV4aW5nL0NvbXBpbGluZyBNZXRob2RcbiAqL1xuSW5saW5lTGV4ZXIub3V0cHV0ID0gZnVuY3Rpb24oc3JjLCBsaW5rcywgb3B0aW9ucykge1xuICAgIHZhciBpbmxpbmUgPSBuZXcgSW5saW5lTGV4ZXIobGlua3MsIG9wdGlvbnMpO1xuICAgIHJldHVybiBpbmxpbmUub3V0cHV0KHNyYyk7XG59O1xuXG4vKipcbiAqIExleGluZy9Db21waWxpbmdcbiAqL1xuSW5saW5lTGV4ZXIucHJvdG90eXBlLm91dHB1dCA9IGZ1bmN0aW9uKHNyYykge1xuICAgIHZhciBvdXQgPSAnJztcblxuICAgIHdoaWxlIChzcmMpIHtcbiAgICAgICAgdmFyIGxvb3AgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgaWdzLmxlbmd0aCA7IGkrKykge1xuICAgICAgICAgICAgdmFyIGlubGluZUdyYW1tYXIgPSBpZ3NbaV07XG4gICAgICAgICAgICB2YXIgZW50cnkgPSBpbmxpbmVHcmFtbWFyLnRlc3Qoc3JjLCB0aGlzKTtcbiAgICAgICAgICAgIGlmIChlbnRyeS5vdXQpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gZW50cnkub3V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudHJ5Lm1hdGNoKSB7XG4gICAgICAgICAgICAgICAgbG9vcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhlbnRyeS5ncm91cC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsb29wKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5maW5pdGUgbG9vcCBvbiBieXRlOiAnICsgc3JjLmNoYXJDb2RlQXQoMCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvbXBpbGUgTGlua1xuICovXG5cbklubGluZUxleGVyLnByb3RvdHlwZS5vdXRwdXRMaW5rID0gZnVuY3Rpb24oY2FwLCBsaW5rKSB7XG4gICAgdmFyIGhyZWYgPSBlc2NhcGUobGluay5ocmVmKVxuICAgICAgICAsIHRpdGxlID0gbGluay50aXRsZSA/IGVzY2FwZShsaW5rLnRpdGxlKSA6IG51bGw7XG5cbiAgICByZXR1cm4gY2FwWzBdLmNoYXJBdCgwKSAhPT0gJyEnXG4gICAgICAgID8gdGhpcy5yZW5kZXJlci5saW5rKGhyZWYsIHRpdGxlLCB0aGlzLm91dHB1dChjYXBbMV0pLCB0aGlzLm9wdGlvbnMpXG4gICAgICAgIDogdGhpcy5yZW5kZXJlci5pbWFnZShocmVmLCB0aXRsZSwgZXNjYXBlKGNhcFsxXSkpO1xufTtcblxuLyoqXG4gKiBTbWFydHlwYW50cyBUcmFuc2Zvcm1hdGlvbnNcbiAqL1xuXG5JbmxpbmVMZXhlci5wcm90b3R5cGUuc21hcnR5cGFudHMgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc21hcnR5cGFudHMpIHJldHVybiB0ZXh0O1xuICAgIHJldHVybiB0ZXh0XG4gICAgICAgIC8vIGVtLWRhc2hlc1xuICAgICAgICAucmVwbGFjZSgvLS0tL2csICdcXHUyMDE0JylcbiAgICAgICAgLy8gZW4tZGFzaGVzXG4gICAgICAgIC5yZXBsYWNlKC8tLS9nLCAnXFx1MjAxMycpXG4gICAgICAgIC8vIG9wZW5pbmcgc2luZ2xlc1xuICAgICAgICAucmVwbGFjZSgvKF58Wy1cXHUyMDE0LyhcXFt7XCJcXHNdKScvZywgJyQxXFx1MjAxOCcpXG4gICAgICAgIC8vIGNsb3Npbmcgc2luZ2xlcyAmIGFwb3N0cm9waGVzXG4gICAgICAgIC5yZXBsYWNlKC8nL2csICdcXHUyMDE5JylcbiAgICAgICAgLy8gb3BlbmluZyBkb3VibGVzXG4gICAgICAgIC5yZXBsYWNlKC8oXnxbLVxcdTIwMTQvKFxcW3tcXHUyMDE4XFxzXSlcIi9nLCAnJDFcXHUyMDFjJylcbiAgICAgICAgLy8gY2xvc2luZyBkb3VibGVzXG4gICAgICAgIC5yZXBsYWNlKC9cIi9nLCAnXFx1MjAxZCcpXG4gICAgICAgIC8vIGVsbGlwc2VzXG4gICAgICAgIC5yZXBsYWNlKC9cXC57M30vZywgJ1xcdTIwMjYnKTtcbn07XG5cbi8qKlxuICogUmVuZGVyZXJcbiAqL1xuZnVuY3Rpb24gUmVuZGVyZXIob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG59XG5cblJlbmRlcmVyLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnJztcbn1cblxuUmVuZGVyZXIucHJvdG90eXBlLmNvZGUgPSBmdW5jdGlvbihjb2RlLCBsYW5nLCBlc2NhcGVkKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5oaWdobGlnaHQpIHtcbiAgICAgICAgdmFyIG91dCA9IG9wdHMuaGlnaGxpZ2h0KGNvZGUsIGxhbmcpO1xuICAgICAgICBpZiAob3V0ICE9IG51bGwgJiYgb3V0ICE9PSBjb2RlKSB7XG4gICAgICAgICAgICBlc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvZGUgPSBvdXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb2RlID0gKGVzY2FwZWQgPyBjb2RlIDogZXNjYXBlKGNvZGUsIHRydWUpKTtcbiAgICBpZiAoIWxhbmcpIHtcbiAgICAgICAgcmV0dXJuIGA8cHJlPjxjb2RlPiR7Y29kZX1cXG48L2NvZGU+PC9wcmU+YDtcbiAgICB9XG5cbiAgICB2YXIgY2xhc3NQcmVmaXggPSB0aGlzLm9wdGlvbnMubGFuZ1ByZWZpeDtcbiAgICByZXR1cm4gc3RyaW5nZm9ybWF0KCc8cHJlPjxjb2RlIGNsYXNzPVwie317fVwiPnt9XFxuPC9jb2RlPjwvcHJlPlxcbicsIGNsYXNzUHJlZml4LCBlc2NhcGUobGFuZywgdHJ1ZSksIGNvZGUpO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmJsb2NrcXVvdGUgPSBmdW5jdGlvbihxdW90ZSkge1xuICAgIHJldHVybiBzdHJpbmdmb3JtYXQoJzxibG9ja3F1b3RlPlxcbnt9PC9ibG9ja3F1b3RlPlxcbicsIHF1b3RlKTtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5odG1sID0gZnVuY3Rpb24oaHRtbCkge1xuICAgIHJldHVybiBodG1sO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmhlYWRpbmcgPSBmdW5jdGlvbih0ZXh0LCBsZXZlbCwgcmF3KSB7XG4gICAgLy8gdmFyIGhlYWRlclByZWZpeCA9IHRoaXMub3B0aW9ucy5oZWFkZXJQcmVmaXg7XG4gICAgLy8gcmV0dXJuIHN0cmluZ2Zvcm1hdCgnPGh7fSBpZD1cInt9e31cIj57fTwvaHt9PlxcbicsIGxldmVsLCBoZWFkZXJQcmVmaXgsIHJhdy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1teXFx3XSsvZywgJy0nKSwgdGV4dCwgbGV2ZWwpO1xuICAgIHJldHVybiBzdHJpbmdmb3JtYXQoJzxoe30+e308L2h7fT5cXG4nLCBsZXZlbCwgdGV4dCwgbGV2ZWwpO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmhyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy54aHRtbCA/ICc8aHIvPlxcbicgOiAnPGhyPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUubGlzdCA9IGZ1bmN0aW9uKGJvZHksIG9yZGVyZWQpIHtcbiAgICB2YXIgdHlwZSA9IG9yZGVyZWQgPyAnb2wnIDogJ3VsJztcbiAgICByZXR1cm4gc3RyaW5nZm9ybWF0KCc8e30+XFxue308L3t9PlxcbicsIHR5cGUsIGJvZHksIHR5cGUpO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmxpc3RpdGVtID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHJldHVybiBzdHJpbmdmb3JtYXQoJzxsaT57fTwvbGk+XFxuJywgdGV4dCk7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUucGFyYWdyYXBoID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHJldHVybiBzdHJpbmdmb3JtYXQoJzxwPnt9PC9wPlxcbicsIHRleHQpO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnRhYmxlID0gZnVuY3Rpb24oaGVhZGVyLCBib2R5KSB7XG4gICAgcmV0dXJuIHN0cmluZ2Zvcm1hdCgnPHRhYmxlPlxcbjx0aGVhZD5cXG57fVxcbjwvdGhlYWQ+XFxuPHRib2R5Plxcbnt9XFxuPC90Ym9keT5cXG48L3RhYmxlPlxcbicsIGhlYWRlciwgYm9keSk7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUudGFibGVyb3cgPSBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgcmV0dXJuIHN0cmluZ2Zvcm1hdCgnPHRyPlxcbnt9PC90cj5cXG4nLCBjb250ZW50KTtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS50YWJsZWNlbGwgPSBmdW5jdGlvbihjb250ZW50LCBmbGFncykge1xuICAgIHZhciB0eXBlID0gZmxhZ3MuaGVhZGVyID8gJ3RoJyA6ICd0ZCc7XG4gICAgdmFyIHRhZ1N0YXJ0ID0gZmxhZ3MuYWxpZ25cbiAgICAgICAgPyBzdHJpbmdmb3JtYXQoJzx7fSBzdHlsZT1cInRleHQtYWxpZ246e31cIj4nLCB0eXBlLCBmbGFncy5hbGlnbilcbiAgICAgICAgOiBzdHJpbmdmb3JtYXQoJzx7fT4nLCB0eXBlKTtcbiAgICB2YXIgdGFnRW5kID0gc3RyaW5nZm9ybWF0KCc8L3t9PlxcbicsIHR5cGUpO1xuICAgIHJldHVybiB0YWdTdGFydCArIGNvbnRlbnQgKyB0YWdFbmQ7XG59O1xuXG4vLyBzcGFuIGxldmVsIHJlbmRlcmVyXG5SZW5kZXJlci5wcm90b3R5cGUuc3Ryb25nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHJldHVybiBgPHN0cm9uZz4ke3RleHR9PC9zdHJvbmc+YDtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5tYXJrID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHJldHVybiBgPG1hcms+JHt0ZXh0fTwvbWFyaz5gO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnVuZGVybGluZSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICByZXR1cm4gYDx1PiR7dGV4dH08L3U+YDtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5lbW9qaSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICBjb25zb2xlLmxvZyh0ZXh0KTtcbiAgICBpZiAoZW1vamlvbmUpIHtcbiAgICAgICAgcmV0dXJuIGVtb2ppb25lLnNob3J0bmFtZVRvSW1hZ2UodGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmVtID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHJldHVybiBgPGVtPiR7dGV4dH08L2VtPmA7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuY29kZXNwYW4gPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgcmV0dXJuIGA8Y29kZT4ke3RleHR9PC9jb2RlPmA7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuYnIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnhodG1sID8gJzxici8+JyA6ICc8YnI+Jztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgcmV0dXJuIGA8ZGVsPiR7dGV4dH08L2RlbD5gO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmxpbmsgPSBmdW5jdGlvbihocmVmLCB0aXRsZSwgdGV4dCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuc2FuaXRpemUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBwcm90ID0gZGVjb2RlVVJJQ29tcG9uZW50KHVuZXNjYXBlKGhyZWYpKVxuICAgICAgICAgICAgICAucmVwbGFjZSgvW15cXHc6XS9nLCAnJylcbiAgICAgICAgICAgICAgLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdC5pbmRleE9mKCdqYXZhc2NyaXB0OicpID09PSAwIHx8IHByb3QuaW5kZXhPZigndmJzY3JpcHQ6JykgPT09IDAgfHwgcHJvdC5pbmRleE9mKCdkYXRhOicpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIG91dCA9IGA8YSBocmVmPVwiJHtocmVmfVwiYDtcbiAgICBpZiAodGl0bGUpIHtcbiAgICAgICAgb3V0ICs9IGAgdGl0bGU9XCIke3RleHR9XCJgO1xuICAgIH1cbiAgICBpZiAoL14oPyFqYXZhc2NyaXB0Onx2YnNjcmlwdDp8IykvLnRlc3QoaHJlZikpIHtcbiAgICAgICAgb3V0ICs9ICcgdGFyZ2V0PVwiX19ibGFua1wiJztcbiAgICB9XG4gICAgb3V0ICs9IGAnPiR7dGV4dH08L2E+YDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmltYWdlID0gZnVuY3Rpb24oaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgICB2YXIgc3R5bGUgPSAnJztcbiAgICB2YXIgbTsgLy8gbWF0Y2hlclxuICAgIGlmICh0aXRsZSAmJiAobSA9IC9cXC93XFwvKFteXFwvXSspLy5leGVjKHRpdGxlKSkpIHtcbiAgICAgICAgdGl0bGUgPSB0aXRsZS5yZXBsYWNlKG1bMF0sICcnKTtcbiAgICAgICAgbSA9IG1bMV07XG4gICAgICAgIHN0eWxlICs9IGB3aWR0aDogJHttfTtgO1xuICAgIH1cbiAgICBpZiAodGl0bGUgJiYgKG0gPSAvXFwvaFxcLyhbXlxcL10rKS8uZXhlYyh0aXRsZSkpKSB7XG4gICAgICAgIHRpdGxlID0gdGl0bGUucmVwbGFjZShtWzBdLCAnJyk7XG4gICAgICAgIG0gPSBtWzFdO1xuICAgICAgICBzdHlsZSArPSBgaGVpZ2h0OiAke219O2A7XG4gICAgfVxuICAgIHZhciBvdXQ7XG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICAgIG91dCA9IGA8aW1nIHNyYz1cIiR7aHJlZn1cIiBhbHQ9XCIke3RleHR9XCIgdGl0bGU9XCIke3RpdGxlfVwiIHN0eWxlPVwiJHtzdHlsZX1cImA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ID0gYDxpbWcgc3JjPVwiJHtocmVmfVwiIGFsdD1cIiR7dGV4dH1cIiBzdHlsZT1cIiR7c3R5bGV9XCJgO1xuICAgIH1cbiAgICBvdXQgKz0gdGhpcy5vcHRpb25zLnhodG1sID8gJy8+JyA6ICc+JztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQ7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuaGFuZHNlcSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgLy8gJGNvbnRhaW5lci5zZXF1ZW5jZURpYWdyYW0oe3RoZW1lOiAnaGFuZCd9KTtcbiAgICB2YXIgZCA9IERpYWdyYW0ucGFyc2UodGV4dCk7XG4gICAgdmFyIG9wdGlvbnMgPSB7dGhlbWU6ICdoYW5kJ307XG4gICAgZC5kcmF3U1ZHKGNvbnRhaW5lciwgb3B0aW9ucyk7XG4gICAgLy8g5aaC5p6c5byV55Soc25hcC5zdmctbWluLmpz77yM5aW95YOP5piv5Zyo5byC5q2l5riy5p+T77yMaW5uZXJIVE1M5Lya5Y+W5LiN5YiwXG4gICAgcmV0dXJuIHN0cmluZ2Zvcm1hdCgnPGRpdj57fTwvZGl2PicsIGNvbnRhaW5lci5pbm5lckhUTUwpO1xufVxuXG5SZW5kZXJlci5wcm90b3R5cGUuZmxvd2NoYXJ0ID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBkaWFncmFtID0gZmxvd2NoYXJ0LnBhcnNlKHRleHQpO1xuICAgICAgICAvL3ZhciAkY29udGFpbmVyID0gJCgnPGRpdiBpZD1cInptZC1pbm5lci1mbG93Y2hhcnRcIiBzdHlsZT1cImRpc3BsYXk6bm9uZTtcIj48L2Rpdj4nKTtcbiAgICAgICAgLy8kKCdib2R5JykuYXBwZW5kKCRjb250YWluZXIpO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRpYWdyYW0uZHJhd1NWRyhjb250YWluZXIsIHtcbiAgICAgICAgICAgICd4JzogMCxcbiAgICAgICAgICAgICd5JzogMCxcbiAgICAgICAgICAgICdsaW5lLXdpZHRoJzogMixcbiAgICAgICAgICAgICdsaW5lLWxlbmd0aCc6IDMwLFxuICAgICAgICAgICAgJ3RleHQtbWFyZ2luJzogMTAsXG4gICAgICAgICAgICAnZm9udC1zaXplJzogMTQsXG4gICAgICAgICAgICAnZm9udC1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICAgICAnbGluZS1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICAgICAnZWxlbWVudC1jb2xvcic6ICdyZ2IoMTA4LCAxMDgsIDEwOCknLFxuICAgICAgICAgICAgJ2ZpbGwnOiAnd2hpdGUnLFxuICAgICAgICAgICAgJ3llcy10ZXh0JzogJ3llcycsXG4gICAgICAgICAgICAnbm8tdGV4dCc6ICdubycsXG4gICAgICAgICAgICAnYXJyb3ctZW5kJzogJ2Jsb2NrJyxcbiAgICAgICAgICAgICdzY2FsZSc6IDEsXG4gICAgICAgICAgICAvLyBzdHlsZSBzeW1ib2wgdHlwZXNcbiAgICAgICAgICAgICdzeW1ib2xzJzoge1xuICAgICAgICAgICAgICAnc3RhcnQnOiB7XG4gICAgICAgICAgICAgICAgJ2ZvbnQtY29sb3InOiAncmVkJyxcbiAgICAgICAgICAgICAgICAnZWxlbWVudC1jb2xvcic6ICdyZ2IoMTA4LCAxMDgsIDEwOCknLFxuICAgICAgICAgICAgICAgICdmaWxsJzogJ3llbGxvdydcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgJ2VuZCc6e1xuICAgICAgICAgICAgICAgICdjbGFzcyc6ICdlbmQtZWxlbWVudCdcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGV2ZW4gZmxvd3N0YXRlIHN1cHBvcnQgOy0pXG4gICAgICAgICAgICAnZmxvd3N0YXRlJyA6IHtcbiAgICAgICAgICAgICAgJ3Bhc3QnIDogeyAnZmlsbCcgOiAnI0NDQ0NDQycsICdmb250LXNpemUnIDogMTJ9LFxuICAgICAgICAgICAgICAnY3VycmVudCcgOiB7J2ZpbGwnIDogJ3JnYigyMzYsIDIzNiwgMjU1KScsICdmb250LWNvbG9yJyA6ICdyZWQnLCAnZm9udC13ZWlnaHQnIDogJ2JvbGQnfSxcbiAgICAgICAgICAgICAgJ2Z1dHVyZScgOiB7ICdmaWxsJyA6ICdyZ2IoMjM2LCAyMzYsIDI1NSknfSxcbiAgICAgICAgICAgICAgJ3JlcXVlc3QnIDogeyAnZmlsbCcgOiAnYmx1ZSd9LFxuICAgICAgICAgICAgICAnaW52YWxpZCc6IHsnZmlsbCcgOiAnIzQ0NDQ0NCd9LFxuICAgICAgICAgICAgICAnYXBwcm92ZWQnIDogeyAnZmlsbCcgOiAnIzU4QzRBMycsICdmb250LXNpemUnIDogMTIsICd5ZXMtdGV4dCcgOiAnQVBQUk9WRUQnLCAnbm8tdGV4dCcgOiAnbi9hJyB9LFxuICAgICAgICAgICAgICAncmVqZWN0ZWQnIDogeyAnZmlsbCcgOiAnI0M0NTg3OScsICdmb250LXNpemUnIDogMTIsICd5ZXMtdGV4dCcgOiAnbi9hJywgJ25vLXRleHQnIDogJ1JFSkVDVEVEJyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdHJpbmdmb3JtYXQoJzxkaXY+e308L2Rpdj4nLCBjb250YWluZXIuaW5uZXJIVE1MKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbn1cblxuXG5SZW5kZXJlci5wcm90b3R5cGUua2F0ZXggPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgLy8gdmFyIGl0ZW1zID0gdGV4dC5zcGxpdCgvXFxuezIsfS8pO1xuICAgIHZhciBpdGVtcyA9IHRleHQuc3BsaXQoL1xcbnsyfS8pO1xuICAgIHZhciBvdXQgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBpdGVtcy5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG91dCArPSBrYXRleC5yZW5kZXJUb1N0cmluZyhpdGVtc1tpXSk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ3JlbmRlciBrYXRleCBlcnJvcjogJyArIGUpO1xuICAgICAgICAgICAgb3V0ICs9IGl0ZW1zW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5cblJlbmRlcmVyLnByb3RvdHlwZS5tZXJtYWlkID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuaWQgPSBcIm1lcm1haWRcIiArIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgaWYgKHR5cGVvZihtZXJtYWlkQVBJKSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHZhciBncmFwaCA9IG1lcm1haWRBUEkucmVuZGVyKGNvbnRhaW5lci5pZCwgdGV4dC50cmltKCksIGZ1bmN0aW9uKGNvZGUpIHt9KTtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2Zvcm1hdCgnPGRpdj57fTwvZGl2PicsIGdyYXBoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygncGxlYXNlIGluY2x1ZGUgbWVybWFpZEFQSS5qcycpO1xuICAgICAgICByZXR1cm4gc3RyaW5nZm9ybWF0KCc8ZGl2Pnt9PC9kaXY+JywgdGV4dCk7XG4gICAgfVxuICAgIFxufVxuXG5SZW5kZXJlci5wcm90b3R5cGUuYm9vdGFsZXJ0ID0gZnVuY3Rpb24oc3R5bGUsIHRleHQpIHtcbiAgICByZXR1cm4gc3RyaW5nZm9ybWF0KCc8ZGl2IGNsYXNzPVwiYWxlcnQgYWxlcnQte31cIj57fTwvZGl2PicsIHN0eWxlLCB0ZXh0KTtcbn1cblxuLyoqXG4gKiBQYXJzaW5nICYgQ29tcGlsaW5nXG4gKi9cblxuZnVuY3Rpb24gUGFyc2VyKG9wdGlvbnMpIHtcbiAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgIHRoaXMudG9rZW4gPSBudWxsO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgbWFya2VkLmRlZmF1bHRzO1xuICAgIHRoaXMub3B0aW9ucy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCBuZXcgUmVuZGVyZXI7XG4gICAgdGhpcy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlcjtcbiAgICB0aGlzLnJlbmRlcmVyLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG59XG5cbi8qKlxuICogU3RhdGljIFBhcnNlIE1ldGhvZFxuICovXG5QYXJzZXIucGFyc2UgPSBmdW5jdGlvbih0b2tlbnMsIG9wdGlvbnMsIHJlbmRlcmVyKSB7XG4gICAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIob3B0aW9ucywgcmVuZGVyZXIpO1xuICAgIHJldHVybiBwYXJzZXIucGFyc2UodG9rZW5zKTtcbn07XG5cbi8qKlxuICogUGFyc2UgTG9vcFxuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odG9rZW5zKSB7XG4gICAgdGhpcy5pbmxpbmUgPSBuZXcgSW5saW5lTGV4ZXIodG9rZW5zLmxpbmtzLCB0aGlzLm9wdGlvbnMsIHRoaXMucmVuZGVyZXIpO1xuICAgIHRoaXMudG9rZW5zID0gdG9rZW5zLnJldmVyc2UoKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMudG9BcnJheSkge1xuICAgICAgICB2YXIgb3V0ID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHdoaWxlICh0aGlzLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy50b2tlbjtcbiAgICAgICAgICAgIHZhciBmcmFnbWVudCA9IHRoaXMudG9rKCk7XG4gICAgICAgICAgICBpZiAoZnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICBvdXQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IGZyYWdtZW50LCBcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0b2tlbi5vZmZzZXQsIFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IHRva2VuLmxlbmd0aFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG91dCA9ICcnO1xuICAgICAgICB3aGlsZSAodGhpcy5uZXh0KCkpIHtcbiAgICAgICAgICAgIG91dCArPSB0aGlzLnRvaygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxufTtcblxuLyoqXG4gKiBOZXh0IFRva2VuXG4gKi9cblBhcnNlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRva2VuID0gdGhpcy50b2tlbnMucG9wKCk7XG59O1xuXG4vKipcbiAqIFByZXZpZXcgTmV4dCBUb2tlblxuICovXG5QYXJzZXIucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy50b2tlbnMubGVuZ3RoIC0gMV0gfHwgMDtcbn07XG5cbi8qKlxuICogUGFyc2UgVGV4dCBUb2tlbnNcbiAqL1xuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRleHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYm9keSA9IHRoaXMudG9rZW4udGV4dDtcbiAgICB3aGlsZSAodGhpcy5wZWVrKCkudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgIGJvZHkgKz0gJ1xcbicgKyB0aGlzLm5leHQoKS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pbmxpbmUub3V0cHV0KGJvZHkpO1xufTtcblxuLyoqXG4gKiBQYXJzZSBDdXJyZW50IFRva2VuICggZm9yIGJsb2NrIGdyYW1tYXIpXG4gKi9cblBhcnNlci5wcm90b3R5cGUudG9rID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlbmRlckZ1bmMgPSBicmVuZGVyc1t0aGlzLnRva2VuLnR5cGVdO1xuICAgIGlmIChyZW5kZXJGdW5jKSB7XG4gICAgICAgIHJldHVybiByZW5kZXJGdW5jKHRoaXMpO1xuICAgIH1cbn07XG5cbi8qKlxuICogSGVscGVyc1xuICovXG5mdW5jdGlvbiBlc2NhcGUoaHRtbCwgZW5jb2RlKSB7XG4gICAgcmV0dXJuIGh0bWxcbiAgICAgICAgLnJlcGxhY2UoIWVuY29kZSA/IC8mKD8hIz9cXHcrOykvZyA6IC8mL2csICcmYW1wOycpXG4gICAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAgICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgICAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXG4gICAgICAgIC5yZXBsYWNlKC8nL2csICcmIzM5OycpO1xufVxuXG5mdW5jdGlvbiB1bmVzY2FwZShodG1sKSB7XG4gICAgLy8gZXhwbGljaXRseSBtYXRjaCBkZWNpbWFsLCBoZXgsIGFuZCBuYW1lZCBIVE1MIGVudGl0aWVzIFxuICAgIHJldHVybiBodG1sLnJlcGxhY2UoLyYoIyg/OlxcZCspfCg/OiN4WzAtOUEtRmEtZl0rKXwoPzpcXHcrKSk7Py9nLCBmdW5jdGlvbihfLCBuKSB7XG4gICAgICAgIG4gPSBuLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChuID09PSAnY29sb24nKSByZXR1cm4gJzonO1xuICAgICAgICBpZiAobi5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgICAgcmV0dXJuIG4uY2hhckF0KDEpID09PSAneCdcbiAgICAgICAgICAgICAgICA/IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQobi5zdWJzdHJpbmcoMiksIDE2KSlcbiAgICAgICAgICAgICAgICA6IFN0cmluZy5mcm9tQ2hhckNvZGUoK24uc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2UocmVnZXgsIG9wdCkge1xuICAgIHJlZ2V4ID0gcmVnZXguc291cmNlO1xuICAgIG9wdCA9IG9wdCB8fCAnJztcbiAgICByZXR1cm4gZnVuY3Rpb24gc2VsZihuYW1lLCB2YWwpIHtcbiAgICAgICAgaWYgKCFuYW1lKSByZXR1cm4gbmV3IFJlZ0V4cChyZWdleCwgb3B0KTtcbiAgICAgICAgdmFsID0gdmFsLnNvdXJjZSB8fCB2YWw7XG4gICAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKC8oXnxbXlxcW10pXFxeL2csICckMScpO1xuICAgICAgICByZWdleCA9IHJlZ2V4LnJlcGxhY2UobmFtZSwgdmFsKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gbWVyZ2Uob2JqKSB7XG4gICAgdmFyIGkgPSAxXG4gICAgICAgICwgdGFyZ2V0XG4gICAgICAgICwga2V5O1xuXG4gICAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGFyZ2V0ID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBmb3IgKGtleSBpbiB0YXJnZXQpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgb2JqW2tleV0gPSB0YXJnZXRba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdmb3JtYXQoc3RyKSB7XG4gICAgZm9yICh2YXIgaSA9IDEgOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKCd7fScsIGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5cbi8qKlxuICogTWFuZ2xlIExpbmtzXG4gKi9cbmZ1bmN0aW9uIG1hbmdsZSh0ZXh0KSB7XG4gICAgdmFyIG91dCA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgdmFyIGNoID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNSkge1xuICAgICAgICAgICAgY2ggPSAneCcgKyBjaC50b1N0cmluZygxNik7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcmIycgKyBjaCArICc7JztcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTWFya2VkXG4gKi9cbmZ1bmN0aW9uIG1hcmtlZChzcmMsIG9wdCwgY2FsbGJhY2spIHtcbiAgICBpZiAoY2FsbGJhY2sgfHwgdHlwZW9mIG9wdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IG9wdDtcbiAgICAgICAgICAgIG9wdCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBvcHQgPSBtZXJnZSh7fSwgbWFya2VkLmRlZmF1bHRzLCBvcHQgfHwge30pO1xuXG4gICAgICAgIHZhciBoaWdobGlnaHQgPSBvcHQuaGlnaGxpZ2h0XG4gICAgICAgICAgICAsIHRva2Vuc1xuICAgICAgICAgICAgLCBwZW5kaW5nO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0b2tlbnMgPSBMZXhlci5sZXgoc3JjLCBvcHQpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBlbmRpbmcgPSB0b2tlbnMubGVuZ3RoO1xuXG4gICAgICAgIHZhciBkb25lID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgb3B0LmhpZ2hsaWdodCA9IGhpZ2hsaWdodDtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG91dDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb3V0ID0gUGFyc2VyLnBhcnNlKHRva2Vucywgb3B0KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBlcnIgPSBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvcHQuaGlnaGxpZ2h0ID0gaGlnaGxpZ2h0O1xuXG4gICAgICAgICAgICByZXR1cm4gZXJyID8gY2FsbGJhY2soZXJyKSA6IGNhbGxiYWNrKG51bGwsIG91dCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFoaWdobGlnaHQgfHwgaGlnaGxpZ2h0Lmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgb3B0LmhpZ2hsaWdodDtcblxuICAgICAgICBpZiAoIXBlbmRpbmcpIHJldHVybiBkb25lKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgdG9rZW5zLmxlbmd0aCA7IGkrKykge1xuICAgICAgICAgICAgKGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09ICdjb2RlJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLS1wZW5kaW5nIHx8IGRvbmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhpZ2hsaWdodCh0b2tlbi50ZXh0LCB0b2tlbi5sYW5nLCBmdW5jdGlvbihlcnIsIGNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPT0gbnVsbCB8fCBjb2RlID09PSB0b2tlbi50ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLS1wZW5kaW5nIHx8IGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0b2tlbi50ZXh0ID0gY29kZTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4uZXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC0tcGVuZGluZyB8fCBkb25lKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSh0b2tlbnNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAob3B0KSBvcHQgPSBtZXJnZSh7fSwgbWFya2VkLmRlZmF1bHRzLCBvcHQpO1xuICAgICAgICByZXR1cm4gUGFyc2VyLnBhcnNlKExleGVyLmxleChzcmMsIG9wdCksIG9wdCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlLm1lc3NhZ2UgKz0gJ1xcblBsZWFzZSByZXBvcnQgdGhpcyB0byB6aGZjaGRldkBnbWFpbC5jb20uJztcbiAgICAgICAgaWYgKChvcHQgfHwgbWFya2VkLmRlZmF1bHRzKS5zaWxlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdmb3JtYXQoJzxwPkFuIGVycm9yIG9jY3VyZWQ6PC9wPjxwcmU+e308L3ByZT4nLCBlc2NhcGUoZS5tZXNzYWdlICsgJycsIHRydWUpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBPcHRpb25zXG4gKi9cbm1hcmtlZC5vcHRpb25zID1cbm1hcmtlZC5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0KSB7XG4gICAgbWVyZ2UobWFya2VkLmRlZmF1bHRzLCBvcHQpO1xuICAgIHJldHVybiBtYXJrZWQ7XG59O1xuXG5tYXJrZWQuZGVmYXVsdHMgPSB7XG4gICAgZ2ZtOiB0cnVlLFxuICAgIHRhYmxlczogdHJ1ZSxcbiAgICBicmVha3M6IGZhbHNlLFxuICAgIHBlZGFudGljOiBmYWxzZSxcbiAgICBzYW5pdGl6ZTogZmFsc2UsXG4gICAgc2FuaXRpemVyOiBudWxsLFxuICAgIG1hbmdsZTogdHJ1ZSxcbiAgICBzbWFydExpc3RzOiBmYWxzZSxcbiAgICBzaWxlbnQ6IGZhbHNlLFxuICAgIGhpZ2hsaWdodDogbnVsbCxcbiAgICBsYW5nUHJlZml4OiAnbGFuZy0nLFxuICAgIHNtYXJ0eXBhbnRzOiBmYWxzZSxcbiAgICBoZWFkZXJQcmVmaXg6ICcnLFxuICAgIHhodG1sOiBmYWxzZSwgXG4gICAgdG9BcnJheTogZmFsc2Vcbn07XG5cbi8qKlxuICogRXhwb3NlXG4gKi9cbm1hcmtlZC5QYXJzZXIgPSBQYXJzZXI7XG5tYXJrZWQucGFyc2VyID0gUGFyc2VyLnBhcnNlO1xuXG5tYXJrZWQucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXI7XG5cbm1hcmtlZC5MZXhlciA9IExleGVyO1xubWFya2VkLmxleGVyID0gTGV4ZXIubGV4O1xuXG5tYXJrZWQuSW5saW5lTGV4ZXIgPSBJbmxpbmVMZXhlcjtcbm1hcmtlZC5pbmxpbmVMZXhlciA9IElubGluZUxleGVyLm91dHB1dDtcblxubWFya2VkLnBhcnNlID0gbWFya2VkO1xuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtYXJrZWQ7XG59IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIG1hcmtlZDsgfSk7XG59IGVsc2Uge1xuICAgIHRoaXMubWFya2VkID0gbWFya2VkO1xufVxuXG59KS5jYWxsKGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcyB8fCAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwpO1xufSgpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL21hcmtlZC5jb3JlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9")},function(g,n,I){g.exports=I(3)}])});